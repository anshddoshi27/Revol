"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/public/[slug]/bookings/route";
exports.ids = ["app/api/public/[slug]/bookings/route"];
exports.modules = {

/***/ "../../client/components/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/client/components/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/action-async-storage.external.js");

/***/ }),

/***/ "../../client/components/request-async-storage.external":
/*!********************************************************************************!*\
  !*** external "next/dist/client/components/request-async-storage.external.js" ***!
  \********************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/request-async-storage.external.js");

/***/ }),

/***/ "../../client/components/static-generation-async-storage.external":
/*!******************************************************************************************!*\
  !*** external "next/dist/client/components/static-generation-async-storage.external.js" ***!
  \******************************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/static-generation-async-storage.external.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute&page=%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute.ts&appDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute&page=%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute.ts&appDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_3017387smacbookm_Downloads_Career_Tithi_apps_web_src_app_api_public_slug_bookings_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/public/[slug]/bookings/route.ts */ \"(rsc)/./src/app/api/public/[slug]/bookings/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/public/[slug]/bookings/route\",\n        pathname: \"/api/public/[slug]/bookings\",\n        filename: \"route\",\n        bundlePath: \"app/api/public/[slug]/bookings/route\"\n    },\n    resolvedPagePath: \"/Users/3017387smacbookm/Downloads/Career/Tithi/apps/web/src/app/api/public/[slug]/bookings/route.ts\",\n    nextConfigOutput,\n    userland: _Users_3017387smacbookm_Downloads_Career_Tithi_apps_web_src_app_api_public_slug_bookings_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/public/[slug]/bookings/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZwdWJsaWMlMkYlNUJzbHVnJTVEJTJGYm9va2luZ3MlMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRnB1YmxpYyUyRiU1QnNsdWclNUQlMkZib29raW5ncyUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRnB1YmxpYyUyRiU1QnNsdWclNUQlMkZib29raW5ncyUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRjMwMTczODdzbWFjYm9va20lMkZEb3dubG9hZHMlMkZDYXJlZXIlMkZUaXRoaSUyRmFwcHMlMkZ3ZWIlMkZzcmMlMkZhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPSUyRlVzZXJzJTJGMzAxNzM4N3NtYWNib29rbSUyRkRvd25sb2FkcyUyRkNhcmVlciUyRlRpdGhpJTJGYXBwcyUyRndlYiZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD0mcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ2M7QUFDbUQ7QUFDaEk7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdIQUFtQjtBQUMzQztBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVk7QUFDWixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBaUU7QUFDekU7QUFDQTtBQUNBLFdBQVcsNEVBQVc7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUN1SDs7QUFFdkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvPzgzMTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiL1VzZXJzLzMwMTczODdzbWFjYm9va20vRG93bmxvYWRzL0NhcmVlci9UaXRoaS9hcHBzL3dlYi9zcmMvYXBwL2FwaS9wdWJsaWMvW3NsdWddL2Jvb2tpbmdzL3JvdXRlLnRzXCI7XG4vLyBXZSBpbmplY3QgdGhlIG5leHRDb25maWdPdXRwdXQgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IG5leHRDb25maWdPdXRwdXQgPSBcIlwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9wdWJsaWMvW3NsdWddL2Jvb2tpbmdzL3JvdXRlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvcHVibGljL1tzbHVnXS9ib29raW5nc1wiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvcHVibGljL1tzbHVnXS9ib29raW5ncy9yb3V0ZVwiXG4gICAgfSxcbiAgICByZXNvbHZlZFBhZ2VQYXRoOiBcIi9Vc2Vycy8zMDE3Mzg3c21hY2Jvb2ttL0Rvd25sb2Fkcy9DYXJlZXIvVGl0aGkvYXBwcy93ZWIvc3JjL2FwcC9hcGkvcHVibGljL1tzbHVnXS9ib29raW5ncy9yb3V0ZS50c1wiLFxuICAgIG5leHRDb25maWdPdXRwdXQsXG4gICAgdXNlcmxhbmRcbn0pO1xuLy8gUHVsbCBvdXQgdGhlIGV4cG9ydHMgdGhhdCB3ZSBuZWVkIHRvIGV4cG9zZSBmcm9tIHRoZSBtb2R1bGUuIFRoaXMgc2hvdWxkXG4vLyBiZSBlbGltaW5hdGVkIHdoZW4gd2UndmUgbW92ZWQgdGhlIG90aGVyIHJvdXRlcyB0byB0aGUgbmV3IGZvcm1hdC4gVGhlc2Vcbi8vIGFyZSB1c2VkIHRvIGhvb2sgaW50byB0aGUgcm91dGUuXG5jb25zdCB7IHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmNvbnN0IG9yaWdpbmFsUGF0aG5hbWUgPSBcIi9hcGkvcHVibGljL1tzbHVnXS9ib29raW5ncy9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute&page=%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute.ts&appDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./src/app/api/public/[slug]/bookings/route.ts":
/*!*****************************************************!*\
  !*** ./src/app/api/public/[slug]/bookings/route.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/db */ \"(rsc)/./src/lib/db.ts\");\n/* harmony import */ var _lib_stripe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/stripe */ \"(rsc)/./src/lib/stripe.ts\");\n/* harmony import */ var _lib_notifications__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/notifications */ \"(rsc)/./src/lib/notifications.ts\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n/**\n * POST /api/public/{slug}/bookings\n * \n * Creates a new booking with card setup (no charge yet)\n * No authentication required - this is a public endpoint\n * \n * Body: {\n *   service_id: string\n *   staff_id: string\n *   start_at: string (ISO timestamp)\n *   customer: { name, email, phone }\n *   gift_card_code?: string\n *   consent_ip?: string\n *   consent_user_agent?: string\n * }\n */ async function POST(request, { params }) {\n    try {\n        const { slug } = params;\n        const body = await request.json();\n        const { service_id, staff_id, start_at, customer, gift_card_code } = body;\n        // Extract consent metadata from headers (for production compliance)\n        const consent_ip = request.headers.get(\"x-forwarded-for\")?.split(\",\")[0]?.trim() || request.headers.get(\"x-real-ip\") || null;\n        const consent_user_agent = request.headers.get(\"user-agent\") || null;\n        if (!slug) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Subdomain is required\"\n            }, {\n                status: 400\n            });\n        }\n        // Validate required fields\n        if (!service_id || !staff_id || !start_at || !customer) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Missing required fields: service_id, staff_id, start_at, customer\"\n            }, {\n                status: 400\n            });\n        }\n        if (!customer.name || !customer.email) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Customer name and email are required\"\n            }, {\n                status: 400\n            });\n        }\n        const supabase = (0,_lib_db__WEBPACK_IMPORTED_MODULE_1__.createAdminClient)();\n        // Get business by subdomain (only active or trial businesses can accept bookings)\n        const { data: business, error: businessError } = await supabase.from(\"businesses\").select(\"*\").eq(\"subdomain\", slug.toLowerCase()).in(\"subscription_status\", [\n            \"active\",\n            \"trial\"\n        ]).is(\"deleted_at\", null).single();\n        if (businessError || !business) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Business not found\"\n            }, {\n                status: 404\n            });\n        }\n        // Get service details\n        const { data: service, error: serviceError } = await supabase.from(\"services\").select(\"*\").eq(\"id\", service_id).eq(\"business_id\", business.id).eq(\"is_active\", true).is(\"deleted_at\", null).single();\n        if (serviceError || !service) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Service not found\"\n            }, {\n                status: 404\n            });\n        }\n        // Validate slot is still available (check unique constraint)\n        const startAtDate = new Date(start_at);\n        const endAtDate = new Date(startAtDate.getTime() + service.duration_min * 60 * 1000);\n        // Check for existing bookings that overlap with this time slot\n        const { data: existingBookings, error: bookingCheckError } = await supabase.from(\"bookings\").select(\"id, start_at, end_at\").eq(\"staff_id\", staff_id).eq(\"business_id\", business.id).in(\"status\", [\n            \"pending\",\n            \"scheduled\",\n            \"held\"\n        ]).is(\"deleted_at\", null);\n        if (bookingCheckError) {\n            console.error(\"Error checking existing bookings:\", bookingCheckError);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Failed to validate slot availability\"\n            }, {\n                status: 500\n            });\n        }\n        // Check if any existing booking overlaps with the requested slot\n        const hasOverlap = existingBookings?.some((booking)=>{\n            const bookingStart = new Date(booking.start_at);\n            const bookingEnd = new Date(booking.end_at || booking.start_at);\n            // Check if time ranges overlap\n            return startAtDate < bookingEnd && endAtDate > bookingStart;\n        });\n        if (hasOverlap) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"This time slot is no longer available\"\n            }, {\n                status: 409\n            });\n        }\n        // Validate gift card if provided\n        let final_price_cents = service.price_cents;\n        let gift_card_id = null;\n        let gift_card_amount_applied_cents = 0;\n        if (gift_card_code) {\n            const { data: giftCard, error: giftCardError } = await supabase.from(\"gift_cards\").select(\"*\").eq(\"user_id\", business.user_id).eq(\"business_id\", business.id).eq(\"code\", gift_card_code.toUpperCase().trim()).eq(\"is_active\", true).is(\"deleted_at\", null).single();\n            if (giftCardError || !giftCard) {\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Invalid gift card code\"\n                }, {\n                    status: 400\n                });\n            }\n            // Check expiration\n            if (giftCard.expires_at && new Date(giftCard.expires_at) < new Date()) {\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Gift card has expired\"\n                }, {\n                    status: 400\n                });\n            }\n            gift_card_id = giftCard.id;\n            // Calculate discount\n            if (giftCard.discount_type === \"amount\") {\n                // For amount-type gift cards, calculate remaining balance\n                // by subtracting amounts already applied in pending/completed bookings\n                const { data: existingBookings } = await supabase.from(\"bookings\").select(\"gift_card_amount_applied_cents, status\").eq(\"gift_card_id\", giftCard.id).in(\"status\", [\n                    \"pending\",\n                    \"scheduled\",\n                    \"completed\",\n                    \"held\"\n                ]).is(\"deleted_at\", null);\n                // Sum up amounts already applied in pending/completed bookings\n                const alreadyAppliedCents = existingBookings?.reduce((sum, booking)=>{\n                    return sum + (booking.gift_card_amount_applied_cents || 0);\n                }, 0) || 0;\n                // Calculate remaining available balance\n                const remainingBalanceCents = Math.max(0, giftCard.current_balance_cents - alreadyAppliedCents);\n                // Check if there's any remaining balance\n                if (remainingBalanceCents <= 0) {\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                        error: \"Gift card has no remaining balance\"\n                    }, {\n                        status: 400\n                    });\n                }\n                // Apply only the remaining balance (not the full current_balance_cents)\n                gift_card_amount_applied_cents = Math.min(remainingBalanceCents, service.price_cents);\n                final_price_cents = service.price_cents - gift_card_amount_applied_cents;\n            } else if (giftCard.discount_type === \"percent\") {\n                const percentOff = giftCard.percent_off || 0;\n                if (percentOff <= 0 || percentOff > 100) {\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                        error: \"Invalid gift card discount percentage\"\n                    }, {\n                        status: 400\n                    });\n                }\n                gift_card_amount_applied_cents = Math.round(service.price_cents * percentOff / 100);\n                final_price_cents = service.price_cents - gift_card_amount_applied_cents;\n            }\n            if (final_price_cents < 0) {\n                final_price_cents = 0;\n                gift_card_amount_applied_cents = service.price_cents;\n            }\n        }\n        // Get current active policy and create snapshot\n        const { data: policy, error: policyError } = await supabase.from(\"business_policies\").select(\"*\").eq(\"business_id\", business.id).eq(\"is_active\", true).order(\"version\", {\n            ascending: false\n        }).limit(1).maybeSingle();\n        if (policyError) {\n            console.error(\"Error fetching business policies:\", policyError);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Failed to fetch business policies\",\n                details: policyError.message\n            }, {\n                status: 500\n            });\n        }\n        if (!policy) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Business policies not found\"\n            }, {\n                status: 500\n            });\n        }\n        // Create policy snapshot with all required fields\n        const policySnapshot = {\n            cancellation_policy_text: policy.cancellation_policy_text,\n            no_show_policy_text: policy.no_show_policy_text,\n            refund_policy_text: policy.refund_policy_text,\n            cash_policy_text: policy.cash_policy_text,\n            no_show_fee_type: policy.no_show_fee_type,\n            no_show_fee_amount_cents: policy.no_show_fee_amount_cents,\n            no_show_fee_percent: policy.no_show_fee_percent,\n            cancel_fee_type: policy.cancel_fee_type,\n            cancel_fee_amount_cents: policy.cancel_fee_amount_cents,\n            cancel_fee_percent: policy.cancel_fee_percent,\n            version: policy.version,\n            snapshot_at: new Date().toISOString()\n        };\n        // Calculate policy hash for compliance (SHA-256 of policy snapshot)\n        const policyHash = (0,crypto__WEBPACK_IMPORTED_MODULE_4__.createHash)(\"sha256\").update(JSON.stringify(policySnapshot)).digest(\"hex\");\n        // Create or find customer\n        let customerId;\n        let stripeCustomerId;\n        const { data: existingCustomer } = await supabase.from(\"customers\").select(\"id, stripe_customer_id\").eq(\"business_id\", business.id).eq(\"email\", customer.email.toLowerCase().trim()).single();\n        if (existingCustomer) {\n            customerId = existingCustomer.id;\n            // Update customer info if needed\n            const updateData = {\n                name: customer.name,\n                updated_at: new Date().toISOString()\n            };\n            if (customer.phone) {\n                // Format phone number (E.164 format: +1 followed by 10 digits)\n                console.log(\"[booking-api] Updating existing customer phone:\", customer.phone, \"length:\", customer.phone.length);\n                const digits = customer.phone.replace(/\\D/g, \"\");\n                console.log(\"[booking-api] Digits extracted for update:\", digits, \"length:\", digits.length);\n                if (digits.length === 11 && digits.startsWith(\"1\")) {\n                    updateData.phone = `+${digits}`;\n                } else if (digits.length === 10) {\n                    updateData.phone = `+1${digits}`;\n                } else if (customer.phone.startsWith(\"+\")) {\n                    const plusDigits = customer.phone.replace(/[^\\d]/g, \"\");\n                    if (plusDigits.length === 11 && plusDigits.startsWith(\"1\")) {\n                        updateData.phone = customer.phone;\n                    } else if (plusDigits.length === 10) {\n                        updateData.phone = `+1${plusDigits}`;\n                    } else {\n                        updateData.phone = customer.phone;\n                    }\n                } else if (digits.length >= 10) {\n                    const last10 = digits.slice(-10);\n                    updateData.phone = `+1${last10}`;\n                } else {\n                    updateData.phone = customer.phone;\n                }\n                console.log(\"[booking-api] Formatted phone for update:\", updateData.phone, \"length:\", updateData.phone?.length);\n            }\n            await supabase.from(\"customers\").update(updateData).eq(\"id\", customerId);\n            // Get or create Stripe Customer ID\n            if (existingCustomer.stripe_customer_id) {\n                stripeCustomerId = existingCustomer.stripe_customer_id;\n            } else {\n                stripeCustomerId = await (0,_lib_stripe__WEBPACK_IMPORTED_MODULE_2__.createOrGetCustomer)(customer.email.toLowerCase().trim(), customer.name, {\n                    business_id: business.id\n                });\n                await supabase.from(\"customers\").update({\n                    stripe_customer_id: stripeCustomerId\n                }).eq(\"id\", customerId);\n            }\n        } else {\n            // Create Stripe Customer first\n            stripeCustomerId = await (0,_lib_stripe__WEBPACK_IMPORTED_MODULE_2__.createOrGetCustomer)(customer.email.toLowerCase().trim(), customer.name, {\n                business_id: business.id\n            });\n            // Format phone number (E.164 format: +1 followed by 10 digits)\n            let formattedPhone = null;\n            if (customer.phone) {\n                // Log original phone for debugging\n                console.log(\"[booking-api] Original phone from request:\", customer.phone, \"length:\", customer.phone.length);\n                // Remove all non-digits\n                const digits = customer.phone.replace(/\\D/g, \"\");\n                console.log(\"[booking-api] Digits extracted:\", digits, \"length:\", digits.length);\n                // If it starts with 1 and has 11 digits, add +\n                if (digits.length === 11 && digits.startsWith(\"1\")) {\n                    formattedPhone = `+${digits}`;\n                } else if (digits.length === 10) {\n                    formattedPhone = `+1${digits}`;\n                } else if (customer.phone.startsWith(\"+\")) {\n                    const plusDigits = customer.phone.replace(/[^\\d]/g, \"\");\n                    if (plusDigits.length === 11 && plusDigits.startsWith(\"1\")) {\n                        formattedPhone = customer.phone;\n                    } else if (plusDigits.length === 10) {\n                        formattedPhone = `+1${plusDigits}`;\n                    } else {\n                        // Invalid format, but save as-is for now\n                        formattedPhone = customer.phone;\n                    }\n                } else if (digits.length >= 10) {\n                    // Take last 10 digits if more than 10\n                    const last10 = digits.slice(-10);\n                    formattedPhone = `+1${last10}`;\n                } else {\n                    // Too short, save as-is (will fail validation later)\n                    formattedPhone = customer.phone;\n                }\n                console.log(\"[booking-api] Formatted phone:\", formattedPhone, \"length:\", formattedPhone?.length);\n            }\n            // Create customer record\n            const { data: newCustomer, error: customerError } = await supabase.from(\"customers\").insert({\n                user_id: business.user_id,\n                business_id: business.id,\n                name: customer.name,\n                email: customer.email.toLowerCase().trim(),\n                phone: formattedPhone,\n                stripe_customer_id: stripeCustomerId,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            }).select(\"id\").single();\n            if (customerError || !newCustomer) {\n                console.error(\"Error creating customer:\", customerError);\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Failed to create customer\",\n                    details: customerError?.message\n                }, {\n                    status: 500\n                });\n            }\n            customerId = newCustomer.id;\n        }\n        // Create booking\n        const { data: booking, error: bookingError } = await supabase.from(\"bookings\").insert({\n            user_id: business.user_id,\n            business_id: business.id,\n            customer_id: customerId,\n            service_id,\n            staff_id,\n            status: \"pending\",\n            start_at: start_at,\n            end_at: endAtDate.toISOString(),\n            duration_min: service.duration_min,\n            price_cents: service.price_cents,\n            final_price_cents,\n            gift_card_id,\n            gift_card_amount_applied_cents,\n            source: \"public\",\n            policy_snapshot: policySnapshot,\n            // policy_hash: policyHash, // Column doesn't exist in schema - removed\n            consent_at: new Date().toISOString(),\n            consent_ip: consent_ip || null,\n            consent_user_agent: consent_user_agent || null,\n            payment_status: \"none\",\n            last_money_action: \"none\",\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString()\n        }).select(\"id\").single();\n        if (bookingError || !booking) {\n            console.error(\"Error creating booking:\", bookingError);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Failed to create booking\",\n                details: bookingError?.message\n            }, {\n                status: 500\n            });\n        }\n        // Create SetupIntent to save card (must use Stripe Customer ID, not email)\n        if (!stripeCustomerId) {\n            console.error(\"No Stripe customer ID available for SetupIntent\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Failed to set up payment method\"\n            }, {\n                status: 500\n            });\n        }\n        const setupIntent = await (0,_lib_stripe__WEBPACK_IMPORTED_MODULE_2__.createSetupIntent)(stripeCustomerId, {\n            booking_id: booking.id,\n            business_id: business.id\n        });\n        // Create booking payment record (status will be updated to 'card_saved' by webhook when SetupIntent succeeds)\n        const { error: paymentError } = await supabase.from(\"booking_payments\").insert({\n            user_id: business.user_id,\n            business_id: business.id,\n            booking_id: booking.id,\n            stripe_setup_intent_id: setupIntent.setupIntentId,\n            amount_cents: final_price_cents,\n            money_action: \"none\",\n            status: \"none\",\n            currency: \"usd\",\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString()\n        });\n        if (paymentError) {\n            console.error(\"Error creating booking payment:\", paymentError);\n        // Continue anyway - payment can be updated later\n        }\n        // Generate booking code (e.g., TITHI-1234)\n        const bookingCode = `TITHI-${booking.id.slice(0, 8).toUpperCase()}`;\n        // Emit booking_created notification (async, don't wait)\n        console.log(`[public-booking] Emitting booking_created notification for business ${business.id}, booking ${booking.id}, notifications_enabled: ${business.notifications_enabled}`);\n        (0,_lib_notifications__WEBPACK_IMPORTED_MODULE_3__.emitNotification)(business.id, \"booking_created\", booking.id, supabase).catch((err)=>{\n            console.error(\"[public-booking] Error emitting booking_created notification:\", err);\n        // Don't fail the request if notification fails\n        });\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            booking_id: booking.id,\n            booking_code: bookingCode,\n            client_secret: setupIntent.clientSecret,\n            setup_intent_id: setupIntent.setupIntentId,\n            final_price_cents,\n            message: \"Booking created successfully. Please complete payment setup.\"\n        });\n    } catch (error) {\n        console.error(\"Error in public booking:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Internal server error\",\n            details: error instanceof Error ? error.message : \"Unknown error\"\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvYXBwL2FwaS9wdWJsaWMvW3NsdWddL2Jvb2tpbmdzL3JvdXRlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMkM7QUFDRTtBQUMwRDtBQUNoRDtBQUNuQjtBQUVwQzs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDTSxlQUFlTSxLQUNwQkMsT0FBZ0IsRUFDaEIsRUFBRUMsTUFBTSxFQUFnQztJQUV4QyxJQUFJO1FBQ0YsTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBR0Q7UUFDakIsTUFBTUUsT0FBTyxNQUFNSCxRQUFRSSxJQUFJO1FBQy9CLE1BQU0sRUFDSkMsVUFBVSxFQUNWQyxRQUFRLEVBQ1JDLFFBQVEsRUFDUkMsUUFBUSxFQUNSQyxjQUFjLEVBQ2YsR0FBR047UUFFSixvRUFBb0U7UUFDcEUsTUFBTU8sYUFBYVYsUUFBUVcsT0FBTyxDQUFDQyxHQUFHLENBQUMsb0JBQW9CQyxNQUFNLElBQUksQ0FBQyxFQUFFLEVBQUVDLFVBQ3hEZCxRQUFRVyxPQUFPLENBQUNDLEdBQUcsQ0FBQyxnQkFDcEI7UUFDbEIsTUFBTUcscUJBQXFCZixRQUFRVyxPQUFPLENBQUNDLEdBQUcsQ0FBQyxpQkFBaUI7UUFFaEUsSUFBSSxDQUFDVixNQUFNO1lBQ1QsT0FBT1QscURBQVlBLENBQUNXLElBQUksQ0FDdEI7Z0JBQUVZLE9BQU87WUFBd0IsR0FDakM7Z0JBQUVDLFFBQVE7WUFBSTtRQUVsQjtRQUVBLDJCQUEyQjtRQUMzQixJQUFJLENBQUNaLGNBQWMsQ0FBQ0MsWUFBWSxDQUFDQyxZQUFZLENBQUNDLFVBQVU7WUFDdEQsT0FBT2YscURBQVlBLENBQUNXLElBQUksQ0FDdEI7Z0JBQUVZLE9BQU87WUFBb0UsR0FDN0U7Z0JBQUVDLFFBQVE7WUFBSTtRQUVsQjtRQUVBLElBQUksQ0FBQ1QsU0FBU1UsSUFBSSxJQUFJLENBQUNWLFNBQVNXLEtBQUssRUFBRTtZQUNyQyxPQUFPMUIscURBQVlBLENBQUNXLElBQUksQ0FDdEI7Z0JBQUVZLE9BQU87WUFBdUMs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bGljL1tzbHVnXS9ib29raW5ncy9yb3V0ZS50cz80ZGJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB7IGNyZWF0ZUFkbWluQ2xpZW50IH0gZnJvbSAnQC9saWIvZGInO1xuaW1wb3J0IHsgY3JlYXRlT3JHZXRDdXN0b21lciwgY3JlYXRlU2V0dXBJbnRlbnQsIGdldFBheW1lbnRNZXRob2RGcm9tU2V0dXBJbnRlbnQgfSBmcm9tICdAL2xpYi9zdHJpcGUnO1xuaW1wb3J0IHsgZW1pdE5vdGlmaWNhdGlvbiB9IGZyb20gJ0AvbGliL25vdGlmaWNhdGlvbnMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaCB9IGZyb20gJ2NyeXB0byc7XG5cbi8qKlxuICogUE9TVCAvYXBpL3B1YmxpYy97c2x1Z30vYm9va2luZ3NcbiAqIFxuICogQ3JlYXRlcyBhIG5ldyBib29raW5nIHdpdGggY2FyZCBzZXR1cCAobm8gY2hhcmdlIHlldClcbiAqIE5vIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkIC0gdGhpcyBpcyBhIHB1YmxpYyBlbmRwb2ludFxuICogXG4gKiBCb2R5OiB7XG4gKiAgIHNlcnZpY2VfaWQ6IHN0cmluZ1xuICogICBzdGFmZl9pZDogc3RyaW5nXG4gKiAgIHN0YXJ0X2F0OiBzdHJpbmcgKElTTyB0aW1lc3RhbXApXG4gKiAgIGN1c3RvbWVyOiB7IG5hbWUsIGVtYWlsLCBwaG9uZSB9XG4gKiAgIGdpZnRfY2FyZF9jb2RlPzogc3RyaW5nXG4gKiAgIGNvbnNlbnRfaXA/OiBzdHJpbmdcbiAqICAgY29uc2VudF91c2VyX2FnZW50Pzogc3RyaW5nXG4gKiB9XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKFxuICByZXF1ZXN0OiBSZXF1ZXN0LFxuICB7IHBhcmFtcyB9OiB7IHBhcmFtczogeyBzbHVnOiBzdHJpbmcgfSB9XG4pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IHNsdWcgfSA9IHBhcmFtcztcbiAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gICAgY29uc3Qge1xuICAgICAgc2VydmljZV9pZCxcbiAgICAgIHN0YWZmX2lkLFxuICAgICAgc3RhcnRfYXQsXG4gICAgICBjdXN0b21lcixcbiAgICAgIGdpZnRfY2FyZF9jb2RlLFxuICAgIH0gPSBib2R5O1xuXG4gICAgLy8gRXh0cmFjdCBjb25zZW50IG1ldGFkYXRhIGZyb20gaGVhZGVycyAoZm9yIHByb2R1Y3Rpb24gY29tcGxpYW5jZSlcbiAgICBjb25zdCBjb25zZW50X2lwID0gcmVxdWVzdC5oZWFkZXJzLmdldCgneC1mb3J3YXJkZWQtZm9yJyk/LnNwbGl0KCcsJylbMF0/LnRyaW0oKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuZ2V0KCd4LXJlYWwtaXAnKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIGNvbnN0IGNvbnNlbnRfdXNlcl9hZ2VudCA9IHJlcXVlc3QuaGVhZGVycy5nZXQoJ3VzZXItYWdlbnQnKSB8fCBudWxsO1xuXG4gICAgaWYgKCFzbHVnKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdTdWJkb21haW4gaXMgcmVxdWlyZWQnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSByZXF1aXJlZCBmaWVsZHNcbiAgICBpZiAoIXNlcnZpY2VfaWQgfHwgIXN0YWZmX2lkIHx8ICFzdGFydF9hdCB8fCAhY3VzdG9tZXIpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ01pc3NpbmcgcmVxdWlyZWQgZmllbGRzOiBzZXJ2aWNlX2lkLCBzdGFmZl9pZCwgc3RhcnRfYXQsIGN1c3RvbWVyJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjdXN0b21lci5uYW1lIHx8ICFjdXN0b21lci5lbWFpbCkge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnQ3VzdG9tZXIgbmFtZSBhbmQgZW1haWwgYXJlIHJlcXVpcmVkJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVBZG1pbkNsaWVudCgpO1xuXG4gICAgLy8gR2V0IGJ1c2luZXNzIGJ5IHN1YmRvbWFpbiAob25seSBhY3RpdmUgb3IgdHJpYWwgYnVzaW5lc3NlcyBjYW4gYWNjZXB0IGJvb2tpbmdzKVxuICAgIGNvbnN0IHsgZGF0YTogYnVzaW5lc3MsIGVycm9yOiBidXNpbmVzc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2J1c2luZXNzZXMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ3N1YmRvbWFpbicsIHNsdWcudG9Mb3dlckNhc2UoKSlcbiAgICAgIC5pbignc3Vic2NyaXB0aW9uX3N0YXR1cycsIFsnYWN0aXZlJywgJ3RyaWFsJ10pXG4gICAgICAuaXMoJ2RlbGV0ZWRfYXQnLCBudWxsKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKGJ1c2luZXNzRXJyb3IgfHwgIWJ1c2luZXNzKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdCdXNpbmVzcyBub3QgZm91bmQnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDQgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgc2VydmljZSBkZXRhaWxzXG4gICAgY29uc3QgeyBkYXRhOiBzZXJ2aWNlLCBlcnJvcjogc2VydmljZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3NlcnZpY2VzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdpZCcsIHNlcnZpY2VfaWQpXG4gICAgICAuZXEoJ2J1c2luZXNzX2lkJywgYnVzaW5lc3MuaWQpXG4gICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG4gICAgICAuaXMoJ2RlbGV0ZWRfYXQnLCBudWxsKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKHNlcnZpY2VFcnJvciB8fCAhc2VydmljZSkge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnU2VydmljZSBub3QgZm91bmQnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDQgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBzbG90IGlzIHN0aWxsIGF2YWlsYWJsZSAoY2hlY2sgdW5pcXVlIGNvbnN0cmFpbnQpXG4gICAgY29uc3Qgc3RhcnRBdERhdGUgPSBuZXcgRGF0ZShzdGFydF9hdCk7XG4gICAgY29uc3QgZW5kQXREYXRlID0gbmV3IERhdGUoc3RhcnRBdERhdGUuZ2V0VGltZSgpICsgc2VydmljZS5kdXJhdGlvbl9taW4gKiA2MCAqIDEwMDApO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGV4aXN0aW5nIGJvb2tpbmdzIHRoYXQgb3ZlcmxhcCB3aXRoIHRoaXMgdGltZSBzbG90XG4gICAgY29uc3QgeyBkYXRhOiBleGlzdGluZ0Jvb2tpbmdzLCBlcnJvcjogYm9va2luZ0NoZWNrRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYm9va2luZ3MnKVxuICAgICAgLnNlbGVjdCgnaWQsIHN0YXJ0X2F0LCBlbmRfYXQnKVxuICAgICAgLmVxKCdzdGFmZl9pZCcsIHN0YWZmX2lkKVxuICAgICAgLmVxKCdidXNpbmVzc19pZCcsIGJ1c2luZXNzLmlkKVxuICAgICAgLmluKCdzdGF0dXMnLCBbJ3BlbmRpbmcnLCAnc2NoZWR1bGVkJywgJ2hlbGQnXSlcbiAgICAgIC5pcygnZGVsZXRlZF9hdCcsIG51bGwpO1xuXG4gICAgaWYgKGJvb2tpbmdDaGVja0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBleGlzdGluZyBib29raW5nczonLCBib29raW5nQ2hlY2tFcnJvcik7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdGYWlsZWQgdG8gdmFsaWRhdGUgc2xvdCBhdmFpbGFiaWxpdHknIH0sXG4gICAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhbnkgZXhpc3RpbmcgYm9va2luZyBvdmVybGFwcyB3aXRoIHRoZSByZXF1ZXN0ZWQgc2xvdFxuICAgIGNvbnN0IGhhc092ZXJsYXAgPSBleGlzdGluZ0Jvb2tpbmdzPy5zb21lKGJvb2tpbmcgPT4ge1xuICAgICAgY29uc3QgYm9va2luZ1N0YXJ0ID0gbmV3IERhdGUoYm9va2luZy5zdGFydF9hdCk7XG4gICAgICBjb25zdCBib29raW5nRW5kID0gbmV3IERhdGUoYm9va2luZy5lbmRfYXQgfHwgYm9va2luZy5zdGFydF9hdCk7XG4gICAgICAvLyBDaGVjayBpZiB0aW1lIHJhbmdlcyBvdmVybGFwXG4gICAgICByZXR1cm4gc3RhcnRBdERhdGUgPCBib29raW5nRW5kICYmIGVuZEF0RGF0ZSA+IGJvb2tpbmdTdGFydDtcbiAgICB9KTtcblxuICAgIGlmIChoYXNPdmVybGFwKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdUaGlzIHRpbWUgc2xvdCBpcyBubyBsb25nZXIgYXZhaWxhYmxlJyB9LFxuICAgICAgICB7IHN0YXR1czogNDA5IH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgZ2lmdCBjYXJkIGlmIHByb3ZpZGVkXG4gICAgbGV0IGZpbmFsX3ByaWNlX2NlbnRzID0gc2VydmljZS5wcmljZV9jZW50cztcbiAgICBsZXQgZ2lmdF9jYXJkX2lkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgZ2lmdF9jYXJkX2Ftb3VudF9hcHBsaWVkX2NlbnRzID0gMDtcblxuICAgIGlmIChnaWZ0X2NhcmRfY29kZSkge1xuICAgICAgY29uc3QgeyBkYXRhOiBnaWZ0Q2FyZCwgZXJyb3I6IGdpZnRDYXJkRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdnaWZ0X2NhcmRzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIGJ1c2luZXNzLnVzZXJfaWQpXG4gICAgICAgIC5lcSgnYnVzaW5lc3NfaWQnLCBidXNpbmVzcy5pZClcbiAgICAgICAgLmVxKCdjb2RlJywgZ2lmdF9jYXJkX2NvZGUudG9VcHBlckNhc2UoKS50cmltKCkpXG4gICAgICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcbiAgICAgICAgLmlzKCdkZWxldGVkX2F0JywgbnVsbClcbiAgICAgICAgLnNpbmdsZSgpO1xuXG4gICAgICBpZiAoZ2lmdENhcmRFcnJvciB8fCAhZ2lmdENhcmQpIHtcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICAgIHsgZXJyb3I6ICdJbnZhbGlkIGdpZnQgY2FyZCBjb2RlJyB9LFxuICAgICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBleHBpcmF0aW9uXG4gICAgICBpZiAoZ2lmdENhcmQuZXhwaXJlc19hdCAmJiBuZXcgRGF0ZShnaWZ0Q2FyZC5leHBpcmVzX2F0KSA8IG5ldyBEYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICAgIHsgZXJyb3I6ICdHaWZ0IGNhcmQgaGFzIGV4cGlyZWQnIH0sXG4gICAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGdpZnRfY2FyZF9pZCA9IGdpZnRDYXJkLmlkO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgZGlzY291bnRcbiAgICAgIGlmIChnaWZ0Q2FyZC5kaXNjb3VudF90eXBlID09PSAnYW1vdW50Jykge1xuICAgICAgICAvLyBGb3IgYW1vdW50LXR5cGUgZ2lmdCBjYXJkcywgY2FsY3VsYXRlIHJlbWFpbmluZyBiYWxhbmNlXG4gICAgICAgIC8vIGJ5IHN1YnRyYWN0aW5nIGFtb3VudHMgYWxyZWFkeSBhcHBsaWVkIGluIHBlbmRpbmcvY29tcGxldGVkIGJvb2tpbmdzXG4gICAgICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdCb29raW5ncyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnYm9va2luZ3MnKVxuICAgICAgICAgIC5zZWxlY3QoJ2dpZnRfY2FyZF9hbW91bnRfYXBwbGllZF9jZW50cywgc3RhdHVzJylcbiAgICAgICAgICAuZXEoJ2dpZnRfY2FyZF9pZCcsIGdpZnRDYXJkLmlkKVxuICAgICAgICAgIC5pbignc3RhdHVzJywgWydwZW5kaW5nJywgJ3NjaGVkdWxlZCcsICdjb21wbGV0ZWQnLCAnaGVsZCddKVxuICAgICAgICAgIC5pcygnZGVsZXRlZF9hdCcsIG51bGwpO1xuXG4gICAgICAgIC8vIFN1bSB1cCBhbW91bnRzIGFscmVhZHkgYXBwbGllZCBpbiBwZW5kaW5nL2NvbXBsZXRlZCBib29raW5nc1xuICAgICAgICBjb25zdCBhbHJlYWR5QXBwbGllZENlbnRzID0gZXhpc3RpbmdCb29raW5ncz8ucmVkdWNlKChzdW0sIGJvb2tpbmcpID0+IHtcbiAgICAgICAgICByZXR1cm4gc3VtICsgKGJvb2tpbmcuZ2lmdF9jYXJkX2Ftb3VudF9hcHBsaWVkX2NlbnRzIHx8IDApO1xuICAgICAgICB9LCAwKSB8fCAwO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSByZW1haW5pbmcgYXZhaWxhYmxlIGJhbGFuY2VcbiAgICAgICAgY29uc3QgcmVtYWluaW5nQmFsYW5jZUNlbnRzID0gTWF0aC5tYXgoMCwgZ2lmdENhcmQuY3VycmVudF9iYWxhbmNlX2NlbnRzIC0gYWxyZWFkeUFwcGxpZWRDZW50cyk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbnkgcmVtYWluaW5nIGJhbGFuY2VcbiAgICAgICAgaWYgKHJlbWFpbmluZ0JhbGFuY2VDZW50cyA8PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICAgICAgeyBlcnJvcjogJ0dpZnQgY2FyZCBoYXMgbm8gcmVtYWluaW5nIGJhbGFuY2UnIH0sXG4gICAgICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgb25seSB0aGUgcmVtYWluaW5nIGJhbGFuY2UgKG5vdCB0aGUgZnVsbCBjdXJyZW50X2JhbGFuY2VfY2VudHMpXG4gICAgICAgIGdpZnRfY2FyZF9hbW91bnRfYXBwbGllZF9jZW50cyA9IE1hdGgubWluKHJlbWFpbmluZ0JhbGFuY2VDZW50cywgc2VydmljZS5wcmljZV9jZW50cyk7XG4gICAgICAgIGZpbmFsX3ByaWNlX2NlbnRzID0gc2VydmljZS5wcmljZV9jZW50cyAtIGdpZnRfY2FyZF9hbW91bnRfYXBwbGllZF9jZW50cztcbiAgICAgIH0gZWxzZSBpZiAoZ2lmdENhcmQuZGlzY291bnRfdHlwZSA9PT0gJ3BlcmNlbnQnKSB7XG4gICAgICAgIGNvbnN0IHBlcmNlbnRPZmYgPSBnaWZ0Q2FyZC5wZXJjZW50X29mZiB8fCAwO1xuICAgICAgICBpZiAocGVyY2VudE9mZiA8PSAwIHx8IHBlcmNlbnRPZmYgPiAxMDApIHtcbiAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgICB7IGVycm9yOiAnSW52YWxpZCBnaWZ0IGNhcmQgZGlzY291bnQgcGVyY2VudGFnZScgfSxcbiAgICAgICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZ2lmdF9jYXJkX2Ftb3VudF9hcHBsaWVkX2NlbnRzID0gTWF0aC5yb3VuZCgoc2VydmljZS5wcmljZV9jZW50cyAqIHBlcmNlbnRPZmYpIC8gMTAwKTtcbiAgICAgICAgZmluYWxfcHJpY2VfY2VudHMgPSBzZXJ2aWNlLnByaWNlX2NlbnRzIC0gZ2lmdF9jYXJkX2Ftb3VudF9hcHBsaWVkX2NlbnRzO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxfcHJpY2VfY2VudHMgPCAwKSB7XG4gICAgICAgIGZpbmFsX3ByaWNlX2NlbnRzID0gMDtcbiAgICAgICAgZ2lmdF9jYXJkX2Ftb3VudF9hcHBsaWVkX2NlbnRzID0gc2VydmljZS5wcmljZV9jZW50cztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXQgY3VycmVudCBhY3RpdmUgcG9saWN5IGFuZCBjcmVhdGUgc25hcHNob3RcbiAgICBjb25zdCB7IGRhdGE6IHBvbGljeSwgZXJyb3I6IHBvbGljeUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2J1c2luZXNzX3BvbGljaWVzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdidXNpbmVzc19pZCcsIGJ1c2luZXNzLmlkKVxuICAgICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKVxuICAgICAgLm9yZGVyKCd2ZXJzaW9uJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgICAubGltaXQoMSlcbiAgICAgIC5tYXliZVNpbmdsZSgpO1xuXG4gICAgaWYgKHBvbGljeUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBidXNpbmVzcyBwb2xpY2llczonLCBwb2xpY3lFcnJvcik7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdGYWlsZWQgdG8gZmV0Y2ggYnVzaW5lc3MgcG9saWNpZXMnLCBkZXRhaWxzOiBwb2xpY3lFcnJvci5tZXNzYWdlIH0sXG4gICAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXBvbGljeSkge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnQnVzaW5lc3MgcG9saWNpZXMgbm90IGZvdW5kJyB9LFxuICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHBvbGljeSBzbmFwc2hvdCB3aXRoIGFsbCByZXF1aXJlZCBmaWVsZHNcbiAgICBjb25zdCBwb2xpY3lTbmFwc2hvdCA9IHtcbiAgICAgIGNhbmNlbGxhdGlvbl9wb2xpY3lfdGV4dDogcG9saWN5LmNhbmNlbGxhdGlvbl9wb2xpY3lfdGV4dCxcbiAgICAgIG5vX3Nob3dfcG9saWN5X3RleHQ6IHBvbGljeS5ub19zaG93X3BvbGljeV90ZXh0LFxuICAgICAgcmVmdW5kX3BvbGljeV90ZXh0OiBwb2xpY3kucmVmdW5kX3BvbGljeV90ZXh0LFxuICAgICAgY2FzaF9wb2xpY3lfdGV4dDogcG9saWN5LmNhc2hfcG9saWN5X3RleHQsXG4gICAgICBub19zaG93X2ZlZV90eXBlOiBwb2xpY3kubm9fc2hvd19mZWVfdHlwZSxcbiAgICAgIG5vX3Nob3dfZmVlX2Ftb3VudF9jZW50czogcG9saWN5Lm5vX3Nob3dfZmVlX2Ftb3VudF9jZW50cyxcbiAgICAgIG5vX3Nob3dfZmVlX3BlcmNlbnQ6IHBvbGljeS5ub19zaG93X2ZlZV9wZXJjZW50LFxuICAgICAgY2FuY2VsX2ZlZV90eXBlOiBwb2xpY3kuY2FuY2VsX2ZlZV90eXBlLFxuICAgICAgY2FuY2VsX2ZlZV9hbW91bnRfY2VudHM6IHBvbGljeS5jYW5jZWxfZmVlX2Ftb3VudF9jZW50cyxcbiAgICAgIGNhbmNlbF9mZWVfcGVyY2VudDogcG9saWN5LmNhbmNlbF9mZWVfcGVyY2VudCxcbiAgICAgIHZlcnNpb246IHBvbGljeS52ZXJzaW9uLFxuICAgICAgc25hcHNob3RfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB9O1xuXG4gICAgLy8gQ2FsY3VsYXRlIHBvbGljeSBoYXNoIGZvciBjb21wbGlhbmNlIChTSEEtMjU2IG9mIHBvbGljeSBzbmFwc2hvdClcbiAgICBjb25zdCBwb2xpY3lIYXNoID0gY3JlYXRlSGFzaCgnc2hhMjU2JylcbiAgICAgIC51cGRhdGUoSlNPTi5zdHJpbmdpZnkocG9saWN5U25hcHNob3QpKVxuICAgICAgLmRpZ2VzdCgnaGV4Jyk7XG5cbiAgICAvLyBDcmVhdGUgb3IgZmluZCBjdXN0b21lclxuICAgIGxldCBjdXN0b21lcklkOiBzdHJpbmc7XG4gICAgbGV0IHN0cmlwZUN1c3RvbWVySWQ6IHN0cmluZztcbiAgICBcbiAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nQ3VzdG9tZXIgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY3VzdG9tZXJzJylcbiAgICAgIC5zZWxlY3QoJ2lkLCBzdHJpcGVfY3VzdG9tZXJfaWQnKVxuICAgICAgLmVxKCdidXNpbmVzc19pZCcsIGJ1c2luZXNzLmlkKVxuICAgICAgLmVxKCdlbWFpbCcsIGN1c3RvbWVyLmVtYWlsLnRvTG93ZXJDYXNlKCkudHJpbSgpKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKGV4aXN0aW5nQ3VzdG9tZXIpIHtcbiAgICAgIGN1c3RvbWVySWQgPSBleGlzdGluZ0N1c3RvbWVyLmlkO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgY3VzdG9tZXIgaW5mbyBpZiBuZWVkZWRcbiAgICAgIGNvbnN0IHVwZGF0ZURhdGE6IGFueSA9IHtcbiAgICAgICAgbmFtZTogY3VzdG9tZXIubmFtZSxcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcbiAgICAgIGlmIChjdXN0b21lci5waG9uZSkge1xuICAgICAgICAvLyBGb3JtYXQgcGhvbmUgbnVtYmVyIChFLjE2NCBmb3JtYXQ6ICsxIGZvbGxvd2VkIGJ5IDEwIGRpZ2l0cylcbiAgICAgICAgY29uc29sZS5sb2coJ1tib29raW5nLWFwaV0gVXBkYXRpbmcgZXhpc3RpbmcgY3VzdG9tZXIgcGhvbmU6JywgY3VzdG9tZXIucGhvbmUsICdsZW5ndGg6JywgY3VzdG9tZXIucGhvbmUubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgZGlnaXRzID0gY3VzdG9tZXIucGhvbmUucmVwbGFjZSgvXFxEL2csICcnKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tib29raW5nLWFwaV0gRGlnaXRzIGV4dHJhY3RlZCBmb3IgdXBkYXRlOicsIGRpZ2l0cywgJ2xlbmd0aDonLCBkaWdpdHMubGVuZ3RoKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChkaWdpdHMubGVuZ3RoID09PSAxMSAmJiBkaWdpdHMuc3RhcnRzV2l0aCgnMScpKSB7XG4gICAgICAgICAgdXBkYXRlRGF0YS5waG9uZSA9IGArJHtkaWdpdHN9YDtcbiAgICAgICAgfSBlbHNlIGlmIChkaWdpdHMubGVuZ3RoID09PSAxMCkge1xuICAgICAgICAgIHVwZGF0ZURhdGEucGhvbmUgPSBgKzEke2RpZ2l0c31gO1xuICAgICAgICB9IGVsc2UgaWYgKGN1c3RvbWVyLnBob25lLnN0YXJ0c1dpdGgoJysnKSkge1xuICAgICAgICAgIGNvbnN0IHBsdXNEaWdpdHMgPSBjdXN0b21lci5waG9uZS5yZXBsYWNlKC9bXlxcZF0vZywgJycpO1xuICAgICAgICAgIGlmIChwbHVzRGlnaXRzLmxlbmd0aCA9PT0gMTEgJiYgcGx1c0RpZ2l0cy5zdGFydHNXaXRoKCcxJykpIHtcbiAgICAgICAgICAgIHVwZGF0ZURhdGEucGhvbmUgPSBjdXN0b21lci5waG9uZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBsdXNEaWdpdHMubGVuZ3RoID09PSAxMCkge1xuICAgICAgICAgICAgdXBkYXRlRGF0YS5waG9uZSA9IGArMSR7cGx1c0RpZ2l0c31gO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVEYXRhLnBob25lID0gY3VzdG9tZXIucGhvbmU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRpZ2l0cy5sZW5ndGggPj0gMTApIHtcbiAgICAgICAgICBjb25zdCBsYXN0MTAgPSBkaWdpdHMuc2xpY2UoLTEwKTtcbiAgICAgICAgICB1cGRhdGVEYXRhLnBob25lID0gYCsxJHtsYXN0MTB9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cGRhdGVEYXRhLnBob25lID0gY3VzdG9tZXIucGhvbmU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdbYm9va2luZy1hcGldIEZvcm1hdHRlZCBwaG9uZSBmb3IgdXBkYXRlOicsIHVwZGF0ZURhdGEucGhvbmUsICdsZW5ndGg6JywgdXBkYXRlRGF0YS5waG9uZT8ubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2N1c3RvbWVycycpXG4gICAgICAgIC51cGRhdGUodXBkYXRlRGF0YSlcbiAgICAgICAgLmVxKCdpZCcsIGN1c3RvbWVySWQpO1xuXG4gICAgICAvLyBHZXQgb3IgY3JlYXRlIFN0cmlwZSBDdXN0b21lciBJRFxuICAgICAgaWYgKGV4aXN0aW5nQ3VzdG9tZXIuc3RyaXBlX2N1c3RvbWVyX2lkKSB7XG4gICAgICAgIHN0cmlwZUN1c3RvbWVySWQgPSBleGlzdGluZ0N1c3RvbWVyLnN0cmlwZV9jdXN0b21lcl9pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmlwZUN1c3RvbWVySWQgPSBhd2FpdCBjcmVhdGVPckdldEN1c3RvbWVyKGN1c3RvbWVyLmVtYWlsLnRvTG93ZXJDYXNlKCkudHJpbSgpLCBjdXN0b21lci5uYW1lLCB7XG4gICAgICAgICAgYnVzaW5lc3NfaWQ6IGJ1c2luZXNzLmlkLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnY3VzdG9tZXJzJylcbiAgICAgICAgICAudXBkYXRlKHsgc3RyaXBlX2N1c3RvbWVyX2lkOiBzdHJpcGVDdXN0b21lcklkIH0pXG4gICAgICAgICAgLmVxKCdpZCcsIGN1c3RvbWVySWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgU3RyaXBlIEN1c3RvbWVyIGZpcnN0XG4gICAgICBzdHJpcGVDdXN0b21lcklkID0gYXdhaXQgY3JlYXRlT3JHZXRDdXN0b21lcihjdXN0b21lci5lbWFpbC50b0xvd2VyQ2FzZSgpLnRyaW0oKSwgY3VzdG9tZXIubmFtZSwge1xuICAgICAgICBidXNpbmVzc19pZDogYnVzaW5lc3MuaWQsXG4gICAgICB9KTtcblxuICAgICAgLy8gRm9ybWF0IHBob25lIG51bWJlciAoRS4xNjQgZm9ybWF0OiArMSBmb2xsb3dlZCBieSAxMCBkaWdpdHMpXG4gICAgICBsZXQgZm9ybWF0dGVkUGhvbmU6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgaWYgKGN1c3RvbWVyLnBob25lKSB7XG4gICAgICAgIC8vIExvZyBvcmlnaW5hbCBwaG9uZSBmb3IgZGVidWdnaW5nXG4gICAgICAgIGNvbnNvbGUubG9nKCdbYm9va2luZy1hcGldIE9yaWdpbmFsIHBob25lIGZyb20gcmVxdWVzdDonLCBjdXN0b21lci5waG9uZSwgJ2xlbmd0aDonLCBjdXN0b21lci5waG9uZS5sZW5ndGgpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBub24tZGlnaXRzXG4gICAgICAgIGNvbnN0IGRpZ2l0cyA9IGN1c3RvbWVyLnBob25lLnJlcGxhY2UoL1xcRC9nLCAnJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbYm9va2luZy1hcGldIERpZ2l0cyBleHRyYWN0ZWQ6JywgZGlnaXRzLCAnbGVuZ3RoOicsIGRpZ2l0cy5sZW5ndGgpO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgaXQgc3RhcnRzIHdpdGggMSBhbmQgaGFzIDExIGRpZ2l0cywgYWRkICtcbiAgICAgICAgaWYgKGRpZ2l0cy5sZW5ndGggPT09IDExICYmIGRpZ2l0cy5zdGFydHNXaXRoKCcxJykpIHtcbiAgICAgICAgICBmb3JtYXR0ZWRQaG9uZSA9IGArJHtkaWdpdHN9YDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBpdCBoYXMgMTAgZGlnaXRzLCBhZGQgKzFcbiAgICAgICAgZWxzZSBpZiAoZGlnaXRzLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgICAgICBmb3JtYXR0ZWRQaG9uZSA9IGArMSR7ZGlnaXRzfWA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgaXQgYWxyZWFkeSBzdGFydHMgd2l0aCArLCB2YWxpZGF0ZSBhbmQgdXNlIGFzLWlzXG4gICAgICAgIGVsc2UgaWYgKGN1c3RvbWVyLnBob25lLnN0YXJ0c1dpdGgoJysnKSkge1xuICAgICAgICAgIGNvbnN0IHBsdXNEaWdpdHMgPSBjdXN0b21lci5waG9uZS5yZXBsYWNlKC9bXlxcZF0vZywgJycpO1xuICAgICAgICAgIGlmIChwbHVzRGlnaXRzLmxlbmd0aCA9PT0gMTEgJiYgcGx1c0RpZ2l0cy5zdGFydHNXaXRoKCcxJykpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFBob25lID0gY3VzdG9tZXIucGhvbmU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwbHVzRGlnaXRzLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZFBob25lID0gYCsxJHtwbHVzRGlnaXRzfWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEludmFsaWQgZm9ybWF0LCBidXQgc2F2ZSBhcy1pcyBmb3Igbm93XG4gICAgICAgICAgICBmb3JtYXR0ZWRQaG9uZSA9IGN1c3RvbWVyLnBob25lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHRyeSB0byBmb3JtYXRcbiAgICAgICAgZWxzZSBpZiAoZGlnaXRzLmxlbmd0aCA+PSAxMCkge1xuICAgICAgICAgIC8vIFRha2UgbGFzdCAxMCBkaWdpdHMgaWYgbW9yZSB0aGFuIDEwXG4gICAgICAgICAgY29uc3QgbGFzdDEwID0gZGlnaXRzLnNsaWNlKC0xMCk7XG4gICAgICAgICAgZm9ybWF0dGVkUGhvbmUgPSBgKzEke2xhc3QxMH1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRvbyBzaG9ydCwgc2F2ZSBhcy1pcyAod2lsbCBmYWlsIHZhbGlkYXRpb24gbGF0ZXIpXG4gICAgICAgICAgZm9ybWF0dGVkUGhvbmUgPSBjdXN0b21lci5waG9uZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ1tib29raW5nLWFwaV0gRm9ybWF0dGVkIHBob25lOicsIGZvcm1hdHRlZFBob25lLCAnbGVuZ3RoOicsIGZvcm1hdHRlZFBob25lPy5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgY3VzdG9tZXIgcmVjb3JkXG4gICAgICBjb25zdCB7IGRhdGE6IG5ld0N1c3RvbWVyLCBlcnJvcjogY3VzdG9tZXJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2N1c3RvbWVycycpXG4gICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgIHVzZXJfaWQ6IGJ1c2luZXNzLnVzZXJfaWQsXG4gICAgICAgICAgYnVzaW5lc3NfaWQ6IGJ1c2luZXNzLmlkLFxuICAgICAgICAgIG5hbWU6IGN1c3RvbWVyLm5hbWUsXG4gICAgICAgICAgZW1haWw6IGN1c3RvbWVyLmVtYWlsLnRvTG93ZXJDYXNlKCkudHJpbSgpLFxuICAgICAgICAgIHBob25lOiBmb3JtYXR0ZWRQaG9uZSxcbiAgICAgICAgICBzdHJpcGVfY3VzdG9tZXJfaWQ6IHN0cmlwZUN1c3RvbWVySWQsXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgIGlmIChjdXN0b21lckVycm9yIHx8ICFuZXdDdXN0b21lcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBjdXN0b21lcjonLCBjdXN0b21lckVycm9yKTtcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICAgIHsgZXJyb3I6ICdGYWlsZWQgdG8gY3JlYXRlIGN1c3RvbWVyJywgZGV0YWlsczogY3VzdG9tZXJFcnJvcj8ubWVzc2FnZSB9LFxuICAgICAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjdXN0b21lcklkID0gbmV3Q3VzdG9tZXIuaWQ7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGJvb2tpbmdcbiAgICBjb25zdCB7IGRhdGE6IGJvb2tpbmcsIGVycm9yOiBib29raW5nRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYm9va2luZ3MnKVxuICAgICAgLmluc2VydCh7XG4gICAgICAgIHVzZXJfaWQ6IGJ1c2luZXNzLnVzZXJfaWQsXG4gICAgICAgIGJ1c2luZXNzX2lkOiBidXNpbmVzcy5pZCxcbiAgICAgICAgY3VzdG9tZXJfaWQ6IGN1c3RvbWVySWQsXG4gICAgICAgIHNlcnZpY2VfaWQsXG4gICAgICAgIHN0YWZmX2lkLFxuICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgc3RhcnRfYXQ6IHN0YXJ0X2F0LFxuICAgICAgICBlbmRfYXQ6IGVuZEF0RGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgICBkdXJhdGlvbl9taW46IHNlcnZpY2UuZHVyYXRpb25fbWluLFxuICAgICAgICBwcmljZV9jZW50czogc2VydmljZS5wcmljZV9jZW50cyxcbiAgICAgICAgZmluYWxfcHJpY2VfY2VudHMsXG4gICAgICAgIGdpZnRfY2FyZF9pZCxcbiAgICAgICAgZ2lmdF9jYXJkX2Ftb3VudF9hcHBsaWVkX2NlbnRzLFxuICAgICAgICBzb3VyY2U6ICdwdWJsaWMnLFxuICAgICAgICBwb2xpY3lfc25hcHNob3Q6IHBvbGljeVNuYXBzaG90LFxuICAgICAgICAvLyBwb2xpY3lfaGFzaDogcG9saWN5SGFzaCwgLy8gQ29sdW1uIGRvZXNuJ3QgZXhpc3QgaW4gc2NoZW1hIC0gcmVtb3ZlZFxuICAgICAgICBjb25zZW50X2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGNvbnNlbnRfaXA6IGNvbnNlbnRfaXAgfHwgbnVsbCxcbiAgICAgICAgY29uc2VudF91c2VyX2FnZW50OiBjb25zZW50X3VzZXJfYWdlbnQgfHwgbnVsbCxcbiAgICAgICAgcGF5bWVudF9zdGF0dXM6ICdub25lJywgLy8gV2lsbCBiZSB1cGRhdGVkIGFmdGVyIFNldHVwSW50ZW50IHN1Y2NlZWRzXG4gICAgICAgIGxhc3RfbW9uZXlfYWN0aW9uOiAnbm9uZScsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfSlcbiAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmIChib29raW5nRXJyb3IgfHwgIWJvb2tpbmcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGJvb2tpbmc6JywgYm9va2luZ0Vycm9yKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0ZhaWxlZCB0byBjcmVhdGUgYm9va2luZycsIGRldGFpbHM6IGJvb2tpbmdFcnJvcj8ubWVzc2FnZSB9LFxuICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIFNldHVwSW50ZW50IHRvIHNhdmUgY2FyZCAobXVzdCB1c2UgU3RyaXBlIEN1c3RvbWVyIElELCBub3QgZW1haWwpXG4gICAgaWYgKCFzdHJpcGVDdXN0b21lcklkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdObyBTdHJpcGUgY3VzdG9tZXIgSUQgYXZhaWxhYmxlIGZvciBTZXR1cEludGVudCcpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnRmFpbGVkIHRvIHNldCB1cCBwYXltZW50IG1ldGhvZCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHNldHVwSW50ZW50ID0gYXdhaXQgY3JlYXRlU2V0dXBJbnRlbnQoXG4gICAgICBzdHJpcGVDdXN0b21lcklkLFxuICAgICAge1xuICAgICAgICBib29raW5nX2lkOiBib29raW5nLmlkLFxuICAgICAgICBidXNpbmVzc19pZDogYnVzaW5lc3MuaWQsXG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIENyZWF0ZSBib29raW5nIHBheW1lbnQgcmVjb3JkIChzdGF0dXMgd2lsbCBiZSB1cGRhdGVkIHRvICdjYXJkX3NhdmVkJyBieSB3ZWJob29rIHdoZW4gU2V0dXBJbnRlbnQgc3VjY2VlZHMpXG4gICAgY29uc3QgeyBlcnJvcjogcGF5bWVudEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2Jvb2tpbmdfcGF5bWVudHMnKVxuICAgICAgLmluc2VydCh7XG4gICAgICAgIHVzZXJfaWQ6IGJ1c2luZXNzLnVzZXJfaWQsXG4gICAgICAgIGJ1c2luZXNzX2lkOiBidXNpbmVzcy5pZCxcbiAgICAgICAgYm9va2luZ19pZDogYm9va2luZy5pZCxcbiAgICAgICAgc3RyaXBlX3NldHVwX2ludGVudF9pZDogc2V0dXBJbnRlbnQuc2V0dXBJbnRlbnRJZCxcbiAgICAgICAgYW1vdW50X2NlbnRzOiBmaW5hbF9wcmljZV9jZW50cyxcbiAgICAgICAgbW9uZXlfYWN0aW9uOiAnbm9uZScsXG4gICAgICAgIHN0YXR1czogJ25vbmUnLCAvLyBXaWxsIGJlIHVwZGF0ZWQgdG8gJ2NhcmRfc2F2ZWQnIGJ5IHdlYmhvb2sgd2hlbiBTZXR1cEludGVudCBzdWNjZWVkc1xuICAgICAgICBjdXJyZW5jeTogJ3VzZCcsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfSk7XG5cbiAgICBpZiAocGF5bWVudEVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBib29raW5nIHBheW1lbnQ6JywgcGF5bWVudEVycm9yKTtcbiAgICAgIC8vIENvbnRpbnVlIGFueXdheSAtIHBheW1lbnQgY2FuIGJlIHVwZGF0ZWQgbGF0ZXJcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBib29raW5nIGNvZGUgKGUuZy4sIFRJVEhJLTEyMzQpXG4gICAgY29uc3QgYm9va2luZ0NvZGUgPSBgVElUSEktJHtib29raW5nLmlkLnNsaWNlKDAsIDgpLnRvVXBwZXJDYXNlKCl9YDtcblxuICAgIC8vIEVtaXQgYm9va2luZ19jcmVhdGVkIG5vdGlmaWNhdGlvbiAoYXN5bmMsIGRvbid0IHdhaXQpXG4gICAgY29uc29sZS5sb2coYFtwdWJsaWMtYm9va2luZ10gRW1pdHRpbmcgYm9va2luZ19jcmVhdGVkIG5vdGlmaWNhdGlvbiBmb3IgYnVzaW5lc3MgJHtidXNpbmVzcy5pZH0sIGJvb2tpbmcgJHtib29raW5nLmlkfSwgbm90aWZpY2F0aW9uc19lbmFibGVkOiAke2J1c2luZXNzLm5vdGlmaWNhdGlvbnNfZW5hYmxlZH1gKTtcbiAgICBlbWl0Tm90aWZpY2F0aW9uKGJ1c2luZXNzLmlkLCAnYm9va2luZ19jcmVhdGVkJywgYm9va2luZy5pZCwgc3VwYWJhc2UpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1twdWJsaWMtYm9va2luZ10gRXJyb3IgZW1pdHRpbmcgYm9va2luZ19jcmVhdGVkIG5vdGlmaWNhdGlvbjonLCBlcnIpO1xuICAgICAgLy8gRG9uJ3QgZmFpbCB0aGUgcmVxdWVzdCBpZiBub3RpZmljYXRpb24gZmFpbHNcbiAgICB9KTtcblxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICBib29raW5nX2lkOiBib29raW5nLmlkLFxuICAgICAgYm9va2luZ19jb2RlOiBib29raW5nQ29kZSxcbiAgICAgIGNsaWVudF9zZWNyZXQ6IHNldHVwSW50ZW50LmNsaWVudFNlY3JldCxcbiAgICAgIHNldHVwX2ludGVudF9pZDogc2V0dXBJbnRlbnQuc2V0dXBJbnRlbnRJZCxcbiAgICAgIGZpbmFsX3ByaWNlX2NlbnRzLFxuICAgICAgbWVzc2FnZTogJ0Jvb2tpbmcgY3JlYXRlZCBzdWNjZXNzZnVsbHkuIFBsZWFzZSBjb21wbGV0ZSBwYXltZW50IHNldHVwLicsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gcHVibGljIGJvb2tpbmc6JywgZXJyb3IpO1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHsgZXJyb3I6ICdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InLCBkZXRhaWxzOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyB9LFxuICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgKTtcbiAgfVxufVxuXG5cbiJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJjcmVhdGVBZG1pbkNsaWVudCIsImNyZWF0ZU9yR2V0Q3VzdG9tZXIiLCJjcmVhdGVTZXR1cEludGVudCIsImVtaXROb3RpZmljYXRpb24iLCJjcmVhdGVIYXNoIiwiUE9TVCIsInJlcXVlc3QiLCJwYXJhbXMiLCJzbHVnIiwiYm9keSIsImpzb24iLCJzZXJ2aWNlX2lkIiwic3RhZmZfaWQiLCJzdGFydF9hdCIsImN1c3RvbWVyIiwiZ2lmdF9jYXJkX2NvZGUiLCJjb25zZW50X2lwIiwiaGVhZGVycyIsImdldCIsInNwbGl0IiwidHJpbSIsImNvbnNlbnRfdXNlcl9hZ2VudCIsImVycm9yIiwic3RhdHVzIiwibmFtZSIsImVtYWlsIiwic3VwYWJhc2UiLCJkYXRhIiwiYnVzaW5lc3MiLCJidXNpbmVzc0Vycm9yIiwiZnJvbSIsInNlbGVjdCIsImVxIiwidG9Mb3dlckNhc2UiLCJpbiIsImlzIiwic2luZ2xlIiwic2VydmljZSIsInNlcnZpY2VFcnJvciIsImlkIiwic3RhcnRBdERhdGUiLCJEYXRlIiwiZW5kQXREYXRlIiwiZ2V0VGltZSIsImR1cmF0aW9uX21pbiIsImV4aXN0aW5nQm9va2luZ3MiLCJib29raW5nQ2hlY2tFcnJvciIsImNvbnNvbGUiLCJoYXNPdmVybGFwIiwic29tZSIsImJvb2tpbmciLCJib29raW5nU3RhcnQiLCJib29raW5nRW5kIiwiZW5kX2F0IiwiZmluYWxfcHJpY2VfY2VudHMiLCJwcmljZV9jZW50cyIsImdpZnRfY2FyZF9pZCIsImdpZnRfY2FyZF9hbW91bnRfYXBwbGllZF9jZW50cyIsImdpZnRDYXJkIiwiZ2lmdENhcmRFcnJvciIsInVzZXJfaWQiLCJ0b1VwcGVyQ2FzZSIsImV4cGlyZXNfYXQiLCJkaXNjb3VudF90eXBlIiwiYWxyZWFkeUFwcGxpZWRDZW50cyIsInJlZHVjZSIsInN1bSIsInJlbWFpbmluZ0JhbGFuY2VDZW50cyIsIk1hdGgiLCJtYXgiLCJjdXJyZW50X2JhbGFuY2VfY2VudHMiLCJtaW4iLCJwZXJjZW50T2ZmIiwicGVyY2VudF9vZmYiLCJyb3VuZCIsInBvbGljeSIsInBvbGljeUVycm9yIiwib3JkZXIiLCJhc2NlbmRpbmciLCJsaW1pdCIsIm1heWJlU2luZ2xlIiwiZGV0YWlscyIsIm1lc3NhZ2UiLCJwb2xpY3lTbmFwc2hvdCIsImNhbmNlbGxhdGlvbl9wb2xpY3lfdGV4dCIsIm5vX3Nob3dfcG9saWN5X3RleHQiLCJyZWZ1bmRfcG9saWN5X3RleHQiLCJjYXNoX3BvbGljeV90ZXh0Iiwibm9fc2hvd19mZWVfdHlwZSIsIm5vX3Nob3dfZmVlX2Ftb3VudF9jZW50cyIsIm5vX3Nob3dfZmVlX3BlcmNlbnQiLCJjYW5jZWxfZmVlX3R5cGUiLCJjYW5jZWxfZmVlX2Ftb3VudF9jZW50cyIsImNhbmNlbF9mZWVfcGVyY2VudCIsInZlcnNpb24iLCJzbmFwc2hvdF9hdCIsInRvSVNPU3RyaW5nIiwicG9saWN5SGFzaCIsInVwZGF0ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJkaWdlc3QiLCJjdXN0b21lcklkIiwic3RyaXBlQ3VzdG9tZXJJZCIsImV4aXN0aW5nQ3VzdG9tZXIiLCJ1cGRhdGVEYXRhIiwidXBkYXRlZF9hdCIsInBob25lIiwibG9nIiwibGVuZ3RoIiwiZGlnaXRzIiwicmVwbGFjZSIsInN0YXJ0c1dpdGgiLCJwbHVzRGlnaXRzIiwibGFzdDEwIiwic2xpY2UiLCJzdHJpcGVfY3VzdG9tZXJfaWQiLCJidXNpbmVzc19pZCIsImZvcm1hdHRlZFBob25lIiwibmV3Q3VzdG9tZXIiLCJjdXN0b21lckVycm9yIiwiaW5zZXJ0IiwiY3JlYXRlZF9hdCIsImJvb2tpbmdFcnJvciIsImN1c3RvbWVyX2lkIiwic291cmNlIiwicG9saWN5X3NuYXBzaG90IiwiY29uc2VudF9hdCIsInBheW1lbnRfc3RhdHVzIiwibGFzdF9tb25leV9hY3Rpb24iLCJzZXR1cEludGVudCIsImJvb2tpbmdfaWQiLCJwYXltZW50RXJyb3IiLCJzdHJpcGVfc2V0dXBfaW50ZW50X2lkIiwic2V0dXBJbnRlbnRJZCIsImFtb3VudF9jZW50cyIsIm1vbmV5X2FjdGlvbiIsImN1cnJlbmN5IiwiYm9va2luZ0NvZGUiLCJub3RpZmljYXRpb25zX2VuYWJsZWQiLCJjYXRjaCIsImVyciIsImJvb2tpbmdfY29kZSIsImNsaWVudF9zZWNyZXQiLCJjbGllbnRTZWNyZXQiLCJzZXR1cF9pbnRlbnRfaWQiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/public/[slug]/bookings/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/db.ts":
/*!***********************!*\
  !*** ./src/lib/db.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAdminClient: () => (/* binding */ createAdminClient),\n/* harmony export */   createClientClient: () => (/* binding */ createClientClient),\n/* harmony export */   createServerClient: () => (/* binding */ createServerClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/../../node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var next_headers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/headers */ \"(rsc)/./node_modules/next/dist/api/headers.js\");\n\n\n/**\n * Get Supabase client for server-side operations\n * \n * This function returns different clients based on context:\n * - If called from an authenticated API route, uses the user's JWT from Authorization header (respects RLS)\n * - If called from a public route or background job, uses service role (bypasses RLS)\n * \n * Usage in API routes:\n * ```ts\n * const supabase = await createServerClient();\n * const { data } = await supabase.from('businesses').select('*');\n * ```\n */ async function createServerClient() {\n    const supabaseUrl = \"https://rgwooqakdvrchfwrdnyx.supabase.co\";\n    const supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJnd29vcWFrZHZyY2hmd3Jkbnl4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMzOTQyNDEsImV4cCI6MjA3ODk3MDI0MX0.YpX0dYf_iueJVR1oK5SvREnO765JAKxriy2csdAEZlI\";\n    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n    if (!supabaseUrl) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_URL environment variable\");\n    }\n    if (!supabaseAnonKey && !supabaseServiceKey) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_ANON_KEY or SUPABASE_SERVICE_ROLE_KEY environment variable\");\n    }\n    // Try to get the user's JWT from Authorization header (for API routes)\n    let accessToken;\n    try {\n        const headersList = await (0,next_headers__WEBPACK_IMPORTED_MODULE_0__.headers)();\n        const authHeader = headersList.get(\"authorization\");\n        if (authHeader?.startsWith(\"Bearer \")) {\n            accessToken = authHeader.substring(7);\n        }\n    } catch  {\n    // Not in a headers context\n    }\n    // If we have a user token from header, use anon key with that token (respects RLS)\n    if (accessToken && supabaseAnonKey) {\n        return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${accessToken}`\n                }\n            }\n        });\n    }\n    // Try to get session from cookies (Supabase stores session in cookies)\n    try {\n        const cookieStore = await (0,next_headers__WEBPACK_IMPORTED_MODULE_0__.cookies)();\n        const allCookies = cookieStore.getAll();\n        // Try to extract access token from cookies first\n        const supabaseUrlObj = new URL(supabaseUrl);\n        const projectRef = supabaseUrlObj.hostname.split(\".\")[0];\n        // Look for Supabase auth token cookie\n        // Try sb-api-auth-token first as it's the most common\n        const authCookieNames = [\n            `sb-api-auth-token`,\n            `sb-${projectRef}-auth-token`\n        ];\n        let accessToken;\n        for (const cookieName of authCookieNames){\n            const cookie = cookieStore.get(cookieName);\n            if (cookie?.value) {\n                // Log first 100 chars to see format (without exposing full token)\n                const preview = cookie.value.substring(0, 100);\n                console.log(`[createServerClient] Checking cookie: ${cookieName}, length: ${cookie.value.length}, preview: ${preview}...`);\n                try {\n                    // Try URL decoding first\n                    let decodedValue = cookie.value;\n                    try {\n                        decodedValue = decodeURIComponent(cookie.value);\n                    } catch  {\n                    // Not URL encoded\n                    }\n                    // Try parsing as JSON\n                    try {\n                        const session = JSON.parse(decodedValue);\n                        console.log(`[createServerClient] Parsed ${cookieName} as JSON, type:`, Array.isArray(session) ? \"array\" : typeof session, \"keys:\", Object.keys(session || {}));\n                        // Check if it's an array (Supabase sometimes stores tokens as array)\n                        if (Array.isArray(session) && session.length > 0) {\n                            console.log(`[createServerClient] Array has ${session.length} elements, checking each...`);\n                            // Try each element to find a valid JWT\n                            for(let i = 0; i < session.length; i++){\n                                const element = session[i];\n                                if (typeof element === \"string\") {\n                                    // Remove any quotes or extra characters\n                                    let cleanToken = element.trim();\n                                    if (cleanToken.startsWith('\"') && cleanToken.endsWith('\"') || cleanToken.startsWith(\"'\") && cleanToken.endsWith(\"'\")) {\n                                        cleanToken = cleanToken.slice(1, -1);\n                                    }\n                                    // Check if it looks like a JWT (has 3 parts separated by dots)\n                                    const parts = cleanToken.split(\".\");\n                                    if (parts.length === 3 && cleanToken.length > 100) {\n                                        console.log(`[createServerClient] Found valid JWT structure in element ${i}, using it as access token`);\n                                        // Use this token - even if signature validation fails later, \n                                        // Supabase might still accept it for RLS if the payload is valid\n                                        accessToken = cleanToken;\n                                        break;\n                                    }\n                                }\n                                // If element is an object, check for access_token\n                                if (element && typeof element === \"object\" && element.access_token) {\n                                    console.log(`[createServerClient] Found access_token in element ${i}: ${cookieName}`);\n                                    accessToken = element.access_token;\n                                    break;\n                                }\n                            }\n                            if (accessToken) {\n                                break;\n                            }\n                            // If no single element works, try joining all string elements\n                            const allStrings = session.filter((e)=>typeof e === \"string\");\n                            if (allStrings.length > 0) {\n                                const joined = allStrings.join(\"\");\n                                const parts = joined.split(\".\");\n                                if (parts.length === 3 && joined.length > 100) {\n                                    console.log(\"[createServerClient] Found JWT by joining array elements\");\n                                    accessToken = joined;\n                                    break;\n                                }\n                            }\n                        }\n                        if (session?.access_token) {\n                            console.log(`[createServerClient] Found access_token in ${cookieName}`);\n                            accessToken = session.access_token;\n                            break;\n                        }\n                        // Check for nested session object\n                        if (session?.session?.access_token) {\n                            console.log(`[createServerClient] Found access_token in nested session: ${cookieName}`);\n                            accessToken = session.session.access_token;\n                            break;\n                        }\n                    } catch (parseError) {\n                        // Not JSON, might be direct JWT token\n                        console.log(`[createServerClient] ${cookieName} is not JSON, checking if JWT`);\n                        if (decodedValue.length > 100 && decodedValue.includes(\".\")) {\n                            console.log(`[createServerClient] Using ${cookieName} as direct JWT token`);\n                            accessToken = decodedValue;\n                            break;\n                        }\n                    }\n                } catch (error) {\n                    console.error(`[createServerClient] Error processing ${cookieName}:`, error);\n                }\n            }\n        }\n        // If we found an access token, use it directly\n        if (accessToken && supabaseAnonKey) {\n            return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey, {\n                global: {\n                    headers: {\n                        Authorization: `Bearer ${accessToken}`\n                    }\n                },\n                auth: {\n                    persistSession: false,\n                    autoRefreshToken: false\n                }\n            });\n        }\n        // Fallback: Build cookie header for Supabase to read\n        const cookieHeader = allCookies.map((c)=>`${c.name}=${c.value}`).join(\"; \");\n        if (cookieHeader && supabaseAnonKey) {\n            // Create client with cookies - Supabase will extract session from cookies\n            return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey, {\n                global: {\n                    headers: {\n                        Cookie: cookieHeader\n                    }\n                },\n                auth: {\n                    persistSession: false,\n                    autoRefreshToken: false\n                }\n            });\n        }\n    } catch (error) {\n        console.error(\"Error reading cookies in createServerClient:\", error);\n    // Not in a cookies context, continue\n    }\n    // For public routes or background jobs, use service role key\n    // WARNING: This bypasses RLS - only use when necessary\n    if (supabaseServiceKey) {\n        return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseServiceKey, {\n            auth: {\n                autoRefreshToken: false,\n                persistSession: false\n            }\n        });\n    }\n    // Fallback to anon key (for public read operations)\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey);\n}\n/**\n * Get Supabase client with service role (bypasses RLS)\n * \n * Use this ONLY for:\n * - Background jobs\n * - Webhook handlers\n * - Admin operations that need to bypass RLS\n * \n * Usage:\n * ```ts\n * const supabase = createAdminClient();\n * const { data } = await supabase.from('businesses').select('*');\n * ```\n */ function createAdminClient() {\n    const supabaseUrl = \"https://rgwooqakdvrchfwrdnyx.supabase.co\";\n    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n    if (!supabaseUrl) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_URL environment variable\");\n    }\n    if (!supabaseServiceKey) {\n        throw new Error(\"Missing SUPABASE_SERVICE_ROLE_KEY environment variable\");\n    }\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseServiceKey, {\n        auth: {\n            autoRefreshToken: false,\n            persistSession: false\n        }\n    });\n}\n/**\n * Get Supabase client for client-side operations\n * \n * This should be used in React components or client-side code.\n * It uses the anon key and relies on Supabase Auth for authentication.\n * \n * Usage in client components:\n * ```ts\n * 'use client';\n * const supabase = createClientClient();\n * ```\n */ function createClientClient() {\n    const supabaseUrl = \"https://rgwooqakdvrchfwrdnyx.supabase.co\";\n    const supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJnd29vcWFrZHZyY2hmd3Jkbnl4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMzOTQyNDEsImV4cCI6MjA3ODk3MDI0MX0.YpX0dYf_iueJVR1oK5SvREnO765JAKxriy2csdAEZlI\";\n    if (!supabaseUrl) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_URL environment variable\");\n    }\n    if (!supabaseAnonKey) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable\");\n    }\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDRjtBQUVBOzs7Ozs7Ozs7OztDQVdDLEdBQ00sU0FBU1E7SUFDZCxNQUFNbkUsY0FBY0MsMENBQW9DO0lBQ3hELE1BQU1HLGtCQUFrQkgsa05BQXlDO0lBRWpFLElBQUksQ0FBQ0QsYUFBYTtRQUNoQixNQUFNLElBQUlRLE1BQU07SUFDbEI7SUFFQSxJQUFJLENBQUNKLGlCQUFpQjtRQUNwQixNQUFNLElBQUlJLE1BQU07SUFDbEI7SUFFQSxPQUFPWixtRUFBWUEsQ0FBQ0ksYUFBYUk7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9zcmMvbGliL2RiLnRzPzllNGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50LCBTdXBhYmFzZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5pbXBvcnQgeyBjb29raWVzLCBoZWFkZXJzIH0gZnJvbSAnbmV4dC9oZWFkZXJzJztcblxuLyoqXG4gKiBHZXQgU3VwYWJhc2UgY2xpZW50IGZvciBzZXJ2ZXItc2lkZSBvcGVyYXRpb25zXG4gKiBcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBkaWZmZXJlbnQgY2xpZW50cyBiYXNlZCBvbiBjb250ZXh0OlxuICogLSBJZiBjYWxsZWQgZnJvbSBhbiBhdXRoZW50aWNhdGVkIEFQSSByb3V0ZSwgdXNlcyB0aGUgdXNlcidzIEpXVCBmcm9tIEF1dGhvcml6YXRpb24gaGVhZGVyIChyZXNwZWN0cyBSTFMpXG4gKiAtIElmIGNhbGxlZCBmcm9tIGEgcHVibGljIHJvdXRlIG9yIGJhY2tncm91bmQgam9iLCB1c2VzIHNlcnZpY2Ugcm9sZSAoYnlwYXNzZXMgUkxTKVxuICogXG4gKiBVc2FnZSBpbiBBUEkgcm91dGVzOlxuICogYGBgdHNcbiAqIGNvbnN0IHN1cGFiYXNlID0gYXdhaXQgY3JlYXRlU2VydmVyQ2xpZW50KCk7XG4gKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2J1c2luZXNzZXMnKS5zZWxlY3QoJyonKTtcbiAqIGBgYFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlU2VydmVyQ2xpZW50KCk6IFByb21pc2U8U3VwYWJhc2VDbGllbnQ+IHtcbiAgY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkw7XG4gIGNvbnN0IHN1cGFiYXNlQW5vbktleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZO1xuICBjb25zdCBzdXBhYmFzZVNlcnZpY2VLZXkgPSBwcm9jZXNzLmVudi5TVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZO1xuXG4gIGlmICghc3VwYWJhc2VVcmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIGVudmlyb25tZW50IHZhcmlhYmxlJyk7XG4gIH1cblxuICBpZiAoIXN1cGFiYXNlQW5vbktleSAmJiAhc3VwYWJhc2VTZXJ2aWNlS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ01pc3NpbmcgTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgb3IgU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSdcbiAgICApO1xuICB9XG5cbiAgLy8gVHJ5IHRvIGdldCB0aGUgdXNlcidzIEpXVCBmcm9tIEF1dGhvcml6YXRpb24gaGVhZGVyIChmb3IgQVBJIHJvdXRlcylcbiAgbGV0IGFjY2Vzc1Rva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IGhlYWRlcnNMaXN0ID0gYXdhaXQgaGVhZGVycygpO1xuICAgIGNvbnN0IGF1dGhIZWFkZXIgPSBoZWFkZXJzTGlzdC5nZXQoJ2F1dGhvcml6YXRpb24nKTtcbiAgICBpZiAoYXV0aEhlYWRlcj8uc3RhcnRzV2l0aCgnQmVhcmVyICcpKSB7XG4gICAgICBhY2Nlc3NUb2tlbiA9IGF1dGhIZWFkZXIuc3Vic3RyaW5nKDcpO1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgLy8gTm90IGluIGEgaGVhZGVycyBjb250ZXh0XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlIGEgdXNlciB0b2tlbiBmcm9tIGhlYWRlciwgdXNlIGFub24ga2V5IHdpdGggdGhhdCB0b2tlbiAocmVzcGVjdHMgUkxTKVxuICBpZiAoYWNjZXNzVG9rZW4gJiYgc3VwYWJhc2VBbm9uS2V5KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5LCB7XG4gICAgICBnbG9iYWw6IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRyeSB0byBnZXQgc2Vzc2lvbiBmcm9tIGNvb2tpZXMgKFN1cGFiYXNlIHN0b3JlcyBzZXNzaW9uIGluIGNvb2tpZXMpXG4gIHRyeSB7XG4gICAgY29uc3QgY29va2llU3RvcmUgPSBhd2FpdCBjb29raWVzKCk7XG4gICAgY29uc3QgYWxsQ29va2llcyA9IGNvb2tpZVN0b3JlLmdldEFsbCgpO1xuICAgIFxuICAgIC8vIFRyeSB0byBleHRyYWN0IGFjY2VzcyB0b2tlbiBmcm9tIGNvb2tpZXMgZmlyc3RcbiAgICBjb25zdCBzdXBhYmFzZVVybE9iaiA9IG5ldyBVUkwoc3VwYWJhc2VVcmwpO1xuICAgIGNvbnN0IHByb2plY3RSZWYgPSBzdXBhYmFzZVVybE9iai5ob3N0bmFtZS5zcGxpdCgnLicpWzBdO1xuICAgIFxuICAgIC8vIExvb2sgZm9yIFN1cGFiYXNlIGF1dGggdG9rZW4gY29va2llXG4gICAgLy8gVHJ5IHNiLWFwaS1hdXRoLXRva2VuIGZpcnN0IGFzIGl0J3MgdGhlIG1vc3QgY29tbW9uXG4gICAgY29uc3QgYXV0aENvb2tpZU5hbWVzID0gW1xuICAgICAgYHNiLWFwaS1hdXRoLXRva2VuYCxcbiAgICAgIGBzYi0ke3Byb2plY3RSZWZ9LWF1dGgtdG9rZW5gLFxuICAgIF07XG4gICAgXG4gICAgbGV0IGFjY2Vzc1Rva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCBjb29raWVOYW1lIG9mIGF1dGhDb29raWVOYW1lcykge1xuICAgICAgY29uc3QgY29va2llID0gY29va2llU3RvcmUuZ2V0KGNvb2tpZU5hbWUpO1xuICAgICAgaWYgKGNvb2tpZT8udmFsdWUpIHtcbiAgICAgICAgLy8gTG9nIGZpcnN0IDEwMCBjaGFycyB0byBzZWUgZm9ybWF0ICh3aXRob3V0IGV4cG9zaW5nIGZ1bGwgdG9rZW4pXG4gICAgICAgIGNvbnN0IHByZXZpZXcgPSBjb29raWUudmFsdWUuc3Vic3RyaW5nKDAsIDEwMCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbY3JlYXRlU2VydmVyQ2xpZW50XSBDaGVja2luZyBjb29raWU6ICR7Y29va2llTmFtZX0sIGxlbmd0aDogJHtjb29raWUudmFsdWUubGVuZ3RofSwgcHJldmlldzogJHtwcmV2aWV3fS4uLmApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRyeSBVUkwgZGVjb2RpbmcgZmlyc3RcbiAgICAgICAgICBsZXQgZGVjb2RlZFZhbHVlID0gY29va2llLnZhbHVlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWNvZGVkVmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoY29va2llLnZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIC8vIE5vdCBVUkwgZW5jb2RlZFxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgcGFyc2luZyBhcyBKU09OXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBKU09OLnBhcnNlKGRlY29kZWRWYWx1ZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NyZWF0ZVNlcnZlckNsaWVudF0gUGFyc2VkICR7Y29va2llTmFtZX0gYXMgSlNPTiwgdHlwZTpgLCBBcnJheS5pc0FycmF5KHNlc3Npb24pID8gJ2FycmF5JyA6IHR5cGVvZiBzZXNzaW9uLCAna2V5czonLCBPYmplY3Qua2V5cyhzZXNzaW9uIHx8IHt9KSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gYXJyYXkgKFN1cGFiYXNlIHNvbWV0aW1lcyBzdG9yZXMgdG9rZW5zIGFzIGFycmF5KVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2Vzc2lvbikgJiYgc2Vzc2lvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbY3JlYXRlU2VydmVyQ2xpZW50XSBBcnJheSBoYXMgJHtzZXNzaW9uLmxlbmd0aH0gZWxlbWVudHMsIGNoZWNraW5nIGVhY2guLi5gKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFRyeSBlYWNoIGVsZW1lbnQgdG8gZmluZCBhIHZhbGlkIEpXVFxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gc2Vzc2lvbltpXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW55IHF1b3RlcyBvciBleHRyYSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICBsZXQgY2xlYW5Ub2tlbiA9IGVsZW1lbnQudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgaWYgKChjbGVhblRva2VuLnN0YXJ0c1dpdGgoJ1wiJykgJiYgY2xlYW5Ub2tlbi5lbmRzV2l0aCgnXCInKSkgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgKGNsZWFuVG9rZW4uc3RhcnRzV2l0aChcIidcIikgJiYgY2xlYW5Ub2tlbi5lbmRzV2l0aChcIidcIikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuVG9rZW4gPSBjbGVhblRva2VuLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgbG9va3MgbGlrZSBhIEpXVCAoaGFzIDMgcGFydHMgc2VwYXJhdGVkIGJ5IGRvdHMpXG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGNsZWFuVG9rZW4uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDMgJiYgY2xlYW5Ub2tlbi5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtjcmVhdGVTZXJ2ZXJDbGllbnRdIEZvdW5kIHZhbGlkIEpXVCBzdHJ1Y3R1cmUgaW4gZWxlbWVudCAke2l9LCB1c2luZyBpdCBhcyBhY2Nlc3MgdG9rZW5gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoaXMgdG9rZW4gLSBldmVuIGlmIHNpZ25hdHVyZSB2YWxpZGF0aW9uIGZhaWxzIGxhdGVyLCBcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwYWJhc2UgbWlnaHQgc3RpbGwgYWNjZXB0IGl0IGZvciBSTFMgaWYgdGhlIHBheWxvYWQgaXMgdmFsaWRcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBjbGVhblRva2VuO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gSWYgZWxlbWVudCBpcyBhbiBvYmplY3QsIGNoZWNrIGZvciBhY2Nlc3NfdG9rZW5cbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudC5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbY3JlYXRlU2VydmVyQ2xpZW50XSBGb3VuZCBhY2Nlc3NfdG9rZW4gaW4gZWxlbWVudCAke2l9OiAke2Nvb2tpZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbiA9IGVsZW1lbnQuYWNjZXNzX3Rva2VuO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gSWYgbm8gc2luZ2xlIGVsZW1lbnQgd29ya3MsIHRyeSBqb2luaW5nIGFsbCBzdHJpbmcgZWxlbWVudHNcbiAgICAgICAgICAgICAgY29uc3QgYWxsU3RyaW5ncyA9IHNlc3Npb24uZmlsdGVyKGUgPT4gdHlwZW9mIGUgPT09ICdzdHJpbmcnKTtcbiAgICAgICAgICAgICAgaWYgKGFsbFN0cmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGpvaW5lZCA9IGFsbFN0cmluZ3Muam9pbignJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBqb2luZWQuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAzICYmIGpvaW5lZC5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbY3JlYXRlU2VydmVyQ2xpZW50XSBGb3VuZCBKV1QgYnkgam9pbmluZyBhcnJheSBlbGVtZW50cycpO1xuICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBqb2luZWQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHNlc3Npb24/LmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NyZWF0ZVNlcnZlckNsaWVudF0gRm91bmQgYWNjZXNzX3Rva2VuIGluICR7Y29va2llTmFtZX1gKTtcbiAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBzZXNzaW9uLmFjY2Vzc190b2tlbjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBuZXN0ZWQgc2Vzc2lvbiBvYmplY3RcbiAgICAgICAgICAgIGlmIChzZXNzaW9uPy5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtjcmVhdGVTZXJ2ZXJDbGllbnRdIEZvdW5kIGFjY2Vzc190b2tlbiBpbiBuZXN0ZWQgc2Vzc2lvbjogJHtjb29raWVOYW1lfWApO1xuICAgICAgICAgICAgICBhY2Nlc3NUb2tlbiA9IHNlc3Npb24uc2Vzc2lvbi5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIE5vdCBKU09OLCBtaWdodCBiZSBkaXJlY3QgSldUIHRva2VuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NyZWF0ZVNlcnZlckNsaWVudF0gJHtjb29raWVOYW1lfSBpcyBub3QgSlNPTiwgY2hlY2tpbmcgaWYgSldUYCk7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZFZhbHVlLmxlbmd0aCA+IDEwMCAmJiBkZWNvZGVkVmFsdWUuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NyZWF0ZVNlcnZlckNsaWVudF0gVXNpbmcgJHtjb29raWVOYW1lfSBhcyBkaXJlY3QgSldUIHRva2VuYCk7XG4gICAgICAgICAgICAgIGFjY2Vzc1Rva2VuID0gZGVjb2RlZFZhbHVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgW2NyZWF0ZVNlcnZlckNsaWVudF0gRXJyb3IgcHJvY2Vzc2luZyAke2Nvb2tpZU5hbWV9OmAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSBmb3VuZCBhbiBhY2Nlc3MgdG9rZW4sIHVzZSBpdCBkaXJlY3RseVxuICAgIGlmIChhY2Nlc3NUb2tlbiAmJiBzdXBhYmFzZUFub25LZXkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgICBnbG9iYWw6IHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgcGVyc2lzdFNlc3Npb246IGZhbHNlLFxuICAgICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrOiBCdWlsZCBjb29raWUgaGVhZGVyIGZvciBTdXBhYmFzZSB0byByZWFkXG4gICAgY29uc3QgY29va2llSGVhZGVyID0gYWxsQ29va2llcy5tYXAoYyA9PiBgJHtjLm5hbWV9PSR7Yy52YWx1ZX1gKS5qb2luKCc7ICcpO1xuICAgIFxuICAgIGlmIChjb29raWVIZWFkZXIgJiYgc3VwYWJhc2VBbm9uS2V5KSB7XG4gICAgICAvLyBDcmVhdGUgY2xpZW50IHdpdGggY29va2llcyAtIFN1cGFiYXNlIHdpbGwgZXh0cmFjdCBzZXNzaW9uIGZyb20gY29va2llc1xuICAgICAgcmV0dXJuIGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5LCB7XG4gICAgICAgIGdsb2JhbDoge1xuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIENvb2tpZTogY29va2llSGVhZGVyLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsIC8vIFdlJ3JlIGhhbmRsaW5nIGNvb2tpZXMgbWFudWFsbHlcbiAgICAgICAgICBhdXRvUmVmcmVzaFRva2VuOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWFkaW5nIGNvb2tpZXMgaW4gY3JlYXRlU2VydmVyQ2xpZW50OicsIGVycm9yKTtcbiAgICAvLyBOb3QgaW4gYSBjb29raWVzIGNvbnRleHQsIGNvbnRpbnVlXG4gIH1cblxuICAvLyBGb3IgcHVibGljIHJvdXRlcyBvciBiYWNrZ3JvdW5kIGpvYnMsIHVzZSBzZXJ2aWNlIHJvbGUga2V5XG4gIC8vIFdBUk5JTkc6IFRoaXMgYnlwYXNzZXMgUkxTIC0gb25seSB1c2Ugd2hlbiBuZWNlc3NhcnlcbiAgaWYgKHN1cGFiYXNlU2VydmljZUtleSkge1xuICAgIHJldHVybiBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlU2VydmljZUtleSwge1xuICAgICAgYXV0aDoge1xuICAgICAgICBhdXRvUmVmcmVzaFRva2VuOiBmYWxzZSxcbiAgICAgICAgcGVyc2lzdFNlc3Npb246IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEZhbGxiYWNrIHRvIGFub24ga2V5IChmb3IgcHVibGljIHJlYWQgb3BlcmF0aW9ucylcbiAgcmV0dXJuIGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5ISk7XG59XG5cbi8qKlxuICogR2V0IFN1cGFiYXNlIGNsaWVudCB3aXRoIHNlcnZpY2Ugcm9sZSAoYnlwYXNzZXMgUkxTKVxuICogXG4gKiBVc2UgdGhpcyBPTkxZIGZvcjpcbiAqIC0gQmFja2dyb3VuZCBqb2JzXG4gKiAtIFdlYmhvb2sgaGFuZGxlcnNcbiAqIC0gQWRtaW4gb3BlcmF0aW9ucyB0aGF0IG5lZWQgdG8gYnlwYXNzIFJMU1xuICogXG4gKiBVc2FnZTpcbiAqIGBgYHRzXG4gKiBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUFkbWluQ2xpZW50KCk7XG4gKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2J1c2luZXNzZXMnKS5zZWxlY3QoJyonKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWRtaW5DbGllbnQoKTogU3VwYWJhc2VDbGllbnQge1xuICBjb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTDtcbiAgY29uc3Qgc3VwYWJhc2VTZXJ2aWNlS2V5ID0gcHJvY2Vzcy5lbnYuU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWTtcblxuICBpZiAoIXN1cGFiYXNlVXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIE5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCBlbnZpcm9ubWVudCB2YXJpYWJsZScpO1xuICB9XG5cbiAgaWYgKCFzdXBhYmFzZVNlcnZpY2VLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZScpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VTZXJ2aWNlS2V5LCB7XG4gICAgYXV0aDoge1xuICAgICAgYXV0b1JlZnJlc2hUb2tlbjogZmFsc2UsXG4gICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsXG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IFN1cGFiYXNlIGNsaWVudCBmb3IgY2xpZW50LXNpZGUgb3BlcmF0aW9uc1xuICogXG4gKiBUaGlzIHNob3VsZCBiZSB1c2VkIGluIFJlYWN0IGNvbXBvbmVudHMgb3IgY2xpZW50LXNpZGUgY29kZS5cbiAqIEl0IHVzZXMgdGhlIGFub24ga2V5IGFuZCByZWxpZXMgb24gU3VwYWJhc2UgQXV0aCBmb3IgYXV0aGVudGljYXRpb24uXG4gKiBcbiAqIFVzYWdlIGluIGNsaWVudCBjb21wb25lbnRzOlxuICogYGBgdHNcbiAqICd1c2UgY2xpZW50JztcbiAqIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50Q2xpZW50KCk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNsaWVudENsaWVudCgpOiBTdXBhYmFzZUNsaWVudCB7XG4gIGNvbnN0IHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMO1xuICBjb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWTtcblxuICBpZiAoIXN1cGFiYXNlVXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIE5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCBlbnZpcm9ubWVudCB2YXJpYWJsZScpO1xuICB9XG5cbiAgaWYgKCFzdXBhYmFzZUFub25LZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGUnKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSk7XG59XG5cbiJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJjb29raWVzIiwiaGVhZGVycyIsImNyZWF0ZVNlcnZlckNsaWVudCIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlQW5vbktleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwic3VwYWJhc2VTZXJ2aWNlS2V5IiwiU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSIsIkVycm9yIiwiYWNjZXNzVG9rZW4iLCJoZWFkZXJzTGlzdCIsImF1dGhIZWFkZXIiLCJnZXQiLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwiZ2xvYmFsIiwiQXV0aG9yaXphdGlvbiIsImNvb2tpZVN0b3JlIiwiYWxsQ29va2llcyIsImdldEFsbCIsInN1cGFiYXNlVXJsT2JqIiwiVVJMIiwicHJvamVjdFJlZiIsImhvc3RuYW1lIiwic3BsaXQiLCJhdXRoQ29va2llTmFtZXMiLCJjb29raWVOYW1lIiwiY29va2llIiwidmFsdWUiLCJwcmV2aWV3IiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsImRlY29kZWRWYWx1ZSIsImRlY29kZVVSSUNvbXBvbmVudCIsInNlc3Npb24iLCJKU09OIiwicGFyc2UiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJrZXlzIiwiaSIsImVsZW1lbnQiLCJjbGVhblRva2VuIiwidHJpbSIsImVuZHNXaXRoIiwic2xpY2UiLCJwYXJ0cyIsImFjY2Vzc190b2tlbiIsImFsbFN0cmluZ3MiLCJmaWx0ZXIiLCJlIiwiam9pbmVkIiwiam9pbiIsInBhcnNlRXJyb3IiLCJpbmNsdWRlcyIsImVycm9yIiwiYXV0aCIsInBlcnNpc3RTZXNzaW9uIiwiYXV0b1JlZnJlc2hUb2tlbiIsImNvb2tpZUhlYWRlciIsIm1hcCIsImMiLCJuYW1lIiwiQ29va2llIiwiY3JlYXRlQWRtaW5DbGllbnQiLCJjcmVhdGVDbGllbnRDbGllbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/db.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/notifications.ts":
/*!**********************************!*\
  !*** ./src/lib/notifications.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALLOWED_PLACEHOLDERS: () => (/* binding */ ALLOWED_PLACEHOLDERS),\n/* harmony export */   createNotificationFromTemplate: () => (/* binding */ createNotificationFromTemplate),\n/* harmony export */   emitNotification: () => (/* binding */ emitNotification),\n/* harmony export */   enqueueNotification: () => (/* binding */ enqueueNotification),\n/* harmony export */   loadTemplateForTrigger: () => (/* binding */ loadTemplateForTrigger),\n/* harmony export */   renderTemplate: () => (/* binding */ renderTemplate),\n/* harmony export */   validatePlaceholders: () => (/* binding */ validatePlaceholders)\n/* harmony export */ });\n/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./db */ \"(rsc)/./src/lib/db.ts\");\n/* harmony import */ var _timezone__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./timezone */ \"(rsc)/./src/lib/timezone.ts\");\n\n\n// Allowed placeholders per the spec\nconst ALLOWED_PLACEHOLDERS = [\n    \"customer.name\",\n    \"customer.email\",\n    \"customer.phone\",\n    \"service.name\",\n    \"service.duration\",\n    \"service.price\",\n    \"staff.name\",\n    \"booking.code\",\n    \"booking.date\",\n    \"booking.time\",\n    \"booking.amount\",\n    \"business.name\",\n    \"business.phone\",\n    \"business.support_email\",\n    \"booking.url\"\n];\n/**\n * Validate that template only contains allowed placeholders\n */ function validatePlaceholders(template) {\n    const placeholderRegex = /\\$\\{([^}]+)\\}/g;\n    const matches = Array.from(template.matchAll(placeholderRegex));\n    const foundPlaceholders = matches.map((m)=>m[1]);\n    const invalid = foundPlaceholders.filter((p)=>!ALLOWED_PLACEHOLDERS.includes(p));\n    return {\n        valid: invalid.length === 0,\n        invalid\n    };\n}\n/**\n * Render a notification template by substituting placeholders\n * Supports timezone-aware date/time formatting\n */ function renderTemplate(template, data, timezone) {\n    let rendered = template;\n    const tz = timezone || data.business?.timezone || \"America/New_York\";\n    // Replace placeholders with actual values\n    if (data.customer) {\n        rendered = rendered.replace(/\\$\\{customer\\.name\\}/g, data.customer.name || \"\");\n        rendered = rendered.replace(/\\$\\{customer\\.email\\}/g, data.customer.email || \"\");\n        rendered = rendered.replace(/\\$\\{customer\\.phone\\}/g, data.customer.phone || \"\");\n    }\n    if (data.service) {\n        rendered = rendered.replace(/\\$\\{service\\.name\\}/g, data.service.name || \"\");\n        rendered = rendered.replace(/\\$\\{service\\.duration\\}/g, String(data.service.duration_min || 0));\n        rendered = rendered.replace(/\\$\\{service\\.price\\}/g, formatPrice(data.service.price_cents || 0));\n    }\n    if (data.staff) {\n        rendered = rendered.replace(/\\$\\{staff\\.name\\}/g, data.staff.name || \"\");\n    }\n    if (data.booking) {\n        const startDate = new Date(data.booking.start_at);\n        rendered = rendered.replace(/\\$\\{booking\\.date\\}/g, formatDate(startDate, tz));\n        rendered = rendered.replace(/\\$\\{booking\\.time\\}/g, formatTime(startDate, tz));\n        rendered = rendered.replace(/\\$\\{booking\\.code\\}/g, `TITHI-${data.booking.id?.slice(0, 8).toUpperCase() || \"\"}`);\n        // booking.amount uses final_price_cents if available, otherwise price_cents\n        const amount = data.booking.final_price_cents ?? data.booking.price_cents ?? 0;\n        rendered = rendered.replace(/\\$\\{booking\\.amount\\}/g, formatPrice(amount));\n    }\n    if (data.business) {\n        rendered = rendered.replace(/\\$\\{business\\.name\\}/g, data.business.name || \"\");\n        rendered = rendered.replace(/\\$\\{business\\.support_email\\}/g, data.business.support_email || \"\");\n        rendered = rendered.replace(/\\$\\{business\\.phone\\}/g, data.business.phone || \"\");\n    }\n    if (data.booking_url) {\n        rendered = rendered.replace(/\\$\\{booking\\.url\\}/g, data.booking_url);\n    } else if (data.business?.subdomain) {\n        // Generate booking URL if not provided\n        const bookingCode = data.booking?.id ? `TITHI-${data.booking.id.slice(0, 8).toUpperCase()}` : \"\";\n        const url = `https://${data.business.subdomain}.tithi.com/confirm/${bookingCode}`;\n        rendered = rendered.replace(/\\$\\{booking\\.url\\}/g, url);\n    }\n    // Handle amount placeholder for fee_charged and refunded\n    if (data.amount !== undefined) {\n        rendered = rendered.replace(/\\$\\{amount\\}/g, formatPrice(data.amount));\n    }\n    return rendered;\n}\n/**\n * Enqueue a notification job\n * Uses unique constraint to prevent duplicate sends\n */ async function enqueueNotification(params) {\n    const supabase = (0,_db__WEBPACK_IMPORTED_MODULE_0__.createAdminClient)(); // Use admin client to bypass RLS for job insertion\n    // Check for existing job with same booking_id, trigger, and channel (idempotency)\n    if (params.bookingId) {\n        const { data: existing } = await supabase.from(\"notification_jobs\").select(\"id\").eq(\"booking_id\", params.bookingId).eq(\"trigger\", params.trigger).eq(\"channel\", params.channel).limit(1).single();\n        if (existing) {\n            // Job already exists, skip\n            return;\n        }\n    }\n    const now = new Date().toISOString();\n    const { error } = await supabase.from(\"notification_jobs\").insert({\n        user_id: params.userId,\n        business_id: params.businessId,\n        booking_id: params.bookingId || null,\n        template_id: params.templateId || null,\n        recipient_email: params.recipientEmail || null,\n        recipient_phone: params.recipientPhone || null,\n        subject: params.subject || null,\n        body: params.body,\n        channel: params.channel,\n        trigger: params.trigger,\n        status: \"pending\",\n        attempt_count: 0,\n        scheduled_at: now,\n        next_retry_at: null,\n        created_at: now\n    });\n    if (error) {\n        // If unique constraint violation, that's okay (idempotency)\n        if (error.code === \"23505\") {\n            return;\n        }\n        console.error(\"Error enqueueing notification:\", error);\n        throw error;\n    }\n}\n/**\n * Load notification template for a trigger\n */ async function loadTemplateForTrigger(businessId, userId, trigger, channel, supabase) {\n    const client = supabase || (0,_db__WEBPACK_IMPORTED_MODULE_0__.createAdminClient)();\n    const { data: template, error } = await client.from(\"notification_templates\").select(\"*\").eq(\"business_id\", businessId).eq(\"user_id\", userId).eq(\"trigger\", trigger).eq(\"channel\", channel).eq(\"is_enabled\", true).is(\"deleted_at\", null).order(\"created_at\", {\n        ascending: false\n    }).limit(1).maybeSingle();\n    if (error && error.code !== \"PGRST116\") {\n        console.error(\"Error loading template:\", error);\n        return null;\n    }\n    return template;\n}\n/**\n * Main function to emit a notification event\n * This loads booking data, resolves templates, and enqueues jobs\n * \n * @param amount Optional amount in cents for fee_charged and refunded triggers\n */ async function emitNotification(businessId, trigger, bookingId, supabase, amount) {\n    // Check feature flag first - if notifications feature is disabled globally, skip all notifications\n    const { getEffectiveNotificationsEnabled } = await __webpack_require__.e(/*! import() */ \"_rsc_src_lib_feature-flags_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./feature-flags */ \"(rsc)/./src/lib/feature-flags.ts\"));\n    if (!getEffectiveNotificationsEnabled()) {\n        console.log(`Skipping notification for business ${businessId} - Notifications feature disabled (v2)`);\n        return;\n    }\n    const client = supabase || (0,_db__WEBPACK_IMPORTED_MODULE_0__.createAdminClient)();\n    // Check if notifications are enabled for this business\n    const { data: business } = await client.from(\"businesses\").select(\"id, user_id, name, support_email, phone, subdomain, timezone, notifications_enabled\").eq(\"id\", businessId).single();\n    if (!business) {\n        console.error(`Business ${businessId} not found`);\n        return;\n    }\n    // If notifications are disabled (Basic Plan), skip sending notifications\n    // Basic Plan accounts only show booking confirmations, no SMS/email notifications\n    if (business.notifications_enabled === false) {\n        console.log(`Skipping notification for business ${businessId} - Basic Plan (notifications disabled)`);\n        return;\n    }\n    const userId = business.user_id;\n    // Load complete booking data with all relations\n    const { data: booking, error: bookingError } = await client.from(\"bookings\").select(`\n      *,\n      customers:customer_id (\n        id,\n        name,\n        email,\n        phone\n      ),\n      services:service_id (\n        id,\n        name,\n        duration_min,\n        price_cents\n      ),\n      staff:staff_id (\n        id,\n        name\n      )\n    `).eq(\"id\", bookingId).eq(\"business_id\", businessId).is(\"deleted_at\", null).single();\n    if (bookingError || !booking) {\n        console.error(`Booking ${bookingId} not found:`, bookingError);\n        return;\n    }\n    // For fee_charged and refunded, load the latest payment amount if not provided\n    let feeAmount = amount;\n    if ((trigger === \"fee_charged\" || trigger === \"refunded\") && feeAmount === undefined) {\n        const { data: latestPayment } = await client.from(\"booking_payments\").select(\"amount_cents\").eq(\"booking_id\", bookingId).in(\"money_action\", trigger === \"fee_charged\" ? [\n            \"no_show_fee\",\n            \"cancel_fee\"\n        ] : [\n            \"refund\"\n        ]).order(\"created_at\", {\n            ascending: false\n        }).limit(1).maybeSingle();\n        if (latestPayment) {\n            feeAmount = latestPayment.amount_cents;\n        }\n    }\n    // Build notification data\n    const notificationData = {\n        booking: {\n            id: booking.id,\n            start_at: booking.start_at,\n            end_at: booking.end_at,\n            final_price_cents: booking.final_price_cents,\n            price_cents: booking.price_cents,\n            staff_id: booking.staff_id,\n            status: booking.status\n        },\n        customer: booking.customers ? {\n            name: booking.customers.name,\n            email: booking.customers.email,\n            phone: booking.customers.phone || undefined\n        } : undefined,\n        service: booking.services ? {\n            name: booking.services.name,\n            duration_min: booking.services.duration_min,\n            price_cents: booking.services.price_cents\n        } : undefined,\n        staff: booking.staff ? {\n            name: booking.staff.name\n        } : undefined,\n        business: {\n            name: business.name,\n            support_email: business.support_email || undefined,\n            phone: business.phone || undefined,\n            subdomain: business.subdomain || undefined,\n            timezone: business.timezone || \"America/New_York\"\n        },\n        booking_url: business.subdomain ? `https://${business.subdomain}.tithi.com/confirm/TITHI-${booking.id.slice(0, 8).toUpperCase()}` : undefined,\n        amount: feeAmount\n    };\n    // Load templates for this trigger\n    // NOTE: SMS notifications disabled for v1 - only email notifications are enabled\n    const emailTemplate = await loadTemplateForTrigger(businessId, userId, trigger, \"email\", client);\n    // const smsTemplate = await loadTemplateForTrigger(businessId, userId, trigger, 'sms', client); // Disabled for v1\n    const timezone = business.timezone || \"America/New_York\";\n    // Log if template is missing (for debugging)\n    if (!emailTemplate) {\n        console.log(`[notifications] No email template found for business ${businessId}, trigger ${trigger}. Email will not be sent.`);\n        console.log(`[notifications] Make sure a template exists with: business_id=${businessId}, trigger=${trigger}, channel=email, is_enabled=true`);\n    } else {\n        console.log(`[notifications] Found email template: ${emailTemplate.id} (${emailTemplate.name}), enabled: ${emailTemplate.is_enabled}`);\n    }\n    // Send email notification if template exists and customer has email\n    if (emailTemplate && notificationData.customer?.email) {\n        const renderedBody = renderTemplate(emailTemplate.body_markdown, notificationData, timezone);\n        const renderedSubject = emailTemplate.subject ? renderTemplate(emailTemplate.subject, notificationData, timezone) : undefined;\n        // For booking_created trigger, send immediately instead of queuing\n        // This ensures customers get confirmation emails right away\n        if (trigger === \"booking_created\" && renderedSubject) {\n            console.log(`[notifications] Sending booking_created email immediately to ${notificationData.customer.email}`);\n            try {\n                const { sendEmailViaSendGrid } = await __webpack_require__.e(/*! import() */ \"_rsc_src_lib_notification-senders_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./notification-senders */ \"(rsc)/./src/lib/notification-senders.ts\"));\n                const emailResult = await sendEmailViaSendGrid(notificationData.customer.email, renderedSubject, renderedBody);\n                if (emailResult.success) {\n                    console.log(`[notifications] Email sent successfully to ${notificationData.customer.email}, messageId: ${emailResult.messageId}`);\n                    // Also enqueue for audit trail\n                    await enqueueNotification({\n                        businessId,\n                        userId,\n                        bookingId,\n                        trigger,\n                        recipientEmail: notificationData.customer.email,\n                        templateId: emailTemplate.id,\n                        subject: renderedSubject,\n                        body: renderedBody,\n                        channel: \"email\"\n                    });\n                    // Mark the queued job as sent immediately\n                    const adminSupabase = (0,_db__WEBPACK_IMPORTED_MODULE_0__.createAdminClient)();\n                    const { data: jobs } = await adminSupabase.from(\"notification_jobs\").select(\"id\").eq(\"booking_id\", bookingId).eq(\"trigger\", trigger).eq(\"channel\", \"email\").eq(\"status\", \"pending\").order(\"created_at\", {\n                        ascending: false\n                    }).limit(1);\n                    if (jobs && jobs.length > 0) {\n                        await adminSupabase.from(\"notification_jobs\").update({\n                            status: \"sent\"\n                        }).eq(\"id\", jobs[0].id);\n                    }\n                } else {\n                    console.error(`[notifications] Failed to send email: ${emailResult.error}`);\n                    // Fall back to queuing if immediate send fails\n                    await enqueueNotification({\n                        businessId,\n                        userId,\n                        bookingId,\n                        trigger,\n                        recipientEmail: notificationData.customer.email,\n                        templateId: emailTemplate.id,\n                        subject: renderedSubject,\n                        body: renderedBody,\n                        channel: \"email\"\n                    });\n                }\n            } catch (error) {\n                console.error(`[notifications] Error sending email immediately:`, error);\n                // Fall back to queuing if immediate send fails\n                await enqueueNotification({\n                    businessId,\n                    userId,\n                    bookingId,\n                    trigger,\n                    recipientEmail: notificationData.customer.email,\n                    templateId: emailTemplate.id,\n                    subject: renderedSubject,\n                    body: renderedBody,\n                    channel: \"email\"\n                });\n            }\n        } else {\n            // For other triggers, queue as normal\n            console.log(`[notifications] Enqueueing email notification for booking ${bookingId} to ${notificationData.customer.email}`);\n            await enqueueNotification({\n                businessId,\n                userId,\n                bookingId,\n                trigger,\n                recipientEmail: notificationData.customer.email,\n                templateId: emailTemplate.id,\n                subject: renderedSubject,\n                body: renderedBody,\n                channel: \"email\"\n            });\n        }\n    }\n// SMS notifications disabled for v1 - will be enabled in v2\n// Enqueue SMS notification if template exists and customer has phone\n// if (smsTemplate && notificationData.customer?.phone) {\n//   const renderedBody = renderTemplate(smsTemplate.body_markdown, notificationData, timezone);\n//\n//   await enqueueNotification({\n//     businessId,\n//     userId,\n//     bookingId,\n//     trigger,\n//     recipientPhone: notificationData.customer.phone,\n//     templateId: smsTemplate.id,\n//     body: renderedBody,\n//     channel: 'sms',\n//   });\n// }\n}\n/**\n * Create notification job from template and data (legacy function, use emitNotification)\n */ async function createNotificationFromTemplate(params) {\n    const { businessId, userId, bookingId, trigger, data } = params;\n    if (!bookingId) {\n        console.error(\"createNotificationFromTemplate requires bookingId\");\n        return;\n    }\n    // Use the main emitNotification function\n    await emitNotification(businessId, trigger, bookingId);\n}\n// Helper functions\nfunction formatDate(date, timezone) {\n    return (0,_timezone__WEBPACK_IMPORTED_MODULE_1__.formatInTimeZone)(date.toISOString(), timezone, {\n        weekday: \"long\",\n        year: \"numeric\",\n        month: \"long\",\n        day: \"numeric\"\n    });\n}\nfunction formatTime(date, timezone) {\n    return (0,_timezone__WEBPACK_IMPORTED_MODULE_1__.formatInTimeZone)(date.toISOString(), timezone, {\n        hour: \"numeric\",\n        minute: \"2-digit\",\n        hour12: true\n    });\n}\nfunction formatPrice(cents) {\n    return `$${(cents / 100).toFixed(2)}`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUV6RCxJQUFJLENBQUNFLFdBQVc7UUFDZCtCLFFBQVFyQixLQUFLLENBQUM7UUFDZDtJQUNGO0lBRUEseUNBQXlDO0lBQ3pDLE1BQU00QixpQkFBaUJ2QixZQUFZWCxTQUFTSjtBQUM5QztBQUVBLG1CQUFtQjtBQUNuQixTQUFTaEIsV0FBV2lGLElBQVUsRUFBRXBHLFFBQWdCO0lBQzlDLE9BQU9wQiwyREFBZ0JBLENBQUN3SCxLQUFLeEQsV0FBVyxJQUFJNUMsVUFBVTtRQUNwRHFHLFNBQVM7UUFDVEMsTUFBTTtRQUNOQyxPQUFPO1FBQ1BDLEtBQUs7SUFDUDtBQUNGO0FBRUEsU0FBU3BGLFdBQVdnRixJQUFVLEVBQUVwRyxRQUFnQjtJQUM5QyxPQUFPcEIsMkRBQWdCQSxDQUFDd0gsS0FBS3hELFdBQVcsSUFBSTVDLFVBQVU7UUFDcER5RyxNQUFNO1FBQ05DLFFBQVE7UUFDUkMsUUFBUTtJQUNWO0FBQ0Y7QUFFQSxTQUFTL0YsWUFBWWdHLEtBQWE7SUFDaEMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDQSxRQUFRLEdBQUUsRUFBR0MsT0FBTyxDQUFDLEdBQUcsQ0FBQztBQUN2QyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL3NyYy9saWIvbm90aWZpY2F0aW9ucy50cz84MmU2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVNlcnZlckNsaWVudCwgY3JlYXRlQWRtaW5DbGllbnQgfSBmcm9tICcuL2RiJztcbmltcG9ydCB7IGZvcm1hdEluVGltZVpvbmUgfSBmcm9tICcuL3RpbWV6b25lJztcbmltcG9ydCB0eXBlIHsgU3VwYWJhc2VDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuXG5leHBvcnQgdHlwZSBOb3RpZmljYXRpb25UcmlnZ2VyID0gXG4gIHwgJ2Jvb2tpbmdfY3JlYXRlZCdcbiAgfCAnYm9va2luZ19jb25maXJtZWQnXG4gIHwgJ3JlbWluZGVyXzI0aCdcbiAgfCAncmVtaW5kZXJfMWgnXG4gIHwgJ2Jvb2tpbmdfY2FuY2VsbGVkJ1xuICB8ICdib29raW5nX3Jlc2NoZWR1bGVkJ1xuICB8ICdib29raW5nX2NvbXBsZXRlZCdcbiAgfCAnZmVlX2NoYXJnZWQnXG4gIHwgJ3JlZnVuZGVkJ1xuICB8ICdwYXltZW50X2lzc3VlJztcblxuZXhwb3J0IGludGVyZmFjZSBOb3RpZmljYXRpb25EYXRhIHtcbiAgYm9va2luZz86IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHN0YXJ0X2F0OiBzdHJpbmc7XG4gICAgZW5kX2F0Pzogc3RyaW5nO1xuICAgIGZpbmFsX3ByaWNlX2NlbnRzPzogbnVtYmVyO1xuICAgIHByaWNlX2NlbnRzPzogbnVtYmVyO1xuICAgIHN0YWZmX2lkPzogc3RyaW5nO1xuICAgIHN0YXR1cz86IHN0cmluZztcbiAgfTtcbiAgY3VzdG9tZXI/OiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGVtYWlsOiBzdHJpbmc7XG4gICAgcGhvbmU/OiBzdHJpbmc7XG4gIH07XG4gIHNlcnZpY2U/OiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGR1cmF0aW9uX21pbjogbnVtYmVyO1xuICAgIHByaWNlX2NlbnRzOiBudW1iZXI7XG4gIH07XG4gIHN0YWZmPzoge1xuICAgIG5hbWU6IHN0cmluZztcbiAgfTtcbiAgYnVzaW5lc3M/OiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHN1cHBvcnRfZW1haWw/OiBzdHJpbmc7XG4gICAgcGhvbmU/OiBzdHJpbmc7XG4gICAgc3ViZG9tYWluPzogc3RyaW5nO1xuICAgIHRpbWV6b25lPzogc3RyaW5nO1xuICB9O1xuICBib29raW5nX3VybD86IHN0cmluZztcbiAgYW1vdW50PzogbnVtYmVyOyAvLyBGb3IgZmVlX2NoYXJnZWQgYW5kIHJlZnVuZGVkIHRyaWdnZXJzXG59XG5cbi8vIEFsbG93ZWQgcGxhY2Vob2xkZXJzIHBlciB0aGUgc3BlY1xuZXhwb3J0IGNvbnN0IEFMTE9XRURfUExBQ0VIT0xERVJTID0gW1xuICAnY3VzdG9tZXIubmFtZScsXG4gICdjdXN0b21lci5lbWFpbCcsXG4gICdjdXN0b21lci5waG9uZScsXG4gICdzZXJ2aWNlLm5hbWUnLFxuICAnc2VydmljZS5kdXJhdGlvbicsXG4gICdzZXJ2aWNlLnByaWNlJyxcbiAgJ3N0YWZmLm5hbWUnLFxuICAnYm9va2luZy5jb2RlJyxcbiAgJ2Jvb2tpbmcuZGF0ZScsXG4gICdib29raW5nLnRpbWUnLFxuICAnYm9va2luZy5hbW91bnQnLFxuICAnYnVzaW5lc3MubmFtZScsXG4gICdidXNpbmVzcy5waG9uZScsXG4gICdidXNpbmVzcy5zdXBwb3J0X2VtYWlsJyxcbiAgJ2Jvb2tpbmcudXJsJyxcbl07XG5cbi8qKlxuICogVmFsaWRhdGUgdGhhdCB0ZW1wbGF0ZSBvbmx5IGNvbnRhaW5zIGFsbG93ZWQgcGxhY2Vob2xkZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVBsYWNlaG9sZGVycyh0ZW1wbGF0ZTogc3RyaW5nKTogeyB2YWxpZDogYm9vbGVhbjsgaW52YWxpZDogc3RyaW5nW10gfSB7XG4gIGNvbnN0IHBsYWNlaG9sZGVyUmVnZXggPSAvXFwkXFx7KFtefV0rKVxcfS9nO1xuICBjb25zdCBtYXRjaGVzID0gQXJyYXkuZnJvbSh0ZW1wbGF0ZS5tYXRjaEFsbChwbGFjZWhvbGRlclJlZ2V4KSk7XG4gIGNvbnN0IGZvdW5kUGxhY2Vob2xkZXJzID0gbWF0Y2hlcy5tYXAobSA9PiBtWzFdKTtcbiAgY29uc3QgaW52YWxpZCA9IGZvdW5kUGxhY2Vob2xkZXJzLmZpbHRlcihwID0+ICFBTExPV0VEX1BMQUNFSE9MREVSUy5pbmNsdWRlcyhwKSk7XG4gIFxuICByZXR1cm4ge1xuICAgIHZhbGlkOiBpbnZhbGlkLmxlbmd0aCA9PT0gMCxcbiAgICBpbnZhbGlkLFxuICB9O1xufVxuXG4vKipcbiAqIFJlbmRlciBhIG5vdGlmaWNhdGlvbiB0ZW1wbGF0ZSBieSBzdWJzdGl0dXRpbmcgcGxhY2Vob2xkZXJzXG4gKiBTdXBwb3J0cyB0aW1lem9uZS1hd2FyZSBkYXRlL3RpbWUgZm9ybWF0dGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyVGVtcGxhdGUodGVtcGxhdGU6IHN0cmluZywgZGF0YTogTm90aWZpY2F0aW9uRGF0YSwgdGltZXpvbmU/OiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgcmVuZGVyZWQgPSB0ZW1wbGF0ZTtcbiAgY29uc3QgdHogPSB0aW1lem9uZSB8fCBkYXRhLmJ1c2luZXNzPy50aW1lem9uZSB8fCAnQW1lcmljYS9OZXdfWW9yayc7XG5cbiAgLy8gUmVwbGFjZSBwbGFjZWhvbGRlcnMgd2l0aCBhY3R1YWwgdmFsdWVzXG4gIGlmIChkYXRhLmN1c3RvbWVyKSB7XG4gICAgcmVuZGVyZWQgPSByZW5kZXJlZC5yZXBsYWNlKC9cXCRcXHtjdXN0b21lclxcLm5hbWVcXH0vZywgZGF0YS5jdXN0b21lci5uYW1lIHx8ICcnKTtcbiAgICByZW5kZXJlZCA9IHJlbmRlcmVkLnJlcGxhY2UoL1xcJFxce2N1c3RvbWVyXFwuZW1haWxcXH0vZywgZGF0YS5jdXN0b21lci5lbWFpbCB8fCAnJyk7XG4gICAgcmVuZGVyZWQgPSByZW5kZXJlZC5yZXBsYWNlKC9cXCRcXHtjdXN0b21lclxcLnBob25lXFx9L2csIGRhdGEuY3VzdG9tZXIucGhvbmUgfHwgJycpO1xuICB9XG5cbiAgaWYgKGRhdGEuc2VydmljZSkge1xuICAgIHJlbmRlcmVkID0gcmVuZGVyZWQucmVwbGFjZSgvXFwkXFx7c2VydmljZVxcLm5hbWVcXH0vZywgZGF0YS5zZXJ2aWNlLm5hbWUgfHwgJycpO1xuICAgIHJlbmRlcmVkID0gcmVuZGVyZWQucmVwbGFjZSgvXFwkXFx7c2VydmljZVxcLmR1cmF0aW9uXFx9L2csIFN0cmluZyhkYXRhLnNlcnZpY2UuZHVyYXRpb25fbWluIHx8IDApKTtcbiAgICByZW5kZXJlZCA9IHJlbmRlcmVkLnJlcGxhY2UoL1xcJFxce3NlcnZpY2VcXC5wcmljZVxcfS9nLCBmb3JtYXRQcmljZShkYXRhLnNlcnZpY2UucHJpY2VfY2VudHMgfHwgMCkpO1xuICB9XG5cbiAgaWYgKGRhdGEuc3RhZmYpIHtcbiAgICByZW5kZXJlZCA9IHJlbmRlcmVkLnJlcGxhY2UoL1xcJFxce3N0YWZmXFwubmFtZVxcfS9nLCBkYXRhLnN0YWZmLm5hbWUgfHwgJycpO1xuICB9XG5cbiAgaWYgKGRhdGEuYm9va2luZykge1xuICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKGRhdGEuYm9va2luZy5zdGFydF9hdCk7XG4gICAgcmVuZGVyZWQgPSByZW5kZXJlZC5yZXBsYWNlKC9cXCRcXHtib29raW5nXFwuZGF0ZVxcfS9nLCBmb3JtYXREYXRlKHN0YXJ0RGF0ZSwgdHopKTtcbiAgICByZW5kZXJlZCA9IHJlbmRlcmVkLnJlcGxhY2UoL1xcJFxce2Jvb2tpbmdcXC50aW1lXFx9L2csIGZvcm1hdFRpbWUoc3RhcnREYXRlLCB0eikpO1xuICAgIHJlbmRlcmVkID0gcmVuZGVyZWQucmVwbGFjZSgvXFwkXFx7Ym9va2luZ1xcLmNvZGVcXH0vZywgYFRJVEhJLSR7ZGF0YS5ib29raW5nLmlkPy5zbGljZSgwLCA4KS50b1VwcGVyQ2FzZSgpIHx8ICcnfWApO1xuICAgIFxuICAgIC8vIGJvb2tpbmcuYW1vdW50IHVzZXMgZmluYWxfcHJpY2VfY2VudHMgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgcHJpY2VfY2VudHNcbiAgICBjb25zdCBhbW91bnQgPSBkYXRhLmJvb2tpbmcuZmluYWxfcHJpY2VfY2VudHMgPz8gZGF0YS5ib29raW5nLnByaWNlX2NlbnRzID8/IDA7XG4gICAgcmVuZGVyZWQgPSByZW5kZXJlZC5yZXBsYWNlKC9cXCRcXHtib29raW5nXFwuYW1vdW50XFx9L2csIGZvcm1hdFByaWNlKGFtb3VudCkpO1xuICB9XG5cbiAgaWYgKGRhdGEuYnVzaW5lc3MpIHtcbiAgICByZW5kZXJlZCA9IHJlbmRlcmVkLnJlcGxhY2UoL1xcJFxce2J1c2luZXNzXFwubmFtZVxcfS9nLCBkYXRhLmJ1c2luZXNzLm5hbWUgfHwgJycpO1xuICAgIHJlbmRlcmVkID0gcmVuZGVyZWQucmVwbGFjZSgvXFwkXFx7YnVzaW5lc3NcXC5zdXBwb3J0X2VtYWlsXFx9L2csIGRhdGEuYnVzaW5lc3Muc3VwcG9ydF9lbWFpbCB8fCAnJyk7XG4gICAgcmVuZGVyZWQgPSByZW5kZXJlZC5yZXBsYWNlKC9cXCRcXHtidXNpbmVzc1xcLnBob25lXFx9L2csIGRhdGEuYnVzaW5lc3MucGhvbmUgfHwgJycpO1xuICB9XG5cbiAgaWYgKGRhdGEuYm9va2luZ191cmwpIHtcbiAgICByZW5kZXJlZCA9IHJlbmRlcmVkLnJlcGxhY2UoL1xcJFxce2Jvb2tpbmdcXC51cmxcXH0vZywgZGF0YS5ib29raW5nX3VybCk7XG4gIH0gZWxzZSBpZiAoZGF0YS5idXNpbmVzcz8uc3ViZG9tYWluKSB7XG4gICAgLy8gR2VuZXJhdGUgYm9va2luZyBVUkwgaWYgbm90IHByb3ZpZGVkXG4gICAgY29uc3QgYm9va2luZ0NvZGUgPSBkYXRhLmJvb2tpbmc/LmlkIFxuICAgICAgPyBgVElUSEktJHtkYXRhLmJvb2tpbmcuaWQuc2xpY2UoMCwgOCkudG9VcHBlckNhc2UoKX1gXG4gICAgICA6ICcnO1xuICAgIGNvbnN0IHVybCA9IGBodHRwczovLyR7ZGF0YS5idXNpbmVzcy5zdWJkb21haW59LnRpdGhpLmNvbS9jb25maXJtLyR7Ym9va2luZ0NvZGV9YDtcbiAgICByZW5kZXJlZCA9IHJlbmRlcmVkLnJlcGxhY2UoL1xcJFxce2Jvb2tpbmdcXC51cmxcXH0vZywgdXJsKTtcbiAgfVxuXG4gIC8vIEhhbmRsZSBhbW91bnQgcGxhY2Vob2xkZXIgZm9yIGZlZV9jaGFyZ2VkIGFuZCByZWZ1bmRlZFxuICBpZiAoZGF0YS5hbW91bnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJlbmRlcmVkID0gcmVuZGVyZWQucmVwbGFjZSgvXFwkXFx7YW1vdW50XFx9L2csIGZvcm1hdFByaWNlKGRhdGEuYW1vdW50KSk7XG4gIH1cblxuICByZXR1cm4gcmVuZGVyZWQ7XG59XG5cbi8qKlxuICogRW5xdWV1ZSBhIG5vdGlmaWNhdGlvbiBqb2JcbiAqIFVzZXMgdW5pcXVlIGNvbnN0cmFpbnQgdG8gcHJldmVudCBkdXBsaWNhdGUgc2VuZHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVucXVldWVOb3RpZmljYXRpb24ocGFyYW1zOiB7XG4gIGJ1c2luZXNzSWQ6IHN0cmluZztcbiAgdXNlcklkOiBzdHJpbmc7XG4gIGJvb2tpbmdJZD86IHN0cmluZztcbiAgdHJpZ2dlcjogc3RyaW5nO1xuICByZWNpcGllbnRFbWFpbD86IHN0cmluZztcbiAgcmVjaXBpZW50UGhvbmU/OiBzdHJpbmc7XG4gIHRlbXBsYXRlSWQ/OiBzdHJpbmc7XG4gIHN1YmplY3Q/OiBzdHJpbmc7XG4gIGJvZHk6IHN0cmluZztcbiAgY2hhbm5lbDogJ2VtYWlsJyB8ICdzbXMnO1xufSk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUFkbWluQ2xpZW50KCk7IC8vIFVzZSBhZG1pbiBjbGllbnQgdG8gYnlwYXNzIFJMUyBmb3Igam9iIGluc2VydGlvblxuXG4gIC8vIENoZWNrIGZvciBleGlzdGluZyBqb2Igd2l0aCBzYW1lIGJvb2tpbmdfaWQsIHRyaWdnZXIsIGFuZCBjaGFubmVsIChpZGVtcG90ZW5jeSlcbiAgaWYgKHBhcmFtcy5ib29raW5nSWQpIHtcbiAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ25vdGlmaWNhdGlvbl9qb2JzJylcbiAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgIC5lcSgnYm9va2luZ19pZCcsIHBhcmFtcy5ib29raW5nSWQpXG4gICAgICAuZXEoJ3RyaWdnZXInLCBwYXJhbXMudHJpZ2dlcilcbiAgICAgIC5lcSgnY2hhbm5lbCcsIHBhcmFtcy5jaGFubmVsKVxuICAgICAgLmxpbWl0KDEpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgIC8vIEpvYiBhbHJlYWR5IGV4aXN0cywgc2tpcFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgnbm90aWZpY2F0aW9uX2pvYnMnKVxuICAgIC5pbnNlcnQoe1xuICAgICAgdXNlcl9pZDogcGFyYW1zLnVzZXJJZCxcbiAgICAgIGJ1c2luZXNzX2lkOiBwYXJhbXMuYnVzaW5lc3NJZCxcbiAgICAgIGJvb2tpbmdfaWQ6IHBhcmFtcy5ib29raW5nSWQgfHwgbnVsbCxcbiAgICAgIHRlbXBsYXRlX2lkOiBwYXJhbXMudGVtcGxhdGVJZCB8fCBudWxsLFxuICAgICAgcmVjaXBpZW50X2VtYWlsOiBwYXJhbXMucmVjaXBpZW50RW1haWwgfHwgbnVsbCxcbiAgICAgIHJlY2lwaWVudF9waG9uZTogcGFyYW1zLnJlY2lwaWVudFBob25lIHx8IG51bGwsXG4gICAgICBzdWJqZWN0OiBwYXJhbXMuc3ViamVjdCB8fCBudWxsLFxuICAgICAgYm9keTogcGFyYW1zLmJvZHksXG4gICAgICBjaGFubmVsOiBwYXJhbXMuY2hhbm5lbCxcbiAgICAgIHRyaWdnZXI6IHBhcmFtcy50cmlnZ2VyIGFzIGFueSxcbiAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgYXR0ZW1wdF9jb3VudDogMCxcbiAgICAgIHNjaGVkdWxlZF9hdDogbm93LFxuICAgICAgbmV4dF9yZXRyeV9hdDogbnVsbCwgLy8gV2lsbCBiZSBzZXQgb24gZmlyc3QgZmFpbHVyZVxuICAgICAgY3JlYXRlZF9hdDogbm93LFxuICAgIH0pO1xuXG4gIGlmIChlcnJvcikge1xuICAgIC8vIElmIHVuaXF1ZSBjb25zdHJhaW50IHZpb2xhdGlvbiwgdGhhdCdzIG9rYXkgKGlkZW1wb3RlbmN5KVxuICAgIGlmIChlcnJvci5jb2RlID09PSAnMjM1MDUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGVucXVldWVpbmcgbm90aWZpY2F0aW9uOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIExvYWQgbm90aWZpY2F0aW9uIHRlbXBsYXRlIGZvciBhIHRyaWdnZXJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRUZW1wbGF0ZUZvclRyaWdnZXIoXG4gIGJ1c2luZXNzSWQ6IHN0cmluZyxcbiAgdXNlcklkOiBzdHJpbmcsXG4gIHRyaWdnZXI6IE5vdGlmaWNhdGlvblRyaWdnZXIsXG4gIGNoYW5uZWw6ICdlbWFpbCcgfCAnc21zJyxcbiAgc3VwYWJhc2U/OiBTdXBhYmFzZUNsaWVudFxuKTogUHJvbWlzZTxhbnkgfCBudWxsPiB7XG4gIGNvbnN0IGNsaWVudCA9IHN1cGFiYXNlIHx8IGNyZWF0ZUFkbWluQ2xpZW50KCk7XG5cbiAgY29uc3QgeyBkYXRhOiB0ZW1wbGF0ZSwgZXJyb3IgfSA9IGF3YWl0IGNsaWVudFxuICAgIC5mcm9tKCdub3RpZmljYXRpb25fdGVtcGxhdGVzJylcbiAgICAuc2VsZWN0KCcqJylcbiAgICAuZXEoJ2J1c2luZXNzX2lkJywgYnVzaW5lc3NJZClcbiAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgLmVxKCd0cmlnZ2VyJywgdHJpZ2dlcilcbiAgICAuZXEoJ2NoYW5uZWwnLCBjaGFubmVsKVxuICAgIC5lcSgnaXNfZW5hYmxlZCcsIHRydWUpXG4gICAgLmlzKCdkZWxldGVkX2F0JywgbnVsbClcbiAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAubGltaXQoMSlcbiAgICAubWF5YmVTaW5nbGUoKTtcblxuICBpZiAoZXJyb3IgJiYgZXJyb3IuY29kZSAhPT0gJ1BHUlNUMTE2JykgeyAvLyBQR1JTVDExNiA9IG5vIHJvd3MgcmV0dXJuZWRcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHRlbXBsYXRlOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0ZW1wbGF0ZTtcbn1cblxuLyoqXG4gKiBNYWluIGZ1bmN0aW9uIHRvIGVtaXQgYSBub3RpZmljYXRpb24gZXZlbnRcbiAqIFRoaXMgbG9hZHMgYm9va2luZyBkYXRhLCByZXNvbHZlcyB0ZW1wbGF0ZXMsIGFuZCBlbnF1ZXVlcyBqb2JzXG4gKiBcbiAqIEBwYXJhbSBhbW91bnQgT3B0aW9uYWwgYW1vdW50IGluIGNlbnRzIGZvciBmZWVfY2hhcmdlZCBhbmQgcmVmdW5kZWQgdHJpZ2dlcnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVtaXROb3RpZmljYXRpb24oXG4gIGJ1c2luZXNzSWQ6IHN0cmluZyxcbiAgdHJpZ2dlcjogTm90aWZpY2F0aW9uVHJpZ2dlcixcbiAgYm9va2luZ0lkOiBzdHJpbmcsXG4gIHN1cGFiYXNlPzogU3VwYWJhc2VDbGllbnQsXG4gIGFtb3VudD86IG51bWJlclxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIENoZWNrIGZlYXR1cmUgZmxhZyBmaXJzdCAtIGlmIG5vdGlmaWNhdGlvbnMgZmVhdHVyZSBpcyBkaXNhYmxlZCBnbG9iYWxseSwgc2tpcCBhbGwgbm90aWZpY2F0aW9uc1xuICBjb25zdCB7IGdldEVmZmVjdGl2ZU5vdGlmaWNhdGlvbnNFbmFibGVkIH0gPSBhd2FpdCBpbXBvcnQoJy4vZmVhdHVyZS1mbGFncycpO1xuICBpZiAoIWdldEVmZmVjdGl2ZU5vdGlmaWNhdGlvbnNFbmFibGVkKCkpIHtcbiAgICBjb25zb2xlLmxvZyhgU2tpcHBpbmcgbm90aWZpY2F0aW9uIGZvciBidXNpbmVzcyAke2J1c2luZXNzSWR9IC0gTm90aWZpY2F0aW9ucyBmZWF0dXJlIGRpc2FibGVkICh2MilgKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBjbGllbnQgPSBzdXBhYmFzZSB8fCBjcmVhdGVBZG1pbkNsaWVudCgpO1xuXG4gIC8vIENoZWNrIGlmIG5vdGlmaWNhdGlvbnMgYXJlIGVuYWJsZWQgZm9yIHRoaXMgYnVzaW5lc3NcbiAgY29uc3QgeyBkYXRhOiBidXNpbmVzcyB9ID0gYXdhaXQgY2xpZW50XG4gICAgLmZyb20oJ2J1c2luZXNzZXMnKVxuICAgIC5zZWxlY3QoJ2lkLCB1c2VyX2lkLCBuYW1lLCBzdXBwb3J0X2VtYWlsLCBwaG9uZSwgc3ViZG9tYWluLCB0aW1lem9uZSwgbm90aWZpY2F0aW9uc19lbmFibGVkJylcbiAgICAuZXEoJ2lkJywgYnVzaW5lc3NJZClcbiAgICAuc2luZ2xlKCk7XG5cbiAgaWYgKCFidXNpbmVzcykge1xuICAgIGNvbnNvbGUuZXJyb3IoYEJ1c2luZXNzICR7YnVzaW5lc3NJZH0gbm90IGZvdW5kYCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgbm90aWZpY2F0aW9ucyBhcmUgZGlzYWJsZWQgKEJhc2ljIFBsYW4pLCBza2lwIHNlbmRpbmcgbm90aWZpY2F0aW9uc1xuICAvLyBCYXNpYyBQbGFuIGFjY291bnRzIG9ubHkgc2hvdyBib29raW5nIGNvbmZpcm1hdGlvbnMsIG5vIFNNUy9lbWFpbCBub3RpZmljYXRpb25zXG4gIGlmIChidXNpbmVzcy5ub3RpZmljYXRpb25zX2VuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgY29uc29sZS5sb2coYFNraXBwaW5nIG5vdGlmaWNhdGlvbiBmb3IgYnVzaW5lc3MgJHtidXNpbmVzc0lkfSAtIEJhc2ljIFBsYW4gKG5vdGlmaWNhdGlvbnMgZGlzYWJsZWQpYCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdXNlcklkID0gYnVzaW5lc3MudXNlcl9pZDtcblxuICAvLyBMb2FkIGNvbXBsZXRlIGJvb2tpbmcgZGF0YSB3aXRoIGFsbCByZWxhdGlvbnNcbiAgY29uc3QgeyBkYXRhOiBib29raW5nLCBlcnJvcjogYm9va2luZ0Vycm9yIH0gPSBhd2FpdCBjbGllbnRcbiAgICAuZnJvbSgnYm9va2luZ3MnKVxuICAgIC5zZWxlY3QoYFxuICAgICAgKixcbiAgICAgIGN1c3RvbWVyczpjdXN0b21lcl9pZCAoXG4gICAgICAgIGlkLFxuICAgICAgICBuYW1lLFxuICAgICAgICBlbWFpbCxcbiAgICAgICAgcGhvbmVcbiAgICAgICksXG4gICAgICBzZXJ2aWNlczpzZXJ2aWNlX2lkIChcbiAgICAgICAgaWQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGR1cmF0aW9uX21pbixcbiAgICAgICAgcHJpY2VfY2VudHNcbiAgICAgICksXG4gICAgICBzdGFmZjpzdGFmZl9pZCAoXG4gICAgICAgIGlkLFxuICAgICAgICBuYW1lXG4gICAgICApXG4gICAgYClcbiAgICAuZXEoJ2lkJywgYm9va2luZ0lkKVxuICAgIC5lcSgnYnVzaW5lc3NfaWQnLCBidXNpbmVzc0lkKVxuICAgIC5pcygnZGVsZXRlZF9hdCcsIG51bGwpXG4gICAgLnNpbmdsZSgpO1xuXG4gIGlmIChib29raW5nRXJyb3IgfHwgIWJvb2tpbmcpIHtcbiAgICBjb25zb2xlLmVycm9yKGBCb29raW5nICR7Ym9va2luZ0lkfSBub3QgZm91bmQ6YCwgYm9va2luZ0Vycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3IgZmVlX2NoYXJnZWQgYW5kIHJlZnVuZGVkLCBsb2FkIHRoZSBsYXRlc3QgcGF5bWVudCBhbW91bnQgaWYgbm90IHByb3ZpZGVkXG4gIGxldCBmZWVBbW91bnQgPSBhbW91bnQ7XG4gIGlmICgodHJpZ2dlciA9PT0gJ2ZlZV9jaGFyZ2VkJyB8fCB0cmlnZ2VyID09PSAncmVmdW5kZWQnKSAmJiBmZWVBbW91bnQgPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHsgZGF0YTogbGF0ZXN0UGF5bWVudCB9ID0gYXdhaXQgY2xpZW50XG4gICAgICAuZnJvbSgnYm9va2luZ19wYXltZW50cycpXG4gICAgICAuc2VsZWN0KCdhbW91bnRfY2VudHMnKVxuICAgICAgLmVxKCdib29raW5nX2lkJywgYm9va2luZ0lkKVxuICAgICAgLmluKCdtb25leV9hY3Rpb24nLCB0cmlnZ2VyID09PSAnZmVlX2NoYXJnZWQnID8gWydub19zaG93X2ZlZScsICdjYW5jZWxfZmVlJ10gOiBbJ3JlZnVuZCddKVxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgICAubGltaXQoMSlcbiAgICAgIC5tYXliZVNpbmdsZSgpO1xuICAgIFxuICAgIGlmIChsYXRlc3RQYXltZW50KSB7XG4gICAgICBmZWVBbW91bnQgPSBsYXRlc3RQYXltZW50LmFtb3VudF9jZW50cztcbiAgICB9XG4gIH1cblxuICAvLyBCdWlsZCBub3RpZmljYXRpb24gZGF0YVxuICBjb25zdCBub3RpZmljYXRpb25EYXRhOiBOb3RpZmljYXRpb25EYXRhID0ge1xuICAgIGJvb2tpbmc6IHtcbiAgICAgIGlkOiBib29raW5nLmlkLFxuICAgICAgc3RhcnRfYXQ6IGJvb2tpbmcuc3RhcnRfYXQsXG4gICAgICBlbmRfYXQ6IGJvb2tpbmcuZW5kX2F0LFxuICAgICAgZmluYWxfcHJpY2VfY2VudHM6IGJvb2tpbmcuZmluYWxfcHJpY2VfY2VudHMsXG4gICAgICBwcmljZV9jZW50czogYm9va2luZy5wcmljZV9jZW50cyxcbiAgICAgIHN0YWZmX2lkOiBib29raW5nLnN0YWZmX2lkLFxuICAgICAgc3RhdHVzOiBib29raW5nLnN0YXR1cyxcbiAgICB9LFxuICAgIGN1c3RvbWVyOiBib29raW5nLmN1c3RvbWVycyA/IHtcbiAgICAgIG5hbWU6IGJvb2tpbmcuY3VzdG9tZXJzLm5hbWUsXG4gICAgICBlbWFpbDogYm9va2luZy5jdXN0b21lcnMuZW1haWwsXG4gICAgICBwaG9uZTogYm9va2luZy5jdXN0b21lcnMucGhvbmUgfHwgdW5kZWZpbmVkLFxuICAgIH0gOiB1bmRlZmluZWQsXG4gICAgc2VydmljZTogYm9va2luZy5zZXJ2aWNlcyA/IHtcbiAgICAgIG5hbWU6IGJvb2tpbmcuc2VydmljZXMubmFtZSxcbiAgICAgIGR1cmF0aW9uX21pbjogYm9va2luZy5zZXJ2aWNlcy5kdXJhdGlvbl9taW4sXG4gICAgICBwcmljZV9jZW50czogYm9va2luZy5zZXJ2aWNlcy5wcmljZV9jZW50cyxcbiAgICB9IDogdW5kZWZpbmVkLFxuICAgIHN0YWZmOiBib29raW5nLnN0YWZmID8ge1xuICAgICAgbmFtZTogYm9va2luZy5zdGFmZi5uYW1lLFxuICAgIH0gOiB1bmRlZmluZWQsXG4gICAgYnVzaW5lc3M6IHtcbiAgICAgIG5hbWU6IGJ1c2luZXNzLm5hbWUsXG4gICAgICBzdXBwb3J0X2VtYWlsOiBidXNpbmVzcy5zdXBwb3J0X2VtYWlsIHx8IHVuZGVmaW5lZCxcbiAgICAgIHBob25lOiBidXNpbmVzcy5waG9uZSB8fCB1bmRlZmluZWQsXG4gICAgICBzdWJkb21haW46IGJ1c2luZXNzLnN1YmRvbWFpbiB8fCB1bmRlZmluZWQsXG4gICAgICB0aW1lem9uZTogYnVzaW5lc3MudGltZXpvbmUgfHwgJ0FtZXJpY2EvTmV3X1lvcmsnLFxuICAgIH0sXG4gICAgYm9va2luZ191cmw6IGJ1c2luZXNzLnN1YmRvbWFpbiBcbiAgICAgID8gYGh0dHBzOi8vJHtidXNpbmVzcy5zdWJkb21haW59LnRpdGhpLmNvbS9jb25maXJtL1RJVEhJLSR7Ym9va2luZy5pZC5zbGljZSgwLCA4KS50b1VwcGVyQ2FzZSgpfWBcbiAgICAgIDogdW5kZWZpbmVkLFxuICAgIGFtb3VudDogZmVlQW1vdW50LCAvLyBGb3IgZmVlX2NoYXJnZWQgYW5kIHJlZnVuZGVkIHRyaWdnZXJzXG4gIH07XG5cbiAgLy8gTG9hZCB0ZW1wbGF0ZXMgZm9yIHRoaXMgdHJpZ2dlclxuICAvLyBOT1RFOiBTTVMgbm90aWZpY2F0aW9ucyBkaXNhYmxlZCBmb3IgdjEgLSBvbmx5IGVtYWlsIG5vdGlmaWNhdGlvbnMgYXJlIGVuYWJsZWRcbiAgY29uc3QgZW1haWxUZW1wbGF0ZSA9IGF3YWl0IGxvYWRUZW1wbGF0ZUZvclRyaWdnZXIoYnVzaW5lc3NJZCwgdXNlcklkLCB0cmlnZ2VyLCAnZW1haWwnLCBjbGllbnQpO1xuICAvLyBjb25zdCBzbXNUZW1wbGF0ZSA9IGF3YWl0IGxvYWRUZW1wbGF0ZUZvclRyaWdnZXIoYnVzaW5lc3NJZCwgdXNlcklkLCB0cmlnZ2VyLCAnc21zJywgY2xpZW50KTsgLy8gRGlzYWJsZWQgZm9yIHYxXG5cbiAgY29uc3QgdGltZXpvbmUgPSBidXNpbmVzcy50aW1lem9uZSB8fCAnQW1lcmljYS9OZXdfWW9yayc7XG5cbiAgLy8gTG9nIGlmIHRlbXBsYXRlIGlzIG1pc3NpbmcgKGZvciBkZWJ1Z2dpbmcpXG4gIGlmICghZW1haWxUZW1wbGF0ZSkge1xuICAgIGNvbnNvbGUubG9nKGBbbm90aWZpY2F0aW9uc10gTm8gZW1haWwgdGVtcGxhdGUgZm91bmQgZm9yIGJ1c2luZXNzICR7YnVzaW5lc3NJZH0sIHRyaWdnZXIgJHt0cmlnZ2VyfS4gRW1haWwgd2lsbCBub3QgYmUgc2VudC5gKTtcbiAgICBjb25zb2xlLmxvZyhgW25vdGlmaWNhdGlvbnNdIE1ha2Ugc3VyZSBhIHRlbXBsYXRlIGV4aXN0cyB3aXRoOiBidXNpbmVzc19pZD0ke2J1c2luZXNzSWR9LCB0cmlnZ2VyPSR7dHJpZ2dlcn0sIGNoYW5uZWw9ZW1haWwsIGlzX2VuYWJsZWQ9dHJ1ZWApO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKGBbbm90aWZpY2F0aW9uc10gRm91bmQgZW1haWwgdGVtcGxhdGU6ICR7ZW1haWxUZW1wbGF0ZS5pZH0gKCR7ZW1haWxUZW1wbGF0ZS5uYW1lfSksIGVuYWJsZWQ6ICR7ZW1haWxUZW1wbGF0ZS5pc19lbmFibGVkfWApO1xuICB9XG5cbiAgLy8gU2VuZCBlbWFpbCBub3RpZmljYXRpb24gaWYgdGVtcGxhdGUgZXhpc3RzIGFuZCBjdXN0b21lciBoYXMgZW1haWxcbiAgaWYgKGVtYWlsVGVtcGxhdGUgJiYgbm90aWZpY2F0aW9uRGF0YS5jdXN0b21lcj8uZW1haWwpIHtcbiAgICBjb25zdCByZW5kZXJlZEJvZHkgPSByZW5kZXJUZW1wbGF0ZShlbWFpbFRlbXBsYXRlLmJvZHlfbWFya2Rvd24sIG5vdGlmaWNhdGlvbkRhdGEsIHRpbWV6b25lKTtcbiAgICBjb25zdCByZW5kZXJlZFN1YmplY3QgPSBlbWFpbFRlbXBsYXRlLnN1YmplY3RcbiAgICAgID8gcmVuZGVyVGVtcGxhdGUoZW1haWxUZW1wbGF0ZS5zdWJqZWN0LCBub3RpZmljYXRpb25EYXRhLCB0aW1lem9uZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gRm9yIGJvb2tpbmdfY3JlYXRlZCB0cmlnZ2VyLCBzZW5kIGltbWVkaWF0ZWx5IGluc3RlYWQgb2YgcXVldWluZ1xuICAgIC8vIFRoaXMgZW5zdXJlcyBjdXN0b21lcnMgZ2V0IGNvbmZpcm1hdGlvbiBlbWFpbHMgcmlnaHQgYXdheVxuICAgIGlmICh0cmlnZ2VyID09PSAnYm9va2luZ19jcmVhdGVkJyAmJiByZW5kZXJlZFN1YmplY3QpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbbm90aWZpY2F0aW9uc10gU2VuZGluZyBib29raW5nX2NyZWF0ZWQgZW1haWwgaW1tZWRpYXRlbHkgdG8gJHtub3RpZmljYXRpb25EYXRhLmN1c3RvbWVyLmVtYWlsfWApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBzZW5kRW1haWxWaWFTZW5kR3JpZCB9ID0gYXdhaXQgaW1wb3J0KCcuL25vdGlmaWNhdGlvbi1zZW5kZXJzJyk7XG4gICAgICAgIGNvbnN0IGVtYWlsUmVzdWx0ID0gYXdhaXQgc2VuZEVtYWlsVmlhU2VuZEdyaWQoXG4gICAgICAgICAgbm90aWZpY2F0aW9uRGF0YS5jdXN0b21lci5lbWFpbCxcbiAgICAgICAgICByZW5kZXJlZFN1YmplY3QsXG4gICAgICAgICAgcmVuZGVyZWRCb2R5XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGVtYWlsUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW25vdGlmaWNhdGlvbnNdIEVtYWlsIHNlbnQgc3VjY2Vzc2Z1bGx5IHRvICR7bm90aWZpY2F0aW9uRGF0YS5jdXN0b21lci5lbWFpbH0sIG1lc3NhZ2VJZDogJHtlbWFpbFJlc3VsdC5tZXNzYWdlSWR9YCk7XG4gICAgICAgICAgLy8gQWxzbyBlbnF1ZXVlIGZvciBhdWRpdCB0cmFpbFxuICAgICAgICAgIGF3YWl0IGVucXVldWVOb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgYnVzaW5lc3NJZCxcbiAgICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICAgIGJvb2tpbmdJZCxcbiAgICAgICAgICAgIHRyaWdnZXIsXG4gICAgICAgICAgICByZWNpcGllbnRFbWFpbDogbm90aWZpY2F0aW9uRGF0YS5jdXN0b21lci5lbWFpbCxcbiAgICAgICAgICAgIHRlbXBsYXRlSWQ6IGVtYWlsVGVtcGxhdGUuaWQsXG4gICAgICAgICAgICBzdWJqZWN0OiByZW5kZXJlZFN1YmplY3QsXG4gICAgICAgICAgICBib2R5OiByZW5kZXJlZEJvZHksXG4gICAgICAgICAgICBjaGFubmVsOiAnZW1haWwnLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIE1hcmsgdGhlIHF1ZXVlZCBqb2IgYXMgc2VudCBpbW1lZGlhdGVseVxuICAgICAgICAgIGNvbnN0IGFkbWluU3VwYWJhc2UgPSBjcmVhdGVBZG1pbkNsaWVudCgpO1xuICAgICAgICAgIGNvbnN0IHsgZGF0YTogam9icyB9ID0gYXdhaXQgYWRtaW5TdXBhYmFzZVxuICAgICAgICAgICAgLmZyb20oJ25vdGlmaWNhdGlvbl9qb2JzJylcbiAgICAgICAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgICAgICAgIC5lcSgnYm9va2luZ19pZCcsIGJvb2tpbmdJZClcbiAgICAgICAgICAgIC5lcSgndHJpZ2dlcicsIHRyaWdnZXIpXG4gICAgICAgICAgICAuZXEoJ2NoYW5uZWwnLCAnZW1haWwnKVxuICAgICAgICAgICAgLmVxKCdzdGF0dXMnLCAncGVuZGluZycpXG4gICAgICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgICAgICAgIC5saW1pdCgxKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoam9icyAmJiBqb2JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IGFkbWluU3VwYWJhc2VcbiAgICAgICAgICAgICAgLmZyb20oJ25vdGlmaWNhdGlvbl9qb2JzJylcbiAgICAgICAgICAgICAgLnVwZGF0ZSh7IHN0YXR1czogJ3NlbnQnIH0pXG4gICAgICAgICAgICAgIC5lcSgnaWQnLCBqb2JzWzBdLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgW25vdGlmaWNhdGlvbnNdIEZhaWxlZCB0byBzZW5kIGVtYWlsOiAke2VtYWlsUmVzdWx0LmVycm9yfWApO1xuICAgICAgICAgIC8vIEZhbGwgYmFjayB0byBxdWV1aW5nIGlmIGltbWVkaWF0ZSBzZW5kIGZhaWxzXG4gICAgICAgICAgYXdhaXQgZW5xdWV1ZU5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICBidXNpbmVzc0lkLFxuICAgICAgICAgICAgdXNlcklkLFxuICAgICAgICAgICAgYm9va2luZ0lkLFxuICAgICAgICAgICAgdHJpZ2dlcixcbiAgICAgICAgICAgIHJlY2lwaWVudEVtYWlsOiBub3RpZmljYXRpb25EYXRhLmN1c3RvbWVyLmVtYWlsLFxuICAgICAgICAgICAgdGVtcGxhdGVJZDogZW1haWxUZW1wbGF0ZS5pZCxcbiAgICAgICAgICAgIHN1YmplY3Q6IHJlbmRlcmVkU3ViamVjdCxcbiAgICAgICAgICAgIGJvZHk6IHJlbmRlcmVkQm9keSxcbiAgICAgICAgICAgIGNoYW5uZWw6ICdlbWFpbCcsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFtub3RpZmljYXRpb25zXSBFcnJvciBzZW5kaW5nIGVtYWlsIGltbWVkaWF0ZWx5OmAsIGVycm9yKTtcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHF1ZXVpbmcgaWYgaW1tZWRpYXRlIHNlbmQgZmFpbHNcbiAgICAgICAgYXdhaXQgZW5xdWV1ZU5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgYnVzaW5lc3NJZCxcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgYm9va2luZ0lkLFxuICAgICAgICAgIHRyaWdnZXIsXG4gICAgICAgICAgcmVjaXBpZW50RW1haWw6IG5vdGlmaWNhdGlvbkRhdGEuY3VzdG9tZXIuZW1haWwsXG4gICAgICAgICAgdGVtcGxhdGVJZDogZW1haWxUZW1wbGF0ZS5pZCxcbiAgICAgICAgICBzdWJqZWN0OiByZW5kZXJlZFN1YmplY3QsXG4gICAgICAgICAgYm9keTogcmVuZGVyZWRCb2R5LFxuICAgICAgICAgIGNoYW5uZWw6ICdlbWFpbCcsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3Igb3RoZXIgdHJpZ2dlcnMsIHF1ZXVlIGFzIG5vcm1hbFxuICAgICAgY29uc29sZS5sb2coYFtub3RpZmljYXRpb25zXSBFbnF1ZXVlaW5nIGVtYWlsIG5vdGlmaWNhdGlvbiBmb3IgYm9va2luZyAke2Jvb2tpbmdJZH0gdG8gJHtub3RpZmljYXRpb25EYXRhLmN1c3RvbWVyLmVtYWlsfWApO1xuICAgICAgYXdhaXQgZW5xdWV1ZU5vdGlmaWNhdGlvbih7XG4gICAgICAgIGJ1c2luZXNzSWQsXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgYm9va2luZ0lkLFxuICAgICAgICB0cmlnZ2VyLFxuICAgICAgICByZWNpcGllbnRFbWFpbDogbm90aWZpY2F0aW9uRGF0YS5jdXN0b21lci5lbWFpbCxcbiAgICAgICAgdGVtcGxhdGVJZDogZW1haWxUZW1wbGF0ZS5pZCxcbiAgICAgICAgc3ViamVjdDogcmVuZGVyZWRTdWJqZWN0LFxuICAgICAgICBib2R5OiByZW5kZXJlZEJvZHksXG4gICAgICAgIGNoYW5uZWw6ICdlbWFpbCcsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBTTVMgbm90aWZpY2F0aW9ucyBkaXNhYmxlZCBmb3IgdjEgLSB3aWxsIGJlIGVuYWJsZWQgaW4gdjJcbiAgLy8gRW5xdWV1ZSBTTVMgbm90aWZpY2F0aW9uIGlmIHRlbXBsYXRlIGV4aXN0cyBhbmQgY3VzdG9tZXIgaGFzIHBob25lXG4gIC8vIGlmIChzbXNUZW1wbGF0ZSAmJiBub3RpZmljYXRpb25EYXRhLmN1c3RvbWVyPy5waG9uZSkge1xuICAvLyAgIGNvbnN0IHJlbmRlcmVkQm9keSA9IHJlbmRlclRlbXBsYXRlKHNtc1RlbXBsYXRlLmJvZHlfbWFya2Rvd24sIG5vdGlmaWNhdGlvbkRhdGEsIHRpbWV6b25lKTtcbiAgLy9cbiAgLy8gICBhd2FpdCBlbnF1ZXVlTm90aWZpY2F0aW9uKHtcbiAgLy8gICAgIGJ1c2luZXNzSWQsXG4gIC8vICAgICB1c2VySWQsXG4gIC8vICAgICBib29raW5nSWQsXG4gIC8vICAgICB0cmlnZ2VyLFxuICAvLyAgICAgcmVjaXBpZW50UGhvbmU6IG5vdGlmaWNhdGlvbkRhdGEuY3VzdG9tZXIucGhvbmUsXG4gIC8vICAgICB0ZW1wbGF0ZUlkOiBzbXNUZW1wbGF0ZS5pZCxcbiAgLy8gICAgIGJvZHk6IHJlbmRlcmVkQm9keSxcbiAgLy8gICAgIGNoYW5uZWw6ICdzbXMnLFxuICAvLyAgIH0pO1xuICAvLyB9XG59XG5cbi8qKlxuICogQ3JlYXRlIG5vdGlmaWNhdGlvbiBqb2IgZnJvbSB0ZW1wbGF0ZSBhbmQgZGF0YSAobGVnYWN5IGZ1bmN0aW9uLCB1c2UgZW1pdE5vdGlmaWNhdGlvbilcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU5vdGlmaWNhdGlvbkZyb21UZW1wbGF0ZShwYXJhbXM6IHtcbiAgYnVzaW5lc3NJZDogc3RyaW5nO1xuICB1c2VySWQ6IHN0cmluZztcbiAgYm9va2luZ0lkPzogc3RyaW5nO1xuICB0cmlnZ2VyOiBOb3RpZmljYXRpb25UcmlnZ2VyO1xuICBkYXRhOiBOb3RpZmljYXRpb25EYXRhO1xufSk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCB7IGJ1c2luZXNzSWQsIHVzZXJJZCwgYm9va2luZ0lkLCB0cmlnZ2VyLCBkYXRhIH0gPSBwYXJhbXM7XG5cbiAgaWYgKCFib29raW5nSWQpIHtcbiAgICBjb25zb2xlLmVycm9yKCdjcmVhdGVOb3RpZmljYXRpb25Gcm9tVGVtcGxhdGUgcmVxdWlyZXMgYm9va2luZ0lkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVXNlIHRoZSBtYWluIGVtaXROb3RpZmljYXRpb24gZnVuY3Rpb25cbiAgYXdhaXQgZW1pdE5vdGlmaWNhdGlvbihidXNpbmVzc0lkLCB0cmlnZ2VyLCBib29raW5nSWQpO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGU6IERhdGUsIHRpbWV6b25lOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gZm9ybWF0SW5UaW1lWm9uZShkYXRlLnRvSVNPU3RyaW5nKCksIHRpbWV6b25lLCB7XG4gICAgd2Vla2RheTogJ2xvbmcnLFxuICAgIHllYXI6ICdudW1lcmljJyxcbiAgICBtb250aDogJ2xvbmcnLFxuICAgIGRheTogJ251bWVyaWMnLFxuICB9KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VGltZShkYXRlOiBEYXRlLCB0aW1lem9uZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGZvcm1hdEluVGltZVpvbmUoZGF0ZS50b0lTT1N0cmluZygpLCB0aW1lem9uZSwge1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICBob3VyMTI6IHRydWUsXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRQcmljZShjZW50czogbnVtYmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAkJHsoY2VudHMgLyAxMDApLnRvRml4ZWQoMil9YDtcbn1cblxuXG4iXSwibmFtZXMiOlsiY3JlYXRlQWRtaW5DbGllbnQiLCJmb3JtYXRJblRpbWVab25lIiwiQUxMT1dFRF9QTEFDRUhPTERFUlMiLCJ2YWxpZGF0ZVBsYWNlaG9sZGVycyIsInRlbXBsYXRlIiwicGxhY2Vob2xkZXJSZWdleCIsIm1hdGNoZXMiLCJBcnJheSIsImZyb20iLCJtYXRjaEFsbCIsImZvdW5kUGxhY2Vob2xkZXJzIiwibWFwIiwibSIsImludmFsaWQiLCJmaWx0ZXIiLCJwIiwiaW5jbHVkZXMiLCJ2YWxpZCIsImxlbmd0aCIsInJlbmRlclRlbXBsYXRlIiwiZGF0YSIsInRpbWV6b25lIiwicmVuZGVyZWQiLCJ0eiIsImJ1c2luZXNzIiwiY3VzdG9tZXIiLCJyZXBsYWNlIiwibmFtZSIsImVtYWlsIiwicGhvbmUiLCJzZXJ2aWNlIiwiU3RyaW5nIiwiZHVyYXRpb25fbWluIiwiZm9ybWF0UHJpY2UiLCJwcmljZV9jZW50cyIsInN0YWZmIiwiYm9va2luZyIsInN0YXJ0RGF0ZSIsIkRhdGUiLCJzdGFydF9hdCIsImZvcm1hdERhdGUiLCJmb3JtYXRUaW1lIiwiaWQiLCJzbGljZSIsInRvVXBwZXJDYXNlIiwiYW1vdW50IiwiZmluYWxfcHJpY2VfY2VudHMiLCJzdXBwb3J0X2VtYWlsIiwiYm9va2luZ191cmwiLCJzdWJkb21haW4iLCJib29raW5nQ29kZSIsInVybCIsInVuZGVmaW5lZCIsImVucXVldWVOb3RpZmljYXRpb24iLCJwYXJhbXMiLCJzdXBhYmFzZSIsImJvb2tpbmdJZCIsImV4aXN0aW5nIiwic2VsZWN0IiwiZXEiLCJ0cmlnZ2VyIiwiY2hhbm5lbCIsImxpbWl0Iiwic2luZ2xlIiwibm93IiwidG9JU09TdHJpbmciLCJlcnJvciIsImluc2VydCIsInVzZXJfaWQiLCJ1c2VySWQiLCJidXNpbmVzc19pZCIsImJ1c2luZXNzSWQiLCJib29raW5nX2lkIiwidGVtcGxhdGVfaWQiLCJ0ZW1wbGF0ZUlkIiwicmVjaXBpZW50X2VtYWlsIiwicmVjaXBpZW50RW1haWwiLCJyZWNpcGllbnRfcGhvbmUiLCJyZWNpcGllbnRQaG9uZSIsInN1YmplY3QiLCJib2R5Iiwic3RhdHVzIiwiYXR0ZW1wdF9jb3VudCIsInNjaGVkdWxlZF9hdCIsIm5leHRfcmV0cnlfYXQiLCJjcmVhdGVkX2F0IiwiY29kZSIsImNvbnNvbGUiLCJsb2FkVGVtcGxhdGVGb3JUcmlnZ2VyIiwiY2xpZW50IiwiaXMiLCJvcmRlciIsImFzY2VuZGluZyIsIm1heWJlU2luZ2xlIiwiZW1pdE5vdGlmaWNhdGlvbiIsImdldEVmZmVjdGl2ZU5vdGlmaWNhdGlvbnNFbmFibGVkIiwibG9nIiwibm90aWZpY2F0aW9uc19lbmFibGVkIiwiYm9va2luZ0Vycm9yIiwiZmVlQW1vdW50IiwibGF0ZXN0UGF5bWVudCIsImluIiwiYW1vdW50X2NlbnRzIiwibm90aWZpY2F0aW9uRGF0YSIsImVuZF9hdCIsInN0YWZmX2lkIiwiY3VzdG9tZXJzIiwic2VydmljZXMiLCJlbWFpbFRlbXBsYXRlIiwiaXNfZW5hYmxlZCIsInJlbmRlcmVkQm9keSIsImJvZHlfbWFya2Rvd24iLCJyZW5kZXJlZFN1YmplY3QiLCJzZW5kRW1haWxWaWFTZW5kR3JpZCIsImVtYWlsUmVzdWx0Iiwic3VjY2VzcyIsIm1lc3NhZ2VJZCIsImFkbWluU3VwYWJhc2UiLCJqb2JzIiwidXBkYXRlIiwiY3JlYXRlTm90aWZpY2F0aW9uRnJvbVRlbXBsYXRlIiwiZGF0ZSIsIndlZWtkYXkiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJob3VyIiwibWludXRlIiwiaG91cjEyIiwiY2VudHMiLCJ0b0ZpeGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/notifications.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/stripe.ts":
/*!***************************!*\
  !*** ./src/lib/stripe.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAccountLink: () => (/* binding */ createAccountLink),\n/* harmony export */   createConnectAccount: () => (/* binding */ createConnectAccount),\n/* harmony export */   createOrGetCustomer: () => (/* binding */ createOrGetCustomer),\n/* harmony export */   createPaymentIntent: () => (/* binding */ createPaymentIntent),\n/* harmony export */   createRefund: () => (/* binding */ createRefund),\n/* harmony export */   createSetupIntent: () => (/* binding */ createSetupIntent),\n/* harmony export */   createSubscription: () => (/* binding */ createSubscription),\n/* harmony export */   getPaymentMethodFromSetupIntent: () => (/* binding */ getPaymentMethodFromSetupIntent),\n/* harmony export */   getStripeClient: () => (/* binding */ getStripeClient),\n/* harmony export */   verifyConnectAccount: () => (/* binding */ verifyConnectAccount)\n/* harmony export */ });\n/* harmony import */ var stripe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stripe */ \"(rsc)/../../node_modules/stripe/esm/stripe.esm.node.js\");\n\nconst stripeSecretKey = process.env.STRIPE_SECRET_KEY;\nif (!stripeSecretKey) {\n    console.warn(\"STRIPE_SECRET_KEY not set - Stripe features will not work\");\n}\n/**\n * Get Stripe client instance\n */ function getStripeClient() {\n    if (!stripeSecretKey) {\n        throw new Error(\"STRIPE_SECRET_KEY environment variable is not set\");\n    }\n    return new stripe__WEBPACK_IMPORTED_MODULE_0__[\"default\"](stripeSecretKey, {\n        apiVersion: \"2024-11-20.acacia\"\n    });\n}\n/**\n * Create a Stripe Connect Express account\n * Returns the account ID\n */ async function createConnectAccount(userId, email) {\n    const stripe = getStripeClient();\n    const account = await stripe.accounts.create({\n        type: \"express\",\n        email,\n        capabilities: {\n            card_payments: {\n                requested: true\n            },\n            transfers: {\n                requested: true\n            }\n        },\n        metadata: {\n            user_id: userId\n        }\n    });\n    return account.id;\n}\n/**\n * Create an Account Link for Stripe Connect onboarding\n * Returns the URL to redirect the user to\n */ async function createAccountLink(accountId, returnUrl, refreshUrl) {\n    const stripe = getStripeClient();\n    const accountLink = await stripe.accountLinks.create({\n        account: accountId,\n        type: \"account_onboarding\",\n        return_url: returnUrl,\n        refresh_url: refreshUrl\n    });\n    return accountLink.url;\n}\n/**\n * Create or retrieve a Stripe Customer\n */ async function createOrGetCustomer(email, name, metadata) {\n    const stripe = getStripeClient();\n    // Search for existing customer by email\n    const existingCustomers = await stripe.customers.list({\n        email,\n        limit: 1\n    });\n    if (existingCustomers.data.length > 0) {\n        return existingCustomers.data[0].id;\n    }\n    // Create new customer\n    const customer = await stripe.customers.create({\n        email,\n        name,\n        metadata: metadata || {}\n    });\n    return customer.id;\n}\n/**\n * Create a SetupIntent to save a card without charging\n */ async function createSetupIntent(customerId, metadata) {\n    const stripe = getStripeClient();\n    const setupIntent = await stripe.setupIntents.create({\n        customer: customerId,\n        payment_method_types: [\n            \"card\"\n        ],\n        metadata: metadata || {}\n    });\n    return {\n        setupIntentId: setupIntent.id,\n        clientSecret: setupIntent.client_secret\n    };\n}\n/**\n * Create a subscription for the business owner ($11.99/mo)\n * Includes 7-day trial period as per app design\n */ async function createSubscription(customerId, priceId, metadata, paymentMethodId // Optional: if owner already has payment method ready\n) {\n    const stripe = getStripeClient();\n    const subscriptionParams = {\n        customer: customerId,\n        items: [\n            {\n                price: priceId\n            }\n        ],\n        payment_settings: {\n            save_default_payment_method: \"on_subscription\"\n        },\n        expand: [\n            \"latest_invoice.payment_intent\"\n        ],\n        metadata: metadata || {},\n        // 7-day trial period as per app design\n        trial_period_days: 7\n    };\n    // If payment method is provided, attach it; otherwise subscription will be incomplete\n    if (paymentMethodId) {\n        subscriptionParams.default_payment_method = paymentMethodId;\n        subscriptionParams.payment_behavior = \"default_incomplete\";\n    } else {\n        // Subscription will be incomplete until payment method is added\n        subscriptionParams.payment_behavior = \"default_incomplete\";\n    }\n    const subscription = await stripe.subscriptions.create(subscriptionParams);\n    return {\n        subscriptionId: subscription.id,\n        status: subscription.status,\n        current_period_end: subscription.current_period_end,\n        trial_end: subscription.trial_end\n    };\n}\n/**\n * Create a PaymentIntent with Connect destination charge\n * This charges the customer and sends funds to the connected account\n * Supports off-session charges for saved payment methods\n * \n * Returns the PaymentIntent with status information\n */ async function createPaymentIntent(params) {\n    const stripe = getStripeClient();\n    const { amount, customerId, paymentMethodId, connectAccountId, applicationFee, metadata, offSession = false } = params;\n    // Create PaymentIntent on platform account with Connect destination\n    const paymentIntentParams = {\n        amount,\n        currency: \"usd\",\n        customer: customerId,\n        payment_method: paymentMethodId,\n        on_behalf_of: connectAccountId,\n        transfer_data: {\n            destination: connectAccountId\n        },\n        application_fee_amount: applicationFee,\n        metadata: metadata || {}\n    };\n    // For off-session charges, set confirmation method and off_session flag\n    if (offSession) {\n        paymentIntentParams.confirmation_method = \"automatic\";\n        paymentIntentParams.confirm = true;\n        paymentIntentParams.off_session = true;\n        paymentIntentParams.payment_method_options = {\n            card: {\n                request_three_d_secure: \"automatic\"\n            }\n        };\n    } else {\n        paymentIntentParams.confirmation_method = \"manual\";\n        paymentIntentParams.confirm = true;\n    }\n    const paymentIntent = await stripe.paymentIntents.create(paymentIntentParams);\n    return {\n        paymentIntentId: paymentIntent.id,\n        clientSecret: paymentIntent.client_secret || \"\",\n        status: paymentIntent.status,\n        requiresAction: paymentIntent.status === \"requires_action\" || paymentIntent.status === \"requires_payment_method\"\n    };\n}\n/**\n * Create a refund for a PaymentIntent\n */ async function createRefund(paymentIntentId, amount // optional amount to refund (partial refund), if not provided, full refund\n) {\n    const stripe = getStripeClient();\n    const refundParams = {\n        payment_intent: paymentIntentId\n    };\n    if (amount !== undefined) {\n        refundParams.amount = amount;\n    }\n    const refund = await stripe.refunds.create(refundParams);\n    return {\n        refundId: refund.id,\n        amount: refund.amount\n    };\n}\n/**\n * Get payment method from a SetupIntent\n */ async function getPaymentMethodFromSetupIntent(setupIntentId) {\n    const stripe = getStripeClient();\n    const setupIntent = await stripe.setupIntents.retrieve(setupIntentId);\n    if (typeof setupIntent.payment_method === \"string\") {\n        return setupIntent.payment_method;\n    }\n    if (setupIntent.payment_method) {\n        return setupIntent.payment_method.id;\n    }\n    return null;\n}\n/**\n * Verify a Connect account is active\n */ async function verifyConnectAccount(accountId) {\n    try {\n        const stripe = getStripeClient();\n        const account = await stripe.accounts.retrieve(accountId);\n        return account.details_submitted && account.charges_enabled;\n    } catch (error) {\n        console.error(\"Error verifying Connect account:\", error);\n        return false;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL3N0cmlwZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUE0QjtBQUU1QixNQUFNQyxrQkFBa0JDLFFBQVFDLEdBQUcsQ0FBQ0MsaUJBQWlCO0FBRXJELElBQUksQ0FBQ0gsaUJBQWlCO0lBQ3BCSSxRQUFRQyxJQUFJLENBQUM7QUFDZjtBQUVBOztDQUVDLEdBQ00sU0FBU0M7SUFDZCxJQUFJLENBQUNOLGlCQUFpQjtRQUNwQixNQUFNLElBQUlPLE1BQU07SUFDbEI7SUFDQSxPQUFPLElBQUlSLDhDQUFNQSxDQUFDQyxpQkFBaUI7UUFDakNRLFlBQVk7SUFDZDtBQUNGO0FBRUE7OztDQUdDLEdBQ00sZUFBZUMscUJBQXFCQyxNQUFjLEVBQUVDLEtBQWE7SUFDdEUsTUFBTUMsU0FBU047SUFFZixNQUFNTyxVQUFVLE1BQU1ELE9BQU9FLFFBQVEsQ0FBQ0MsTUFBTSxDQUFDO1FBQzNDQyxNQUFNO1FBQ05MO1FBQ0FNLGNBQWM7WUFDWkMsZUFBZTtnQkFBRUMsV0FBVztZQUFLO1lBQ2pDQyxXQUFXO2dCQUFFRCxXQUFXO1lBQUs7UUFDL0I7UUFDQUUsVUFBVTtZQUNSQyxTQUFTWjtRQUNYO0lBQ0Y7SUFFQSxPQUFPRyxRQUFRVSxFQUFFO0FBQ25CO0FBRUE7OztDQUdDLEdBQ00sZUFBZUMsa0JBQ3BCQyxTQUFpQixFQUNqQkMsU0FBaUIsRUFDakJDLFVBQWtCO0lBRWxCLE1BQU1mLFNBQVNOO0lBRWYsTUFBTXNCLGNBQWMsTUFBTWhCLE9BQU9pQixZQUFZLENBQUNkLE1BQU0sQ0FBQztRQUNuREYsU0FBU1k7UUFDVFQsTUFBTTtRQUNOYyxZQUFZSjtRQUNaSyxhQUFhSjtJQUNmO0lBRUEsT0FBT0MsWUFBWUksR0FBRztBQUN4QjtBQUVBOztDQUVDLEdBQ00sZUFBZUMsb0JBQ3BCdEIsS0FBYSxFQUNidUIsSUFBWSxFQUNaYixRQUFpQztJQUVqQyxNQUFNVCxTQUFTTjtJQUVmLHdDQUF3QztJQUN4QyxNQUFNNkIsb0JBQW9CLE1BQU12QixPQUFPd0IsU0FBUyxDQUFDQyxJQUFJLENBQUM7UUFDcEQxQjtRQUNBMkIsT0FBTztJQUNUO0lBRUEsSUFBSUgsa0JBQWtCSSxJQUFJLENBQUNDLE1BQU0sR0FBRyxHQUFHO1FBQ3JDLE9BQU9MLGtCQUFrQkksSUFBSSxDQUFDLEVBQUUsQ0FBQ2hCLEVBQUU7SUFDckM7SUFFQSxzQkFBc0I7SUFDdEIsTUFBTWtCLFdBQVcsTUFBTTdCLE9BQU93QixTQUFTLENBQUNyQixNQUFNLENBQUM7UUFDN0NKO1FBQ0F1QjtRQUNBYixVQUFVQSxZQUFZLENBQUM7SUFDekI7SUFFQSxPQUFPb0IsU0FBU2xCLEVBQUU7QUFDcEI7QUFFQTs7Q0FFQyxHQUNNLGVBQWVtQixrQkFDcEJDLFVBQWtCLEVBQ2xCdEIsUUFBaUM7SUFFakMsTUFBTVQsU0FBU047SUFFZixNQUFNc0MsY0FBYyxNQUFNaEMsT0FBT2lDLFlBQVksQ0FBQzlCLE1BQU0sQ0FBQztRQUNuRDBCLFVBQVVFO1FBQ1ZHLHNCQUFzQjtZQUFDO1NBQU87UUFDOUJ6QixVQUFVQSxZQUFZLENBQUM7SUFDekI7SUFFQSxPQUFPO1FBQ0wwQixlQUFlSCxZQUFZckIsRUFBRTtRQUM3QnlCLGNBQWNKLFlBQVlLLGFBQWE7SUFDekM7QUFDRjtBQUVBOzs7Q0FHQyxHQUNNLGVBQWVDLG1CQUNwQlAsVUFBa0IsRUFDbEJRLE9BQWUsRUFDZjlCLFFBQWlDLEVBQ2pDK0IsZ0JBQXlCLHNEQUFzRDtBQUF2RDtJQUV4QixNQUFNeEMsU0FBU047SUFFZixNQUFNK0MscUJBQXNEO1FBQzFEWixVQUFVRTtRQUNWVyxPQUFPO1lBQUM7Z0JBQUVDLE9BQU9KO1lBQVE7U0FBRTtRQUMzQkssa0JBQWtCO1lBQUVDLDZCQUE2QjtRQUFrQjtRQUNuRUMsUUFBUTtZQUFDO1NBQWdDO1FBQ3pDckMsVUFBVUEsWUFBWSxDQUFDO1FBQ3ZCLHVDQUF1QztRQUN2Q3NDLG1CQUFtQjtJQUNyQjtJQUVBLHNGQUFzRjtJQUN0RixJQUFJUCxpQkFBaUI7UUFDbkJDLG1CQUFtQk8sc0JBQXNCLEdBQUdSO1FBQzVDQyxtQkFBbUJRLGdCQUFnQixHQUFHO0lBQ3hDLE9BQU87UUFDTCxnRUFBZ0U7UUFDaEVSLG1CQUFtQlEsZ0JBQWdCLEdBQUc7SUFDeEM7SUFFQSxNQUFNQyxlQUFlLE1BQU1sRCxPQUFPbUQsYUFBYSxDQUFDaEQsTUFBTSxDQUFDc0M7SUFFdkQsT0FBTztRQUNMVyxnQkFBZ0JGLGFBQWF2QyxFQUFFO1FBQy9CMEMsUUFBUUgsYUFBYUcsTUFBTTtRQUMzQkMsb0JBQW9CSixhQUFhSSxrQkFBa0I7UUFDbkRDLFdBQVdMLGFBQWFLLFNBQVM7SUFDbkM7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUNNLGVBQWVDLG9CQUFvQkMsTUFRekM7SUFNQyxNQUFNekQsU0FBU047SUFDZixNQUFNLEVBQUVnRSxNQUFNLEVBQUUzQixVQUFVLEVBQUVTLGVBQWUsRUFBRW1CLGdCQUFnQixFQUFFQyxjQUFjLEVBQUVuRCxRQUFRLEVBQUVvRCxhQUFhLEtBQUssRUFBRSxHQUFHSjtJQUVoSCxvRUFBb0U7SUFDcEUsTUFBTUssc0JBQXdEO1FBQzVESjtRQUNBSyxVQUFVO1FBQ1ZsQyxVQUFVRTtRQUNWaUMsZ0JBQWdCeEI7UUFDaEJ5QixjQUFjTjtRQUNkTyxlQUFlO1lBQ2JDLGFBQWFSO1FBQ2Y7UUFDQVMsd0JBQXdCUjtRQUN4Qm5ELFVBQVVBLFlBQVksQ0FBQztJQUN6QjtJQUVBLHdFQUF3RTtJQUN4RSxJQUFJb0QsWUFBWTtRQUNkQyxvQkFBb0JPLG1CQUFtQixHQUFHO1FBQzFDUCxvQkFBb0JRLE9BQU8sR0FBRztRQUM5QlIsb0JBQW9CUyxXQUFXLEdBQUc7UUFDbENULG9CQUFvQlUsc0JBQXNCLEdBQUc7WUFDM0NDLE1BQU07Z0JBQ0pDLHdCQUF3QjtZQUMxQjtRQUNGO0lBQ0YsT0FBTztRQUNMWixvQkFBb0JPLG1CQUFtQixHQUFHO1FBQzFDUCxvQkFBb0JRLE9BQU8sR0FBRztJQUNoQztJQUVBLE1BQU1LLGdCQUFnQixNQUFNM0UsT0FBTzRFLGNBQWMsQ0FBQ3pFLE1BQU0sQ0FBQzJEO0lBRXpELE9BQU87UUFDTGUsaUJBQWlCRixjQUFjaEUsRUFBRTtRQUNqQ3lCLGNBQWN1QyxjQUFjdEMsYUFBYSxJQUFJO1FBQzdDZ0IsUUFBUXNCLGNBQWN0QixNQUFNO1FBQzVCeUIsZ0JBQWdCSCxjQUFjdEIsTUFBTSxLQUFLLHFCQUFxQnNCLGNBQWN0QixNQUFNLEtBQUs7SUFDekY7QUFDRjtBQUVBOztDQUVDLEdBQ00sZUFBZTBCLGFBQ3BCRixlQUF1QixFQUN2Qm5CLE9BQWdCLDJFQUEyRTtBQUE1RTtJQUVmLE1BQU0xRCxTQUFTTjtJQUVmLE1BQU1zRixlQUEwQztRQUM5Q0MsZ0JBQWdCSjtJQUNsQjtJQUVBLElBQUluQixXQUFXd0IsV0FBVztRQUN4QkYsYUFBYXRCLE1BQU0sR0FBR0E7SUFDeEI7SUFFQSxNQUFNeUIsU0FBUyxNQUFNbkYsT0FBT29GLE9BQU8sQ0FBQ2pGLE1BQU0sQ0FBQzZFO0lBRTNDLE9BQU87UUFDTEssVUFBVUYsT0FBT3hFLEVBQUU7UUFDbkIrQyxRQUFReUIsT0FBT3pCLE1BQU07SUFDdkI7QUFDRjtBQUVBOztDQUVDLEdBQ00sZUFBZTRCLGdDQUNwQm5ELGFBQXFCO0lBRXJCLE1BQU1uQyxTQUFTTjtJQUVmLE1BQU1zQyxjQUFjLE1BQU1oQyxPQUFPaUMsWUFBWSxDQUFDc0QsUUFBUSxDQUFDcEQ7SUFFdkQsSUFBSSxPQUFPSCxZQUFZZ0MsY0FBYyxLQUFLLFVBQVU7UUFDbEQsT0FBT2hDLFlBQVlnQyxjQUFjO0lBQ25DO0lBRUEsSUFBSWhDLFlBQVlnQyxjQUFjLEVBQUU7UUFDOUIsT0FBT2hDLFlBQVlnQyxjQUFjLENBQUNyRCxFQUFFO0lBQ3RDO0lBRUEsT0FBTztBQUNUO0FBRUE7O0NBRUMsR0FDTSxlQUFlNkUscUJBQXFCM0UsU0FBaUI7SUFDMUQsSUFBSTtRQUNGLE1BQU1iLFNBQVNOO1FBQ2YsTUFBTU8sVUFBVSxNQUFNRCxPQUFPRSxRQUFRLENBQUNxRixRQUFRLENBQUMxRTtRQUUvQyxPQUFPWixRQUFRd0YsaUJBQWlCLElBQUl4RixRQUFReUYsZUFBZTtJQUM3RCxFQUFFLE9BQU9DLE9BQU87UUFDZG5HLFFBQVFtRyxLQUFLLENBQUMsb0NBQW9DQTtRQUNsRCxPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL3NyYy9saWIvc3RyaXBlLnRzPzc5OGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFN0cmlwZSBmcm9tICdzdHJpcGUnO1xuXG5jb25zdCBzdHJpcGVTZWNyZXRLZXkgPSBwcm9jZXNzLmVudi5TVFJJUEVfU0VDUkVUX0tFWTtcblxuaWYgKCFzdHJpcGVTZWNyZXRLZXkpIHtcbiAgY29uc29sZS53YXJuKCdTVFJJUEVfU0VDUkVUX0tFWSBub3Qgc2V0IC0gU3RyaXBlIGZlYXR1cmVzIHdpbGwgbm90IHdvcmsnKTtcbn1cblxuLyoqXG4gKiBHZXQgU3RyaXBlIGNsaWVudCBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RyaXBlQ2xpZW50KCk6IFN0cmlwZSB7XG4gIGlmICghc3RyaXBlU2VjcmV0S2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTVFJJUEVfU0VDUkVUX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3Qgc2V0Jyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBTdHJpcGUoc3RyaXBlU2VjcmV0S2V5LCB7XG4gICAgYXBpVmVyc2lvbjogJzIwMjQtMTEtMjAuYWNhY2lhJyxcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgU3RyaXBlIENvbm5lY3QgRXhwcmVzcyBhY2NvdW50XG4gKiBSZXR1cm5zIHRoZSBhY2NvdW50IElEXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb25uZWN0QWNjb3VudCh1c2VySWQ6IHN0cmluZywgZW1haWw6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IHN0cmlwZSA9IGdldFN0cmlwZUNsaWVudCgpO1xuXG4gIGNvbnN0IGFjY291bnQgPSBhd2FpdCBzdHJpcGUuYWNjb3VudHMuY3JlYXRlKHtcbiAgICB0eXBlOiAnZXhwcmVzcycsXG4gICAgZW1haWwsXG4gICAgY2FwYWJpbGl0aWVzOiB7XG4gICAgICBjYXJkX3BheW1lbnRzOiB7IHJlcXVlc3RlZDogdHJ1ZSB9LFxuICAgICAgdHJhbnNmZXJzOiB7IHJlcXVlc3RlZDogdHJ1ZSB9LFxuICAgIH0sXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICB9LFxuICB9KTtcblxuICByZXR1cm4gYWNjb3VudC5pZDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gQWNjb3VudCBMaW5rIGZvciBTdHJpcGUgQ29ubmVjdCBvbmJvYXJkaW5nXG4gKiBSZXR1cm5zIHRoZSBVUkwgdG8gcmVkaXJlY3QgdGhlIHVzZXIgdG9cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUFjY291bnRMaW5rKFxuICBhY2NvdW50SWQ6IHN0cmluZyxcbiAgcmV0dXJuVXJsOiBzdHJpbmcsXG4gIHJlZnJlc2hVcmw6IHN0cmluZ1xuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3Qgc3RyaXBlID0gZ2V0U3RyaXBlQ2xpZW50KCk7XG5cbiAgY29uc3QgYWNjb3VudExpbmsgPSBhd2FpdCBzdHJpcGUuYWNjb3VudExpbmtzLmNyZWF0ZSh7XG4gICAgYWNjb3VudDogYWNjb3VudElkLFxuICAgIHR5cGU6ICdhY2NvdW50X29uYm9hcmRpbmcnLFxuICAgIHJldHVybl91cmw6IHJldHVyblVybCxcbiAgICByZWZyZXNoX3VybDogcmVmcmVzaFVybCxcbiAgfSk7XG5cbiAgcmV0dXJuIGFjY291bnRMaW5rLnVybDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgb3IgcmV0cmlldmUgYSBTdHJpcGUgQ3VzdG9tZXJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU9yR2V0Q3VzdG9tZXIoXG4gIGVtYWlsOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBzdHJpcGUgPSBnZXRTdHJpcGVDbGllbnQoKTtcblxuICAvLyBTZWFyY2ggZm9yIGV4aXN0aW5nIGN1c3RvbWVyIGJ5IGVtYWlsXG4gIGNvbnN0IGV4aXN0aW5nQ3VzdG9tZXJzID0gYXdhaXQgc3RyaXBlLmN1c3RvbWVycy5saXN0KHtcbiAgICBlbWFpbCxcbiAgICBsaW1pdDogMSxcbiAgfSk7XG5cbiAgaWYgKGV4aXN0aW5nQ3VzdG9tZXJzLmRhdGEubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBleGlzdGluZ0N1c3RvbWVycy5kYXRhWzBdLmlkO1xuICB9XG5cbiAgLy8gQ3JlYXRlIG5ldyBjdXN0b21lclxuICBjb25zdCBjdXN0b21lciA9IGF3YWl0IHN0cmlwZS5jdXN0b21lcnMuY3JlYXRlKHtcbiAgICBlbWFpbCxcbiAgICBuYW1lLFxuICAgIG1ldGFkYXRhOiBtZXRhZGF0YSB8fCB7fSxcbiAgfSk7XG5cbiAgcmV0dXJuIGN1c3RvbWVyLmlkO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIFNldHVwSW50ZW50IHRvIHNhdmUgYSBjYXJkIHdpdGhvdXQgY2hhcmdpbmdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNldHVwSW50ZW50KFxuICBjdXN0b21lcklkOiBzdHJpbmcsXG4gIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuKTogUHJvbWlzZTx7IHNldHVwSW50ZW50SWQ6IHN0cmluZzsgY2xpZW50U2VjcmV0OiBzdHJpbmcgfT4ge1xuICBjb25zdCBzdHJpcGUgPSBnZXRTdHJpcGVDbGllbnQoKTtcblxuICBjb25zdCBzZXR1cEludGVudCA9IGF3YWl0IHN0cmlwZS5zZXR1cEludGVudHMuY3JlYXRlKHtcbiAgICBjdXN0b21lcjogY3VzdG9tZXJJZCxcbiAgICBwYXltZW50X21ldGhvZF90eXBlczogWydjYXJkJ10sXG4gICAgbWV0YWRhdGE6IG1ldGFkYXRhIHx8IHt9LFxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHNldHVwSW50ZW50SWQ6IHNldHVwSW50ZW50LmlkLFxuICAgIGNsaWVudFNlY3JldDogc2V0dXBJbnRlbnQuY2xpZW50X3NlY3JldCEsXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc3Vic2NyaXB0aW9uIGZvciB0aGUgYnVzaW5lc3Mgb3duZXIgKCQxMS45OS9tbylcbiAqIEluY2x1ZGVzIDctZGF5IHRyaWFsIHBlcmlvZCBhcyBwZXIgYXBwIGRlc2lnblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlU3Vic2NyaXB0aW9uKFxuICBjdXN0b21lcklkOiBzdHJpbmcsXG4gIHByaWNlSWQ6IHN0cmluZyxcbiAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICBwYXltZW50TWV0aG9kSWQ/OiBzdHJpbmcgLy8gT3B0aW9uYWw6IGlmIG93bmVyIGFscmVhZHkgaGFzIHBheW1lbnQgbWV0aG9kIHJlYWR5XG4pOiBQcm9taXNlPHsgc3Vic2NyaXB0aW9uSWQ6IHN0cmluZzsgc3RhdHVzOiBzdHJpbmc7IGN1cnJlbnRfcGVyaW9kX2VuZD86IG51bWJlcjsgdHJpYWxfZW5kPzogbnVtYmVyIH0+IHtcbiAgY29uc3Qgc3RyaXBlID0gZ2V0U3RyaXBlQ2xpZW50KCk7XG5cbiAgY29uc3Qgc3Vic2NyaXB0aW9uUGFyYW1zOiBTdHJpcGUuU3Vic2NyaXB0aW9uQ3JlYXRlUGFyYW1zID0ge1xuICAgIGN1c3RvbWVyOiBjdXN0b21lcklkLFxuICAgIGl0ZW1zOiBbeyBwcmljZTogcHJpY2VJZCB9XSxcbiAgICBwYXltZW50X3NldHRpbmdzOiB7IHNhdmVfZGVmYXVsdF9wYXltZW50X21ldGhvZDogJ29uX3N1YnNjcmlwdGlvbicgfSxcbiAgICBleHBhbmQ6IFsnbGF0ZXN0X2ludm9pY2UucGF5bWVudF9pbnRlbnQnXSxcbiAgICBtZXRhZGF0YTogbWV0YWRhdGEgfHwge30sXG4gICAgLy8gNy1kYXkgdHJpYWwgcGVyaW9kIGFzIHBlciBhcHAgZGVzaWduXG4gICAgdHJpYWxfcGVyaW9kX2RheXM6IDcsXG4gIH07XG5cbiAgLy8gSWYgcGF5bWVudCBtZXRob2QgaXMgcHJvdmlkZWQsIGF0dGFjaCBpdDsgb3RoZXJ3aXNlIHN1YnNjcmlwdGlvbiB3aWxsIGJlIGluY29tcGxldGVcbiAgaWYgKHBheW1lbnRNZXRob2RJZCkge1xuICAgIHN1YnNjcmlwdGlvblBhcmFtcy5kZWZhdWx0X3BheW1lbnRfbWV0aG9kID0gcGF5bWVudE1ldGhvZElkO1xuICAgIHN1YnNjcmlwdGlvblBhcmFtcy5wYXltZW50X2JlaGF2aW9yID0gJ2RlZmF1bHRfaW5jb21wbGV0ZSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3Vic2NyaXB0aW9uIHdpbGwgYmUgaW5jb21wbGV0ZSB1bnRpbCBwYXltZW50IG1ldGhvZCBpcyBhZGRlZFxuICAgIHN1YnNjcmlwdGlvblBhcmFtcy5wYXltZW50X2JlaGF2aW9yID0gJ2RlZmF1bHRfaW5jb21wbGV0ZSc7XG4gIH1cblxuICBjb25zdCBzdWJzY3JpcHRpb24gPSBhd2FpdCBzdHJpcGUuc3Vic2NyaXB0aW9ucy5jcmVhdGUoc3Vic2NyaXB0aW9uUGFyYW1zKTtcblxuICByZXR1cm4ge1xuICAgIHN1YnNjcmlwdGlvbklkOiBzdWJzY3JpcHRpb24uaWQsXG4gICAgc3RhdHVzOiBzdWJzY3JpcHRpb24uc3RhdHVzLFxuICAgIGN1cnJlbnRfcGVyaW9kX2VuZDogc3Vic2NyaXB0aW9uLmN1cnJlbnRfcGVyaW9kX2VuZCxcbiAgICB0cmlhbF9lbmQ6IHN1YnNjcmlwdGlvbi50cmlhbF9lbmQsXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgUGF5bWVudEludGVudCB3aXRoIENvbm5lY3QgZGVzdGluYXRpb24gY2hhcmdlXG4gKiBUaGlzIGNoYXJnZXMgdGhlIGN1c3RvbWVyIGFuZCBzZW5kcyBmdW5kcyB0byB0aGUgY29ubmVjdGVkIGFjY291bnRcbiAqIFN1cHBvcnRzIG9mZi1zZXNzaW9uIGNoYXJnZXMgZm9yIHNhdmVkIHBheW1lbnQgbWV0aG9kc1xuICogXG4gKiBSZXR1cm5zIHRoZSBQYXltZW50SW50ZW50IHdpdGggc3RhdHVzIGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVQYXltZW50SW50ZW50KHBhcmFtczoge1xuICBhbW91bnQ6IG51bWJlcjsgLy8gaW4gY2VudHNcbiAgY3VzdG9tZXJJZDogc3RyaW5nO1xuICBwYXltZW50TWV0aG9kSWQ6IHN0cmluZztcbiAgY29ubmVjdEFjY291bnRJZDogc3RyaW5nO1xuICBhcHBsaWNhdGlvbkZlZTogbnVtYmVyOyAvLyBwbGF0Zm9ybSBmZWUgaW4gY2VudHMgKDElIG9mIGFtb3VudClcbiAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICBvZmZTZXNzaW9uPzogYm9vbGVhbjsgLy8gSWYgdHJ1ZSwgYXR0ZW1wdHMgb2ZmLXNlc3Npb24gY2hhcmdlIChmb3Igc2F2ZWQgY2FyZHMpXG59KTogUHJvbWlzZTx7IFxuICBwYXltZW50SW50ZW50SWQ6IHN0cmluZzsgXG4gIGNsaWVudFNlY3JldDogc3RyaW5nO1xuICBzdGF0dXM6IHN0cmluZztcbiAgcmVxdWlyZXNBY3Rpb24/OiBib29sZWFuO1xufT4ge1xuICBjb25zdCBzdHJpcGUgPSBnZXRTdHJpcGVDbGllbnQoKTtcbiAgY29uc3QgeyBhbW91bnQsIGN1c3RvbWVySWQsIHBheW1lbnRNZXRob2RJZCwgY29ubmVjdEFjY291bnRJZCwgYXBwbGljYXRpb25GZWUsIG1ldGFkYXRhLCBvZmZTZXNzaW9uID0gZmFsc2UgfSA9IHBhcmFtcztcblxuICAvLyBDcmVhdGUgUGF5bWVudEludGVudCBvbiBwbGF0Zm9ybSBhY2NvdW50IHdpdGggQ29ubmVjdCBkZXN0aW5hdGlvblxuICBjb25zdCBwYXltZW50SW50ZW50UGFyYW1zOiBTdHJpcGUuUGF5bWVudEludGVudENyZWF0ZVBhcmFtcyA9IHtcbiAgICBhbW91bnQsXG4gICAgY3VycmVuY3k6ICd1c2QnLFxuICAgIGN1c3RvbWVyOiBjdXN0b21lcklkLFxuICAgIHBheW1lbnRfbWV0aG9kOiBwYXltZW50TWV0aG9kSWQsXG4gICAgb25fYmVoYWxmX29mOiBjb25uZWN0QWNjb3VudElkLFxuICAgIHRyYW5zZmVyX2RhdGE6IHtcbiAgICAgIGRlc3RpbmF0aW9uOiBjb25uZWN0QWNjb3VudElkLFxuICAgIH0sXG4gICAgYXBwbGljYXRpb25fZmVlX2Ftb3VudDogYXBwbGljYXRpb25GZWUsXG4gICAgbWV0YWRhdGE6IG1ldGFkYXRhIHx8IHt9LFxuICB9O1xuXG4gIC8vIEZvciBvZmYtc2Vzc2lvbiBjaGFyZ2VzLCBzZXQgY29uZmlybWF0aW9uIG1ldGhvZCBhbmQgb2ZmX3Nlc3Npb24gZmxhZ1xuICBpZiAob2ZmU2Vzc2lvbikge1xuICAgIHBheW1lbnRJbnRlbnRQYXJhbXMuY29uZmlybWF0aW9uX21ldGhvZCA9ICdhdXRvbWF0aWMnO1xuICAgIHBheW1lbnRJbnRlbnRQYXJhbXMuY29uZmlybSA9IHRydWU7XG4gICAgcGF5bWVudEludGVudFBhcmFtcy5vZmZfc2Vzc2lvbiA9IHRydWU7XG4gICAgcGF5bWVudEludGVudFBhcmFtcy5wYXltZW50X21ldGhvZF9vcHRpb25zID0ge1xuICAgICAgY2FyZDoge1xuICAgICAgICByZXF1ZXN0X3RocmVlX2Rfc2VjdXJlOiAnYXV0b21hdGljJyxcbiAgICAgIH0sXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBwYXltZW50SW50ZW50UGFyYW1zLmNvbmZpcm1hdGlvbl9tZXRob2QgPSAnbWFudWFsJztcbiAgICBwYXltZW50SW50ZW50UGFyYW1zLmNvbmZpcm0gPSB0cnVlO1xuICB9XG5cbiAgY29uc3QgcGF5bWVudEludGVudCA9IGF3YWl0IHN0cmlwZS5wYXltZW50SW50ZW50cy5jcmVhdGUocGF5bWVudEludGVudFBhcmFtcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXltZW50SW50ZW50SWQ6IHBheW1lbnRJbnRlbnQuaWQsXG4gICAgY2xpZW50U2VjcmV0OiBwYXltZW50SW50ZW50LmNsaWVudF9zZWNyZXQgfHwgJycsXG4gICAgc3RhdHVzOiBwYXltZW50SW50ZW50LnN0YXR1cyxcbiAgICByZXF1aXJlc0FjdGlvbjogcGF5bWVudEludGVudC5zdGF0dXMgPT09ICdyZXF1aXJlc19hY3Rpb24nIHx8IHBheW1lbnRJbnRlbnQuc3RhdHVzID09PSAncmVxdWlyZXNfcGF5bWVudF9tZXRob2QnLFxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJlZnVuZCBmb3IgYSBQYXltZW50SW50ZW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVSZWZ1bmQoXG4gIHBheW1lbnRJbnRlbnRJZDogc3RyaW5nLFxuICBhbW91bnQ/OiBudW1iZXIgLy8gb3B0aW9uYWwgYW1vdW50IHRvIHJlZnVuZCAocGFydGlhbCByZWZ1bmQpLCBpZiBub3QgcHJvdmlkZWQsIGZ1bGwgcmVmdW5kXG4pOiBQcm9taXNlPHsgcmVmdW5kSWQ6IHN0cmluZzsgYW1vdW50OiBudW1iZXIgfT4ge1xuICBjb25zdCBzdHJpcGUgPSBnZXRTdHJpcGVDbGllbnQoKTtcblxuICBjb25zdCByZWZ1bmRQYXJhbXM6IFN0cmlwZS5SZWZ1bmRDcmVhdGVQYXJhbXMgPSB7XG4gICAgcGF5bWVudF9pbnRlbnQ6IHBheW1lbnRJbnRlbnRJZCxcbiAgfTtcblxuICBpZiAoYW1vdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZWZ1bmRQYXJhbXMuYW1vdW50ID0gYW1vdW50O1xuICB9XG5cbiAgY29uc3QgcmVmdW5kID0gYXdhaXQgc3RyaXBlLnJlZnVuZHMuY3JlYXRlKHJlZnVuZFBhcmFtcyk7XG5cbiAgcmV0dXJuIHtcbiAgICByZWZ1bmRJZDogcmVmdW5kLmlkLFxuICAgIGFtb3VudDogcmVmdW5kLmFtb3VudCxcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgcGF5bWVudCBtZXRob2QgZnJvbSBhIFNldHVwSW50ZW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQYXltZW50TWV0aG9kRnJvbVNldHVwSW50ZW50KFxuICBzZXR1cEludGVudElkOiBzdHJpbmdcbik6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICBjb25zdCBzdHJpcGUgPSBnZXRTdHJpcGVDbGllbnQoKTtcblxuICBjb25zdCBzZXR1cEludGVudCA9IGF3YWl0IHN0cmlwZS5zZXR1cEludGVudHMucmV0cmlldmUoc2V0dXBJbnRlbnRJZCk7XG5cbiAgaWYgKHR5cGVvZiBzZXR1cEludGVudC5wYXltZW50X21ldGhvZCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc2V0dXBJbnRlbnQucGF5bWVudF9tZXRob2Q7XG4gIH1cblxuICBpZiAoc2V0dXBJbnRlbnQucGF5bWVudF9tZXRob2QpIHtcbiAgICByZXR1cm4gc2V0dXBJbnRlbnQucGF5bWVudF9tZXRob2QuaWQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBWZXJpZnkgYSBDb25uZWN0IGFjY291bnQgaXMgYWN0aXZlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlDb25uZWN0QWNjb3VudChhY2NvdW50SWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHN0cmlwZSA9IGdldFN0cmlwZUNsaWVudCgpO1xuICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCBzdHJpcGUuYWNjb3VudHMucmV0cmlldmUoYWNjb3VudElkKTtcblxuICAgIHJldHVybiBhY2NvdW50LmRldGFpbHNfc3VibWl0dGVkICYmIGFjY291bnQuY2hhcmdlc19lbmFibGVkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyBDb25uZWN0IGFjY291bnQ6JywgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4iXSwibmFtZXMiOlsiU3RyaXBlIiwic3RyaXBlU2VjcmV0S2V5IiwicHJvY2VzcyIsImVudiIsIlNUUklQRV9TRUNSRVRfS0VZIiwiY29uc29sZSIsIndhcm4iLCJnZXRTdHJpcGVDbGllbnQiLCJFcnJvciIsImFwaVZlcnNpb24iLCJjcmVhdGVDb25uZWN0QWNjb3VudCIsInVzZXJJZCIsImVtYWlsIiwic3RyaXBlIiwiYWNjb3VudCIsImFjY291bnRzIiwiY3JlYXRlIiwidHlwZSIsImNhcGFiaWxpdGllcyIsImNhcmRfcGF5bWVudHMiLCJyZXF1ZXN0ZWQiLCJ0cmFuc2ZlcnMiLCJtZXRhZGF0YSIsInVzZXJfaWQiLCJpZCIsImNyZWF0ZUFjY291bnRMaW5rIiwiYWNjb3VudElkIiwicmV0dXJuVXJsIiwicmVmcmVzaFVybCIsImFjY291bnRMaW5rIiwiYWNjb3VudExpbmtzIiwicmV0dXJuX3VybCIsInJlZnJlc2hfdXJsIiwidXJsIiwiY3JlYXRlT3JHZXRDdXN0b21lciIsIm5hbWUiLCJleGlzdGluZ0N1c3RvbWVycyIsImN1c3RvbWVycyIsImxpc3QiLCJsaW1pdCIsImRhdGEiLCJsZW5ndGgiLCJjdXN0b21lciIsImNyZWF0ZVNldHVwSW50ZW50IiwiY3VzdG9tZXJJZCIsInNldHVwSW50ZW50Iiwic2V0dXBJbnRlbnRzIiwicGF5bWVudF9tZXRob2RfdHlwZXMiLCJzZXR1cEludGVudElkIiwiY2xpZW50U2VjcmV0IiwiY2xpZW50X3NlY3JldCIsImNyZWF0ZVN1YnNjcmlwdGlvbiIsInByaWNlSWQiLCJwYXltZW50TWV0aG9kSWQiLCJzdWJzY3JpcHRpb25QYXJhbXMiLCJpdGVtcyIsInByaWNlIiwicGF5bWVudF9zZXR0aW5ncyIsInNhdmVfZGVmYXVsdF9wYXltZW50X21ldGhvZCIsImV4cGFuZCIsInRyaWFsX3BlcmlvZF9kYXlzIiwiZGVmYXVsdF9wYXltZW50X21ldGhvZCIsInBheW1lbnRfYmVoYXZpb3IiLCJzdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb25zIiwic3Vic2NyaXB0aW9uSWQiLCJzdGF0dXMiLCJjdXJyZW50X3BlcmlvZF9lbmQiLCJ0cmlhbF9lbmQiLCJjcmVhdGVQYXltZW50SW50ZW50IiwicGFyYW1zIiwiYW1vdW50IiwiY29ubmVjdEFjY291bnRJZCIsImFwcGxpY2F0aW9uRmVlIiwib2ZmU2Vzc2lvbiIsInBheW1lbnRJbnRlbnRQYXJhbXMiLCJjdXJyZW5jeSIsInBheW1lbnRfbWV0aG9kIiwib25fYmVoYWxmX29mIiwidHJhbnNmZXJfZGF0YSIsImRlc3RpbmF0aW9uIiwiYXBwbGljYXRpb25fZmVlX2Ftb3VudCIsImNvbmZpcm1hdGlvbl9tZXRob2QiLCJjb25maXJtIiwib2ZmX3Nlc3Npb24iLCJwYXltZW50X21ldGhvZF9vcHRpb25zIiwiY2FyZCIsInJlcXVlc3RfdGhyZWVfZF9zZWN1cmUiLCJwYXltZW50SW50ZW50IiwicGF5bWVudEludGVudHMiLCJwYXltZW50SW50ZW50SWQiLCJyZXF1aXJlc0FjdGlvbiIsImNyZWF0ZVJlZnVuZCIsInJlZnVuZFBhcmFtcyIsInBheW1lbnRfaW50ZW50IiwidW5kZWZpbmVkIiwicmVmdW5kIiwicmVmdW5kcyIsInJlZnVuZElkIiwiZ2V0UGF5bWVudE1ldGhvZEZyb21TZXR1cEludGVudCIsInJldHJpZXZlIiwidmVyaWZ5Q29ubmVjdEFjY291bnQiLCJkZXRhaWxzX3N1Ym1pdHRlZCIsImNoYXJnZXNfZW5hYmxlZCIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/stripe.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/timezone.ts":
/*!*****************************!*\
  !*** ./src/lib/timezone.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatInTimeZone: () => (/* binding */ formatInTimeZone),\n/* harmony export */   timeStringToMinutes: () => (/* binding */ timeStringToMinutes),\n/* harmony export */   zonedMinutesToDate: () => (/* binding */ zonedMinutesToDate)\n/* harmony export */ });\nfunction timeStringToMinutes(time) {\n    const [hours = \"0\", minutes = \"0\"] = time.split(\":\");\n    return parseInt(hours, 10) * 60 + parseInt(minutes, 10);\n}\nfunction zonedMinutesToDate(date, minutes, timeZone) {\n    const baseParts = getDateParts(date, timeZone);\n    const hours = Math.floor(minutes / 60);\n    const mins = minutes % 60;\n    const utcDate = new Date(Date.UTC(baseParts.year, baseParts.month - 1, baseParts.day, hours, mins));\n    const offset = getOffsetMinutes(utcDate, timeZone);\n    return new Date(utcDate.getTime() - offset * 60000);\n}\nfunction formatInTimeZone(isoString, timeZone, options) {\n    // Handle both string and Date inputs\n    let date;\n    if (isoString instanceof Date) {\n        date = isoString;\n    } else if (typeof isoString === \"string\") {\n        // Validate string is not empty\n        if (!isoString || isoString.trim() === \"\") {\n            console.error(`[formatInTimeZone] Empty date string provided`);\n            return \"Invalid Date\";\n        }\n        date = new Date(isoString);\n    } else {\n        console.error(`[formatInTimeZone] Invalid input type:`, typeof isoString, isoString);\n        return \"Invalid Date\";\n    }\n    // Validate the date\n    if (isNaN(date.getTime())) {\n        console.error(`[formatInTimeZone] Invalid date value:`, isoString);\n        return \"Invalid Date\";\n    }\n    // Handle string format option (like \"yyyy-MM-dd\")\n    if (typeof options === \"string\") {\n        // For simple date format strings, use a basic formatter\n        const formatter = new Intl.DateTimeFormat(\"en-US\", {\n            timeZone,\n            year: \"numeric\",\n            month: \"2-digit\",\n            day: \"2-digit\"\n        });\n        const parts = formatter.formatToParts(date);\n        const year = parts.find((p)=>p.type === \"year\")?.value || \"\";\n        const month = parts.find((p)=>p.type === \"month\")?.value || \"\";\n        const day = parts.find((p)=>p.type === \"day\")?.value || \"\";\n        // Replace format string placeholders\n        return options.replace(\"yyyy\", year).replace(\"MM\", month).replace(\"dd\", day);\n    }\n    // Handle Intl.DateTimeFormatOptions\n    const formatter = new Intl.DateTimeFormat(\"en-US\", {\n        timeZone,\n        ...options\n    });\n    return formatter.format(date);\n}\nfunction getDateParts(date, timeZone) {\n    const formatter = new Intl.DateTimeFormat(\"en-US\", {\n        timeZone,\n        year: \"numeric\",\n        month: \"2-digit\",\n        day: \"2-digit\"\n    });\n    const parts = formatter.formatToParts(date);\n    return {\n        year: Number(parts.find((part)=>part.type === \"year\")?.value ?? date.getUTCFullYear()),\n        month: Number(parts.find((part)=>part.type === \"month\")?.value ?? date.getUTCMonth() + 1),\n        day: Number(parts.find((part)=>part.type === \"day\")?.value ?? date.getUTCDate())\n    };\n}\nfunction getOffsetMinutes(date, timeZone) {\n    const formatter = new Intl.DateTimeFormat(\"en-US\", {\n        timeZone,\n        year: \"numeric\",\n        month: \"2-digit\",\n        day: \"2-digit\",\n        hour: \"2-digit\",\n        minute: \"2-digit\",\n        hourCycle: \"h23\"\n    });\n    const parts = formatter.formatToParts(date);\n    const year = Number(parts.find((part)=>part.type === \"year\")?.value ?? date.getUTCFullYear());\n    const month = Number(parts.find((part)=>part.type === \"month\")?.value ?? date.getUTCMonth() + 1);\n    const day = Number(parts.find((part)=>part.type === \"day\")?.value ?? date.getUTCDate());\n    const hour = Number(parts.find((part)=>part.type === \"hour\")?.value ?? date.getUTCHours());\n    const minute = Number(parts.find((part)=>part.type === \"minute\")?.value ?? date.getUTCMinutes());\n    const asUTC = Date.UTC(year, month - 1, day, hour, minute);\n    return (asUTC - date.getTime()) / 60000;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL3RpbWV6b25lLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFPLFNBQVNBLG9CQUFvQkMsSUFBWTtJQUM5QyxNQUFNLENBQUNDLFFBQVEsR0FBRyxFQUFFQyxVQUFVLEdBQUcsQ0FBQyxHQUFHRixLQUFLRyxLQUFLLENBQUM7SUFDaEQsT0FBT0MsU0FBU0gsT0FBTyxNQUFNLEtBQUtHLFNBQVNGLFNBQVM7QUFDdEQ7QUFFTyxTQUFTRyxtQkFBbUJDLElBQVUsRUFBRUosT0FBZSxFQUFFSyxRQUFnQjtJQUM5RSxNQUFNQyxZQUFZQyxhQUFhSCxNQUFNQztJQUNyQyxNQUFNTixRQUFRUyxLQUFLQyxLQUFLLENBQUNULFVBQVU7SUFDbkMsTUFBTVUsT0FBT1YsVUFBVTtJQUN2QixNQUFNVyxVQUFVLElBQUlDLEtBQUtBLEtBQUtDLEdBQUcsQ0FBQ1AsVUFBVVEsSUFBSSxFQUFFUixVQUFVUyxLQUFLLEdBQUcsR0FBR1QsVUFBVVUsR0FBRyxFQUFFakIsT0FBT1c7SUFDN0YsTUFBTU8sU0FBU0MsaUJBQWlCUCxTQUFTTjtJQUN6QyxPQUFPLElBQUlPLEtBQUtELFFBQVFRLE9BQU8sS0FBS0YsU0FBUztBQUMvQztBQUVPLFNBQVNHLGlCQUNkQyxTQUF3QixFQUN4QmhCLFFBQWdCLEVBQ2hCaUIsT0FBNEM7SUFFNUMscUNBQXFDO0lBQ3JDLElBQUlsQjtJQUNKLElBQUlpQixxQkFBcUJULE1BQU07UUFDN0JSLE9BQU9pQjtJQUNULE9BQU8sSUFBSSxPQUFPQSxjQUFjLFVBQVU7UUFDeEMsK0JBQStCO1FBQy9CLElBQUksQ0FBQ0EsYUFBYUEsVUFBVUUsSUFBSSxPQUFPLElBQUk7WUFDekNDLFFBQVFDLEtBQUssQ0FBQyxDQUFDLDZDQUE2QyxDQUFDO1lBQzdELE9BQU87UUFDVDtRQUNBckIsT0FBTyxJQUFJUSxLQUFLUztJQUNsQixPQUFPO1FBQ0xHLFFBQVFDLEtBQUssQ0FBQyxDQUFDLHNDQUFzQyxDQUFDLEVBQUUsT0FBT0osV0FBV0E7UUFDMUUsT0FBTztJQUNUO0lBRUEsb0JBQW9CO0lBQ3BCLElBQUlLLE1BQU10QixLQUFLZSxPQUFPLEtBQUs7UUFDekJLLFFBQVFDLEtBQUssQ0FBQyxDQUFDLHNDQUFzQyxDQUFDLEVBQUVKO1FBQ3hELE9BQU87SUFDVDtJQUVBLGtEQUFrRDtJQUNsRCxJQUFJLE9BQU9DLFlBQVksVUFBVTtRQUMvQix3REFBd0Q7UUFDeEQsTUFBTUssWUFBWSxJQUFJQyxLQUFLQyxjQUFjLENBQUMsU0FBUztZQUNqRHhCO1lBQ0FTLE1BQU07WUFDTkMsT0FBTztZQUNQQyxLQUFLO1FBQ1A7UUFDQSxNQUFNYyxRQUFRSCxVQUFVSSxhQUFhLENBQUMzQjtRQUN0QyxNQUFNVSxPQUFPZ0IsTUFBTUUsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxJQUFJLEtBQUssU0FBU0MsU0FBUztRQUMxRCxNQUFNcEIsUUFBUWUsTUFBTUUsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxJQUFJLEtBQUssVUFBVUMsU0FBUztRQUM1RCxNQUFNbkIsTUFBTWMsTUFBTUUsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxJQUFJLEtBQUssUUFBUUMsU0FBUztRQUV4RCxxQ0FBcUM7UUFDckMsT0FBT2IsUUFDSmMsT0FBTyxDQUFDLFFBQVF0QixNQUNoQnNCLE9BQU8sQ0FBQyxNQUFNckIsT0FDZHFCLE9BQU8sQ0FBQyxNQUFNcEI7SUFDbkI7SUFFQSxvQ0FBb0M7SUFDcEMsTUFBTVcsWUFBWSxJQUFJQyxLQUFLQyxjQUFjLENBQUMsU0FBUztRQUFFeEI7UUFBVSxHQUFHaUIsT0FBTztJQUFDO0lBQzFFLE9BQU9LLFVBQVVVLE1BQU0sQ0FBQ2pDO0FBQzFCO0FBRUEsU0FBU0csYUFBYUgsSUFBVSxFQUFFQyxRQUFnQjtJQUNoRCxNQUFNc0IsWUFBWSxJQUFJQyxLQUFLQyxjQUFjLENBQUMsU0FBUztRQUNqRHhCO1FBQ0FTLE1BQU07UUFDTkMsT0FBTztRQUNQQyxLQUFLO0lBQ1A7SUFDQSxNQUFNYyxRQUFRSCxVQUFVSSxhQUFhLENBQUMzQjtJQUN0QyxPQUFPO1FBQ0xVLE1BQU13QixPQUFPUixNQUFNRSxJQUFJLENBQUMsQ0FBQ08sT0FBU0EsS0FBS0wsSUFBSSxLQUFLLFNBQVNDLFNBQVMvQixLQUFLb0MsY0FBYztRQUNyRnpCLE9BQU91QixPQUFPUixNQUFNRSxJQUFJLENBQUMsQ0FBQ08sT0FBU0EsS0FBS0wsSUFBSSxLQUFLLFVBQVVDLFNBQVMvQixLQUFLcUMsV0FBVyxLQUFLO1FBQ3pGekIsS0FBS3NCLE9BQU9SLE1BQU1FLElBQUksQ0FBQyxDQUFDTyxPQUFTQSxLQUFLTCxJQUFJLEtBQUssUUFBUUMsU0FBUy9CLEtBQUtzQyxVQUFVO0lBQ2pGO0FBQ0Y7QUFFQSxTQUFTeEIsaUJBQWlCZCxJQUFVLEVBQUVDLFFBQWdCO0lBQ3BELE1BQU1zQixZQUFZLElBQUlDLEtBQUtDLGNBQWMsQ0FBQyxTQUFTO1FBQ2pEeEI7UUFDQVMsTUFBTTtRQUNOQyxPQUFPO1FBQ1BDLEtBQUs7UUFDTDJCLE1BQU07UUFDTkMsUUFBUTtRQUNSQyxXQUFXO0lBQ2I7SUFDQSxNQUFNZixRQUFRSCxVQUFVSSxhQUFhLENBQUMzQjtJQUN0QyxNQUFNVSxPQUFPd0IsT0FBT1IsTUFBTUUsSUFBSSxDQUFDLENBQUNPLE9BQVNBLEtBQUtMLElBQUksS0FBSyxTQUFTQyxTQUFTL0IsS0FBS29DLGNBQWM7SUFDNUYsTUFBTXpCLFFBQVF1QixPQUFPUixNQUFNRSxJQUFJLENBQUMsQ0FBQ08sT0FBU0EsS0FBS0wsSUFBSSxLQUFLLFVBQVVDLFNBQVMvQixLQUFLcUMsV0FBVyxLQUFLO0lBQ2hHLE1BQU16QixNQUFNc0IsT0FBT1IsTUFBTUUsSUFBSSxDQUFDLENBQUNPLE9BQVNBLEtBQUtMLElBQUksS0FBSyxRQUFRQyxTQUFTL0IsS0FBS3NDLFVBQVU7SUFDdEYsTUFBTUMsT0FBT0wsT0FBT1IsTUFBTUUsSUFBSSxDQUFDLENBQUNPLE9BQVNBLEtBQUtMLElBQUksS0FBSyxTQUFTQyxTQUFTL0IsS0FBSzBDLFdBQVc7SUFDekYsTUFBTUYsU0FBU04sT0FBT1IsTUFBTUUsSUFBSSxDQUFDLENBQUNPLE9BQVNBLEtBQUtMLElBQUksS0FBSyxXQUFXQyxTQUFTL0IsS0FBSzJDLGFBQWE7SUFDL0YsTUFBTUMsUUFBUXBDLEtBQUtDLEdBQUcsQ0FBQ0MsTUFBTUMsUUFBUSxHQUFHQyxLQUFLMkIsTUFBTUM7SUFDbkQsT0FBTyxDQUFDSSxRQUFRNUMsS0FBS2UsT0FBTyxFQUFDLElBQUs7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9zcmMvbGliL3RpbWV6b25lLnRzP2ZkYjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIHRpbWVTdHJpbmdUb01pbnV0ZXModGltZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgW2hvdXJzID0gXCIwXCIsIG1pbnV0ZXMgPSBcIjBcIl0gPSB0aW1lLnNwbGl0KFwiOlwiKTtcbiAgcmV0dXJuIHBhcnNlSW50KGhvdXJzLCAxMCkgKiA2MCArIHBhcnNlSW50KG1pbnV0ZXMsIDEwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHpvbmVkTWludXRlc1RvRGF0ZShkYXRlOiBEYXRlLCBtaW51dGVzOiBudW1iZXIsIHRpbWVab25lOiBzdHJpbmcpOiBEYXRlIHtcbiAgY29uc3QgYmFzZVBhcnRzID0gZ2V0RGF0ZVBhcnRzKGRhdGUsIHRpbWVab25lKTtcbiAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKG1pbnV0ZXMgLyA2MCk7XG4gIGNvbnN0IG1pbnMgPSBtaW51dGVzICUgNjA7XG4gIGNvbnN0IHV0Y0RhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyhiYXNlUGFydHMueWVhciwgYmFzZVBhcnRzLm1vbnRoIC0gMSwgYmFzZVBhcnRzLmRheSwgaG91cnMsIG1pbnMpKTtcbiAgY29uc3Qgb2Zmc2V0ID0gZ2V0T2Zmc2V0TWludXRlcyh1dGNEYXRlLCB0aW1lWm9uZSk7XG4gIHJldHVybiBuZXcgRGF0ZSh1dGNEYXRlLmdldFRpbWUoKSAtIG9mZnNldCAqIDYwXzAwMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRJblRpbWVab25lKFxuICBpc29TdHJpbmc6IHN0cmluZyB8IERhdGUsXG4gIHRpbWVab25lOiBzdHJpbmcsXG4gIG9wdGlvbnM6IEludGwuRGF0ZVRpbWVGb3JtYXRPcHRpb25zIHwgc3RyaW5nXG4pOiBzdHJpbmcge1xuICAvLyBIYW5kbGUgYm90aCBzdHJpbmcgYW5kIERhdGUgaW5wdXRzXG4gIGxldCBkYXRlOiBEYXRlO1xuICBpZiAoaXNvU3RyaW5nIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIGRhdGUgPSBpc29TdHJpbmc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGlzb1N0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBWYWxpZGF0ZSBzdHJpbmcgaXMgbm90IGVtcHR5XG4gICAgaWYgKCFpc29TdHJpbmcgfHwgaXNvU3RyaW5nLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFtmb3JtYXRJblRpbWVab25lXSBFbXB0eSBkYXRlIHN0cmluZyBwcm92aWRlZGApO1xuICAgICAgcmV0dXJuICdJbnZhbGlkIERhdGUnO1xuICAgIH1cbiAgICBkYXRlID0gbmV3IERhdGUoaXNvU3RyaW5nKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKGBbZm9ybWF0SW5UaW1lWm9uZV0gSW52YWxpZCBpbnB1dCB0eXBlOmAsIHR5cGVvZiBpc29TdHJpbmcsIGlzb1N0cmluZyk7XG4gICAgcmV0dXJuICdJbnZhbGlkIERhdGUnO1xuICB9XG4gIFxuICAvLyBWYWxpZGF0ZSB0aGUgZGF0ZVxuICBpZiAoaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgY29uc29sZS5lcnJvcihgW2Zvcm1hdEluVGltZVpvbmVdIEludmFsaWQgZGF0ZSB2YWx1ZTpgLCBpc29TdHJpbmcpO1xuICAgIHJldHVybiAnSW52YWxpZCBEYXRlJztcbiAgfVxuICBcbiAgLy8gSGFuZGxlIHN0cmluZyBmb3JtYXQgb3B0aW9uIChsaWtlIFwieXl5eS1NTS1kZFwiKVxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gRm9yIHNpbXBsZSBkYXRlIGZvcm1hdCBzdHJpbmdzLCB1c2UgYSBiYXNpYyBmb3JtYXR0ZXJcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHsgXG4gICAgICB0aW1lWm9uZSxcbiAgICAgIHllYXI6ICdudW1lcmljJyxcbiAgICAgIG1vbnRoOiAnMi1kaWdpdCcsXG4gICAgICBkYXk6ICcyLWRpZ2l0J1xuICAgIH0pO1xuICAgIGNvbnN0IHBhcnRzID0gZm9ybWF0dGVyLmZvcm1hdFRvUGFydHMoZGF0ZSk7XG4gICAgY29uc3QgeWVhciA9IHBhcnRzLmZpbmQocCA9PiBwLnR5cGUgPT09ICd5ZWFyJyk/LnZhbHVlIHx8ICcnO1xuICAgIGNvbnN0IG1vbnRoID0gcGFydHMuZmluZChwID0+IHAudHlwZSA9PT0gJ21vbnRoJyk/LnZhbHVlIHx8ICcnO1xuICAgIGNvbnN0IGRheSA9IHBhcnRzLmZpbmQocCA9PiBwLnR5cGUgPT09ICdkYXknKT8udmFsdWUgfHwgJyc7XG4gICAgXG4gICAgLy8gUmVwbGFjZSBmb3JtYXQgc3RyaW5nIHBsYWNlaG9sZGVyc1xuICAgIHJldHVybiBvcHRpb25zXG4gICAgICAucmVwbGFjZSgneXl5eScsIHllYXIpXG4gICAgICAucmVwbGFjZSgnTU0nLCBtb250aClcbiAgICAgIC5yZXBsYWNlKCdkZCcsIGRheSk7XG4gIH1cbiAgXG4gIC8vIEhhbmRsZSBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9uc1xuICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHsgdGltZVpvbmUsIC4uLm9wdGlvbnMgfSk7XG4gIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KGRhdGUpO1xufVxuXG5mdW5jdGlvbiBnZXREYXRlUGFydHMoZGF0ZTogRGF0ZSwgdGltZVpvbmU6IHN0cmluZykge1xuICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHtcbiAgICB0aW1lWm9uZSxcbiAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICBtb250aDogXCIyLWRpZ2l0XCIsXG4gICAgZGF5OiBcIjItZGlnaXRcIlxuICB9KTtcbiAgY29uc3QgcGFydHMgPSBmb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhkYXRlKTtcbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiBOdW1iZXIocGFydHMuZmluZCgocGFydCkgPT4gcGFydC50eXBlID09PSBcInllYXJcIik/LnZhbHVlID8/IGRhdGUuZ2V0VVRDRnVsbFllYXIoKSksXG4gICAgbW9udGg6IE51bWJlcihwYXJ0cy5maW5kKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwibW9udGhcIik/LnZhbHVlID8/IGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLFxuICAgIGRheTogTnVtYmVyKHBhcnRzLmZpbmQoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJkYXlcIik/LnZhbHVlID8/IGRhdGUuZ2V0VVRDRGF0ZSgpKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXRNaW51dGVzKGRhdGU6IERhdGUsIHRpbWVab25lOiBzdHJpbmcpOiBudW1iZXIge1xuICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHtcbiAgICB0aW1lWm9uZSxcbiAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICBtb250aDogXCIyLWRpZ2l0XCIsXG4gICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICBob3VyOiBcIjItZGlnaXRcIixcbiAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgIGhvdXJDeWNsZTogXCJoMjNcIlxuICB9KTtcbiAgY29uc3QgcGFydHMgPSBmb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhkYXRlKTtcbiAgY29uc3QgeWVhciA9IE51bWJlcihwYXJ0cy5maW5kKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwieWVhclwiKT8udmFsdWUgPz8gZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgY29uc3QgbW9udGggPSBOdW1iZXIocGFydHMuZmluZCgocGFydCkgPT4gcGFydC50eXBlID09PSBcIm1vbnRoXCIpPy52YWx1ZSA/PyBkYXRlLmdldFVUQ01vbnRoKCkgKyAxKTtcbiAgY29uc3QgZGF5ID0gTnVtYmVyKHBhcnRzLmZpbmQoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJkYXlcIik/LnZhbHVlID8/IGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgY29uc3QgaG91ciA9IE51bWJlcihwYXJ0cy5maW5kKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwiaG91clwiKT8udmFsdWUgPz8gZGF0ZS5nZXRVVENIb3VycygpKTtcbiAgY29uc3QgbWludXRlID0gTnVtYmVyKHBhcnRzLmZpbmQoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJtaW51dGVcIik/LnZhbHVlID8/IGRhdGUuZ2V0VVRDTWludXRlcygpKTtcbiAgY29uc3QgYXNVVEMgPSBEYXRlLlVUQyh5ZWFyLCBtb250aCAtIDEsIGRheSwgaG91ciwgbWludXRlKTtcbiAgcmV0dXJuIChhc1VUQyAtIGRhdGUuZ2V0VGltZSgpKSAvIDYwXzAwMDtcbn1cblxuXG4iXSwibmFtZXMiOlsidGltZVN0cmluZ1RvTWludXRlcyIsInRpbWUiLCJob3VycyIsIm1pbnV0ZXMiLCJzcGxpdCIsInBhcnNlSW50Iiwiem9uZWRNaW51dGVzVG9EYXRlIiwiZGF0ZSIsInRpbWVab25lIiwiYmFzZVBhcnRzIiwiZ2V0RGF0ZVBhcnRzIiwiTWF0aCIsImZsb29yIiwibWlucyIsInV0Y0RhdGUiLCJEYXRlIiwiVVRDIiwieWVhciIsIm1vbnRoIiwiZGF5Iiwib2Zmc2V0IiwiZ2V0T2Zmc2V0TWludXRlcyIsImdldFRpbWUiLCJmb3JtYXRJblRpbWVab25lIiwiaXNvU3RyaW5nIiwib3B0aW9ucyIsInRyaW0iLCJjb25zb2xlIiwiZXJyb3IiLCJpc05hTiIsImZvcm1hdHRlciIsIkludGwiLCJEYXRlVGltZUZvcm1hdCIsInBhcnRzIiwiZm9ybWF0VG9QYXJ0cyIsImZpbmQiLCJwIiwidHlwZSIsInZhbHVlIiwicmVwbGFjZSIsImZvcm1hdCIsIk51bWJlciIsInBhcnQiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImhvdXIiLCJtaW51dGUiLCJob3VyQ3ljbGUiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJhc1VUQyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/timezone.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@supabase","vendor-chunks/tslib","vendor-chunks/stripe","vendor-chunks/math-intrinsics","vendor-chunks/es-errors","vendor-chunks/qs","vendor-chunks/call-bind-apply-helpers","vendor-chunks/get-proto","vendor-chunks/object-inspect","vendor-chunks/has-symbols","vendor-chunks/gopd","vendor-chunks/function-bind","vendor-chunks/side-channel","vendor-chunks/side-channel-weakmap","vendor-chunks/side-channel-map","vendor-chunks/side-channel-list","vendor-chunks/hasown","vendor-chunks/get-intrinsic","vendor-chunks/es-object-atoms","vendor-chunks/es-define-property","vendor-chunks/dunder-proto","vendor-chunks/call-bound"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute&page=%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute.ts&appDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();