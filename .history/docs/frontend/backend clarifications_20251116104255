Auth and tenancy

Ground rules (your clarified model)

One user = one business.

Only one login per business (the â€œownerâ€ account).

No staff authentication; in real life, a receptionist would just use the ownerâ€™s credentials.

No dashboard/tenant picker â€“ after login, the owner goes straight to their admin view.

Customers never sign in. They just fill name / phone / email when booking; that data is stored on the booking and visible in the ownerâ€™s â€œpast bookingsâ€ view.

With that in mind, hereâ€™s the updated breakdown of what Iâ€™d do for auth & tenancy.

1. Auth style: Sessions vs JWTs
What the app actually needs

A simple, secure way for the owner to log in.

Authenticated API calls from the frontend to:

fetch bookings,

manage services/availability,

see past bookings, etc.

Public booking flow that does not require login (just form submissions).

Options

Option A â€“ Traditional server sessions

Browser stores a session cookie.

Backend keeps a session row (user_id, expiry, etc.).

Pros:

Very easy mental model.

Easy to kill all sessions.

Cons:

More awkward if you ever want:

mobile apps,

fully decoupled API,

serverless / edge compute.

Not aligned with Supabaseâ€™s â€œJWT + RLSâ€ sweet spot.

Option B â€“ JWT-based auth (Supabase style)

On login, Supabase issues:

a short-lived access token (JWT),

a refresh token.

Frontend attaches access token to requests.

DB uses JWT + RLS to only return the current userâ€™s data.

Pros:

Built-in with Supabase.

Works great for SPAs and APIs.

Plays perfectly with Postgres RLS for isolation.

Cons:

Token/refresh flow is conceptually more complex than just â€œsession cookie.â€

What Iâ€™d choose for Tithi

ğŸ‘‰ JWT-based auth using Supabase Auth.

Why:

Youâ€™re already committing to Supabase and Postgres.

You still want a clean API surface & good security story.

Even though you only have one owner per business, you still have many businesses/users, so per-user isolation matters.

We can keep the mental model simple:

owner logs in â†’ frontend gets Supabase session â†’ calls APIs as that user.

2. Refresh strategy
Options

Option A â€“ Long-lived single token, no refresh

Access token lives for days/weeks.

Easier, but if it leaks, attacker has a lot of time.

Option B â€“ Short-lived access token + long-lived refresh token

Access token: 5â€“15 minutes.

Refresh token: 30â€“90 days.

Frontend silently refreshes in the background.

If you revoke the refresh token, attacker canâ€™t keep renewing.

What Iâ€™d choose for Tithi

ğŸ‘‰ Short-lived access tokens + longer-lived refresh tokens (Supabase default).

Why:

You get good security with almost no extra work, because Supabase already handles this pattern.

The ownerâ€™s experience is still smooth:

They stay logged in for a long time (thanks to refresh token).

If something looks wrong, we can invalidate refresh tokens (e.g., on password reset).

3. MFA (Multi-Factor Authentication)
Why MFA slows v1

Even a basic MFA setup comes with a lot of extra surface area:

Extra flows:

Enable MFA.

Verify a 6-digit code on login.

Disable MFA.

Reset/recover if user loses their device.

Data to manage:

TOTP secrets or phone numbers.

Backup codes for recovery.

Logs of failed attempts.

Edge cases:

What happens after too many failed codes?

What if user changes their phone number?

How does support help them recover?

Thatâ€™s all on top of normal login/password flows you already have to get right.

What Iâ€™d choose for Tithi

ğŸ‘‰ Skip MFA for v1.

Tithi v1 is small-surface: one owner per business, no staff accounts, no client logins.

You can get very decent security from:

strong passwords,

short-lived access tokens,

secure Stripe integration (Stripe stores card data, not you).

In a later phase, when you want â€œserious security hardening,â€ we can:

add an mfa_methods table,

implement TOTP/email OTP,

expose it in the admin UI.

For now, it is more important to ship a working product than to build full enterprise-style auth.

4. Tenant isolation: how to separate businesses

Your reality:

Each user owns exactly one business.

No user ever needs to switch businesses.

But there are many users, each with their own data.

So â€œmulti-tenantâ€ for you basically means â€œeach user must only ever see their own rows.â€

Options

Option A â€“ App-level filtering

Every query manually filters by user_id:

SELECT * FROM bookings WHERE user_id = current_user_id.

Pros:

Simple to understand.

Cons:

If you forget WHERE user_id = ... even once, you can leak data.

As features grow, this risk increases.

Option B â€“ Postgres RLS (Row-Level Security)

Every table that belongs to an owner has user_id.

You define policies like:

USING (user_id = auth.uid())

Postgres itself refuses to return rows for other users, even if you write a bad query.

Pros:

Very strong safety net.

Designed to work with Supabase (this is their main pattern).

Cons:

Initial policy setup is an extra step.

What Iâ€™d choose for Tithi

ğŸ‘‰ Use Postgres RLS with user_id as the isolation key.

Concrete shape:

users table (Supabase auth users).

businesses table with a user_id column (1â€“1).

services, availability_rules, bookings, etc. all have user_id.

RLS policy: user_id = auth.uid() on each of these tables.

This keeps your model extremely simple:

No tenant picker.

No â€œactive tenantâ€ concept.

Just â€œrows belong to user X, and Postgres will only show user X their own rows.â€

5. Enforcing tenant context in code

Given the above, the â€œtenant contextâ€ is basically just:

â€œWhich user is making this request?â€

Since one user = one business, we do not need any extra tension around tenant IDs.

How it works

The frontend uses Supabase Auth â†’ requests include a JWT with sub = user_id.

RLS policies use auth.uid() to get that user_id.

Each table that stores private admin data includes user_id.

Examples:

businesses: one row per user.

bookings: each booking has user_id referencing the owner.

Everything you do in code is now:

â€œJust query the table; RLS ensures the rows belong to the logged-in user.â€

No need for:

explicit tenant headers,

active tenant switching,

complicated scoping logic.

6. Roles & staff accounts

Your clarified stance:

No staff logins, full stop.

If a receptionist needs access, theyâ€™ll just use the ownerâ€™s credentials.

Staff exist only for defining availability / performing services, not as authenticated users.

Options

Option A â€“ Overengineering roles

Create roles, user_tenant_roles, etc. now.

Model owners and staff as separate users in auth, etc.

Pros:

Very flexible later for permissioning.

Cons:

Completely unnecessary for your current, real-world usage model.

Adds conceptual complexity without immediate payoff.

Option B â€“ Single owner + â€œstaff as data onlyâ€

users table: only owner accounts.

businesses table: one per user.

staff table: contains staff members for that business:

name, color, calendar, etc.

linked via user_id or business_id.

Staff never authenticate; they are just entities for availability and bookings.

What Iâ€™d choose for Tithi

ğŸ‘‰ Option B â€“ owner-only auth; staff are just rows, not users.

Why:

Matches exactly how you expect real users to behave.

Avoids a bunch of role/permission complexity.

Still lets you:

assign bookings to a specific staff member,

define availability by staff,

show â€œStaff Aâ€™s calendarâ€ in the admin view.

So the only â€œroleâ€ we really care about is implicit: authenticated user = owner.

7. Session & device management

Your model:

One owner per business.

A receptionist might share the same login.

We donâ€™t need enterprise â€œsession dashboardsâ€ on day one.

Options

Option A â€“ Minimal v1

Use Supabase Auth sessions as-is.

Provide:

login,

logout,

password reset.

No visible UI for â€œactive devices.â€

Option B â€“ Fully-fledged device/session management

Table of active refresh tokens/sessions.

UI listing devices, IP, last seen.

â€œLog out of all other devicesâ€ button.

What Iâ€™d choose for Tithi

ğŸ‘‰ Minimal v1, but store enough data for future improvements.

Let Supabase handle session + refresh token storage internally.

You donâ€™t need a â€œdevicesâ€ screen now.

If you later want to:

tighten security,

show sessions,

or support â€œlog out everywhere,â€
you can layer that on when it becomes a real need.

Final shape for auth & tenancy in Tithi v1

Putting it all together, hereâ€™s the clean, updated plan that matches your clarified app:

Auth style

Use Supabase Auth with JWTs.

One users row per owner.

Login â†’ directly to admin view.

Refresh strategy

Short-lived access tokens + long-lived refresh tokens (Supabase default).

Owner enjoys â€œstay logged inâ€ behavior without giving up too much security.

MFA

Not in v1.

Can be added later as a dedicated â€œsecurity upgradeâ€ phase.

Tenant isolation

Each important table (businesses, services, availability, bookings, etc.) gets a user_id column.

Use Postgres RLS so auth.uid() can only see its own rows.

Tenant context in code

No tenant picker; no multiple businesses per user.

Backend just trusts auth.uid() and RLS guarantees isolation.

Roles & staff

Only owners authenticate.

staff exist only as data tied to the ownerâ€™s business, for availability and bookings.

No extra role tables required.

Sessions/devices

Use Supabaseâ€™s session + refresh system.

Provide basic login/logout/password reset in UI; skip session device listing for v1.

If you want, next we can turn this into:

a short â€œAuth & Tenancy Specâ€ doc you can paste into your repo (like docs/backend/auth_and_tenancy.md), written in super clear non-coder language so you + Cursor + any engineer are all aligned.


------------

Database Modeling
One owner = one account = one business

Only the owner can log into admin (no staff logins)

No dashboard; login â†’ straight to admin view

Customers never sign in; they just give name / phone / email at checkout

Card is saved at booking, but no money moves until the owner clicks Completed / No-Show / Cancelled / Refund on the Past Bookings page

frontend logistics

Iâ€™ll give you:

The core entities + how they relate

Recommended enums

Table-by-table schema (with relationships, indexes, soft delete / versioning)

How RLS ties it all together

1. Core entities & relationships

With your updated reality, Iâ€™d simplify tenancy like this:

auth.users (Supabase) â€” the owner login.

businesses â€” exactly one row per user.

service_categories â€” group services for the catalog.

services â€” what customers actually book.

staff â€” purely â€œdata staff,â€ used for availability & assignment; no auth.

availability_rules â€” â€œstaff X can do service Y at these times.â€

customers â€” name/email/phone + Stripe customer link.

bookings â€” the appointment itself (service + staff + time + customer).

booking_payments â€” how/when money moved for that booking.

policies â€” the editable policies for that business (no-show, cancel, refund, cash).

policy_snapshots (embedded on booking) â€” freeze what the customer agreed to.

gift_cards + gift_card_ledger â€” balances & movements.

notification_templates â€” what the owner configures in onboarding/admin.

notification_events â€” log of actual sends.

Key idea: every tenant-owned table has user_id (auth.uid) and business_id, but RLS uses user_id as the isolation key. Business is just the â€œbucketâ€ under that owner.

2. Recommended enums

You can use Postgres enums or text + CHECK constraints. Iâ€™d do enums for clarity:

CREATE TYPE booking_status AS ENUM (
  'pending',      -- created, card saved, no money moved yet
  'scheduled',    -- same as pending but used if you want semantic diff
  'completed',
  'no_show',
  'cancelled',
  'refunded'
);

CREATE TYPE payment_status AS ENUM (
  'none',             -- no card saved / no payment expected
  'card_saved',       -- SetupIntent succeeded, card on file
  'charge_pending',   -- we are trying to charge
  'charged',          -- money captured
  'refunded',
  'failed'
);

CREATE TYPE money_action AS ENUM (
  'none',
  'completed_charge',   -- Completed button
  'no_show_fee',
  'cancel_fee',
  'refund'
);

CREATE TYPE notification_channel AS ENUM ('email', 'sms');
CREATE TYPE notification_category AS ENUM (
  'confirmation',
  'reminder',
  'follow_up',
  'cancellation',
  'reschedule',
  'completion'
);

CREATE TYPE notification_trigger AS ENUM (
  'booking_created',
  'booking_confirmed',
  'reminder_24h',
  'reminder_1h',
  'booking_cancelled',
  'booking_rescheduled',
  'booking_completed',
  'fee_charged',
  'refunded'
);

CREATE TYPE discount_type AS ENUM ('amount', 'percent');

3. Table-by-table schema

Iâ€™ll describe each table with key columns, relationships, indexes, and soft-delete/versioning notes.

3.1 businesses

Purpose: bucket for everything under one owner.

Columns (core)

id uuid pk

user_id uuid not null â€” references auth.users(id)

name text not null

dba_name text â€” DBA

legal_name text

industry text

subdomain text unique not null â€” used for {subdomain}.tithi.com

timezone text not null

phone text

support_email text

website_url text

street text, city text, state text, postal_code text, country text

brand_primary_color text

brand_secondary_color text

logo_url text

stripe_connect_account_id text

stripe_subscription_id text â€” for the $11.99/mo plan

subscription_status text â€” 'trial' | 'active' | 'paused' | 'canceled'

trial_ends_at timestamptz

created_at, updated_at timestamptz

deleted_at timestamptz (nullable; soft delete flag)

Constraints / indices

UNIQUE (user_id) â€” enforce one business per owner.

UNIQUE (subdomain) â€” one booking site per subdomain.

Index on (user_id) for RLS speed.

Soft delete / versioning

Business is soft-deleted by setting deleted_at.

RLS policy should also check deleted_at IS NULL.

3.2 service_categories

Purpose: groups of services (haircuts vs color, etc.).

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

name text not null

description text

color text

sort_order int â€” for UI ordering

is_active boolean default true

created_at, updated_at, deleted_at

Relationships

business_id â†’ businesses(id)

user_id must match business.user_id (you can enforce via trigger or rely on app).

Indexes

(user_id, business_id)

(user_id, sort_order) for admin listing.

Soft delete

Use deleted_at + is_active; RLS filters deleted_at IS NULL for normal queries.

3.3 services

Purpose: the actual bookable things.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

category_id uuid not null

name text not null

description text

duration_min int not null

price_cents int not null

pre_appointment_instructions text

is_active boolean default true

created_at, updated_at, deleted_at

Relationships

category_id â†’ service_categories(id)

business_id / user_id â†’ businesses(id) and auth.users(id).

Indexes

(user_id, business_id, category_id)

(user_id, is_active) for catalog queries.

3.4 staff

Purpose: staff as data only (names, roles, colors). No login.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

name text not null

role text â€” e.g. â€œstylistâ€, â€œtherapistâ€

color text â€” for calendar lane color

notes text

is_active boolean default true

created_at, updated_at, deleted_at

Indexes

(user_id, business_id, is_active)

3.5 staff_services

Purpose: which staff can perform which services.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

staff_id uuid not null

service_id uuid not null

created_at

Constraints

UNIQUE (staff_id, service_id) â€” no duplicates.

Foreign keys â†’ staff(id), services(id).

Indexes

(user_id, staff_id)

(user_id, service_id)

3.6 availability_rules

Iâ€™d follow your onboarding flow: availability is per service per staff, not generic shifts.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

staff_id uuid not null

service_id uuid not null

rule_type text not null â€” 'weekly' | 'exception' | 'closure'

weekday smallint â€” 0â€“6, for weekly rules

start_time time not null â€” time in business timezone

end_time time not null

date date â€” for exceptions/closures

capacity int default 1 â€” if you ever support multiple at once

created_at, updated_at, deleted_at

Usage

Slot engine: for a given service_id and date, load rules for that service & staff, then generate slots.

Indexes

(user_id, service_id, staff_id, weekday)

(user_id, staff_id, date) for exceptions.

3.7 customers

Purpose: people booking appointments; no login.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

name text not null

email text not null

phone text

stripe_customer_id text â€” link to Stripe

created_at, updated_at

Indexes

(user_id, email)

(user_id, phone)

(user_id, name) (for simple LIKE search in admin).

3.8 bookings

Purpose: the core appointment record.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

customer_id uuid not null

service_id uuid not null

staff_id uuid not null

status booking_status not null default 'pending'

start_at timestamptz not null â€” UTC

end_at timestamptz not null

duration_min int not null

price_cents int not null â€” base price at time of booking

final_price_cents int not null â€” after gift cards / discounts

gift_card_id uuid (nullable)

gift_card_amount_applied_cents int default 0

notes text â€” internal notes

source text not null default 'public' â€” 'public' | 'admin'

policy_snapshot jsonb not null â€” text & fee numbers as seen on checkout

consent_at timestamptz â€” when they checked â€œI agreeâ€

consent_ip text

consent_user_agent text

payment_status payment_status not null default 'card_saved'

last_money_action money_action not null default 'none'

created_at, updated_at, deleted_at

Relationships

FK to customers, services, staff, businesses.

Indexes

(user_id, business_id, start_at DESC) â€” main â€œcalendar / past bookingsâ€ queries.

(user_id, status, start_at DESC) â€” filter by status quickly.

(user_id, customer_id, start_at DESC) â€” customer history.

Why embed policy_snapshot?

Each booking keeps the exact policy text & fee values that the customer agreed to, so you never have â€œpolicy changed laterâ€ disputes.

3.9 booking_payments

Purpose: track how money moves for each booking and wire it to Stripe.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

booking_id uuid not null

stripe_setup_intent_id text â€” card saved at checkout

stripe_payment_intent_id text â€” for a specific charge (completed/no-show/cancel)

last_payment_intent_id text â€” if you want to track latest

amount_cents int not null â€” amount of this transaction

money_action money_action not null â€” why this was created

status payment_status not null

application_fee_cents int â€” your 1% platform fee

stripe_fee_cents int

net_amount_cents int â€” remainder to the business

currency text default 'usd'

created_at, updated_at

Behavior:

At checkout: create row with status='card_saved', stripe_setup_intent_id set, amount_cents = final_price_cents (for reference).

When owner presses:

Completed â†’ create new booking_payments row with money_action='completed_charge', amount_cents = final price (minus gift), status ends at 'charged'.

No-Show â†’ new row with money_action='no_show_fee', amount_cents = no-show fee calculated from policy snapshot.

Cancelled â†’ new row with money_action='cancel_fee', amount_cents = cancel fee.

Refund â†’ new row with money_action='refund', amount_cents = refund amount (positive int), status='refunded'.

bookings.payment_status & bookings.last_money_action are updated as a denormalized summary for quick display.

Indexes

(user_id, booking_id)

(user_id, created_at DESC)

UNIQUE (stripe_payment_intent_id) to avoid duplicates.

Idempotency key table (optional) if you want to be extra safe.

3.10 policies

Purpose: what owners configure in onboarding/admin for cancellation/no-show/refund/cash.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

version int not null â€” bump on change

cancellation_policy_text text

no_show_policy_text text

refund_policy_text text

cash_policy_text text

no_show_fee_type discount_type default 'amount'

no_show_fee_amount_cents int default 0

no_show_fee_percent numeric(5,2) default 0.0

cancel_fee_type discount_type default 'amount'

cancel_fee_amount_cents int default 0

cancel_fee_percent numeric(5,2) default 0.0

is_active boolean default true

created_at, updated_at

Usage

The â€œcurrentâ€ policy is the row with highest version AND is_active = true.

When a booking is created, you copy text and numeric values into bookings.policy_snapshot.

Indexes

(user_id, business_id, is_active, version DESC)

3.11 gift_cards

Purpose: generate/store cards with balance.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

code text not null

discount_type discount_type not null â€” 'amount' | 'percent'

initial_amount_cents int not null

current_balance_cents int not null â€” only used for amount type

percent_off numeric(5,2) â€” only used for percent type

expires_at timestamptz

is_active boolean default true

created_at, updated_at, deleted_at

Constraints / indexes

UNIQUE (user_id, code) â€” codes unique per business.

Index (user_id, code) for lookup during checkout.

Index (user_id, expires_at) for cleanup.

3.12 gift_card_ledger

Purpose: audit changes to card balances.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

gift_card_id uuid not null

booking_id uuid â€” nullable (purchase / admin adjustment may not have booking)

delta_cents int not null â€” positive = added, negative = consumed

reason text â€” 'purchase' | 'redemption' | 'refund_restore' | 'admin_adjust'

created_at

Indexes

(user_id, gift_card_id, created_at).

3.13 notification_templates

Purpose: onboarding step where owner configures templates + placeholders.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

name text not null â€” internal label

channel notification_channel not null

category notification_category not null

trigger notification_trigger not null

subject text â€” email only

body_markdown text not null â€” with placeholders like ${customer.name}

is_enabled boolean default true

created_at, updated_at, deleted_at

Placeholders

You support placeholders like:

${customer.name}

${service.name}

${service.duration}

${service.price}

${booking.date}

${booking.time}

${business.name}

${booking.url}

At save time, the frontend can lint for unknown ${â€¦} patterns; backend at send time fills them from bookings, customers, services, businesses.

Indexes

(user_id, trigger, is_enabled)

(user_id, category)

3.14 notification_events

Purpose: log sends for debugging/support.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

booking_id uuid (nullable)

template_id uuid (nullable if you ever send a system message)

channel notification_channel not null

to_address text not null â€” email or phone

status text not null â€” 'queued' | 'sent' | 'failed'

provider_message_id text

error_message text

sent_at timestamptz

created_at

Indexes

(user_id, booking_id)

(user_id, to_address, created_at DESC)

4. RLS, soft delete, and indexes (strategy)
RLS pattern (Supabase)

On every tenant-owned table, do:

Add user_id uuid not null.

Policy:

ALTER TABLE services ENABLE ROW LEVEL SECURITY;

CREATE POLICY "user_owns_row" ON services
USING (
  user_id = auth.uid()
  AND deleted_at IS NULL  -- when applicable
);


Same pattern for businesses, staff, availability_rules, customers, bookings, booking_payments, gift_cards, notification_templates, etc.

This keeps your mental model super simple:

â€œIf auth.uid() doesnâ€™t match row.user_id, Postgres wonâ€™t show you the row, even if your query is wrong.â€

Given your â€œone user = one businessâ€ rule, you do not need separate tenant IDs or business pickers to enforce isolation.

Soft delete

For most configuration tables (services, staff, categories, gift cards, notification templates):

Add deleted_at timestamptz.

Treat deleted_at IS NOT NULL as hidden from normal queries.

Only allow â€œhard deleteâ€ for truly destructive actions (like business offboarding).

For bookings, Iâ€™d avoid soft delete entirely except for GDPR/account deletion; usually you never delete bookings, you just mark statuses.

Index strategy summary

Always index user_id on every multi-row table (fast RLS scans).

Time-series tables:

bookings(user_id, start_at DESC)

booking_payments(user_id, created_at DESC)

notification_events(user_id, created_at DESC)

Lookups:

customers(user_id, email), (user_id, phone)

gift_cards(user_id, code)

Availability:

availability_rules(user_id, service_id, staff_id, weekday)

Policies:

policies(user_id, business_id, is_active, version DESC)

This gives you fast queries that match your actual UI:

Past bookings paginated by date.

Search bookings by status & date.

Look up customers by email/phone.

Apply gift cards in checkout.

Generate slots by service/staff/day.

What you should actually do next

Lock in this simplified tenant model

Add user_id + RLS to all tables.

Enforce UNIQUE (user_id) on businesses.

Create the core tables in Supabase in roughly this order:

businesses, service_categories, services

staff, staff_services, availability_rules

customers, bookings, booking_payments

policies, gift_cards, gift_card_ledger

notification_templates, notification_events

Wire onboarding â†’ these tables exactly in the order of your 8 steps.

Wire booking flow:

Use services + availability_rules to build slots.

On checkout: create customer, booking, booking_payments (card saved), embed policy_snapshot.

Wire the Past Bookings page:

List from bookings ordered by start_at DESC, joined to customers, services, staff, booking_payments.

Buttons call endpoints that create new booking_payments rows and update bookings.status + payment_status.

-------------
Stripe & billing specifics


---------------

API Contracts




---------
Notifications and Availability Engine



---------
Gift Cards and Policies and Compliance