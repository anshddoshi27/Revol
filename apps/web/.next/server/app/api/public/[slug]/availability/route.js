"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/public/[slug]/availability/route";
exports.ids = ["app/api/public/[slug]/availability/route"];
exports.modules = {

/***/ "../../client/components/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/client/components/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/action-async-storage.external.js");

/***/ }),

/***/ "../../client/components/request-async-storage.external":
/*!********************************************************************************!*\
  !*** external "next/dist/client/components/request-async-storage.external.js" ***!
  \********************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/request-async-storage.external.js");

/***/ }),

/***/ "../../client/components/static-generation-async-storage.external":
/*!******************************************************************************************!*\
  !*** external "next/dist/client/components/static-generation-async-storage.external.js" ***!
  \******************************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/static-generation-async-storage.external.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fpublic%2F%5Bslug%5D%2Favailability%2Froute&page=%2Fapi%2Fpublic%2F%5Bslug%5D%2Favailability%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fpublic%2F%5Bslug%5D%2Favailability%2Froute.ts&appDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fpublic%2F%5Bslug%5D%2Favailability%2Froute&page=%2Fapi%2Fpublic%2F%5Bslug%5D%2Favailability%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fpublic%2F%5Bslug%5D%2Favailability%2Froute.ts&appDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_3017387smacbookm_Downloads_Career_Tithi_apps_web_src_app_api_public_slug_availability_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/public/[slug]/availability/route.ts */ \"(rsc)/./src/app/api/public/[slug]/availability/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/public/[slug]/availability/route\",\n        pathname: \"/api/public/[slug]/availability\",\n        filename: \"route\",\n        bundlePath: \"app/api/public/[slug]/availability/route\"\n    },\n    resolvedPagePath: \"/Users/3017387smacbookm/Downloads/Career/Tithi/apps/web/src/app/api/public/[slug]/availability/route.ts\",\n    nextConfigOutput,\n    userland: _Users_3017387smacbookm_Downloads_Career_Tithi_apps_web_src_app_api_public_slug_availability_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/public/[slug]/availability/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZwdWJsaWMlMkYlNUJzbHVnJTVEJTJGYXZhaWxhYmlsaXR5JTJGcm91dGUmcGFnZT0lMkZhcGklMkZwdWJsaWMlMkYlNUJzbHVnJTVEJTJGYXZhaWxhYmlsaXR5JTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGcHVibGljJTJGJTVCc2x1ZyU1RCUyRmF2YWlsYWJpbGl0eSUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRjMwMTczODdzbWFjYm9va20lMkZEb3dubG9hZHMlMkZDYXJlZXIlMkZUaXRoaSUyRmFwcHMlMkZ3ZWIlMkZzcmMlMkZhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPSUyRlVzZXJzJTJGMzAxNzM4N3NtYWNib29rbSUyRkRvd25sb2FkcyUyRkNhcmVlciUyRlRpdGhpJTJGYXBwcyUyRndlYiZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD0mcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ2M7QUFDdUQ7QUFDcEk7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdIQUFtQjtBQUMzQztBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVk7QUFDWixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBaUU7QUFDekU7QUFDQTtBQUNBLFdBQVcsNEVBQVc7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUN1SDs7QUFFdkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvPzA2YjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiL1VzZXJzLzMwMTczODdzbWFjYm9va20vRG93bmxvYWRzL0NhcmVlci9UaXRoaS9hcHBzL3dlYi9zcmMvYXBwL2FwaS9wdWJsaWMvW3NsdWddL2F2YWlsYWJpbGl0eS9yb3V0ZS50c1wiO1xuLy8gV2UgaW5qZWN0IHRoZSBuZXh0Q29uZmlnT3V0cHV0IGhlcmUgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZW0gaW4gdGhlIHJvdXRlXG4vLyBtb2R1bGUuXG5jb25zdCBuZXh0Q29uZmlnT3V0cHV0ID0gXCJcIlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUm91dGVSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICBwYWdlOiBcIi9hcGkvcHVibGljL1tzbHVnXS9hdmFpbGFiaWxpdHkvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9wdWJsaWMvW3NsdWddL2F2YWlsYWJpbGl0eVwiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvcHVibGljL1tzbHVnXS9hdmFpbGFiaWxpdHkvcm91dGVcIlxuICAgIH0sXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCIvVXNlcnMvMzAxNzM4N3NtYWNib29rbS9Eb3dubG9hZHMvQ2FyZWVyL1RpdGhpL2FwcHMvd2ViL3NyYy9hcHAvYXBpL3B1YmxpYy9bc2x1Z10vYXZhaWxhYmlsaXR5L3JvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MgfSA9IHJvdXRlTW9kdWxlO1xuY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IFwiL2FwaS9wdWJsaWMvW3NsdWddL2F2YWlsYWJpbGl0eS9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fpublic%2F%5Bslug%5D%2Favailability%2Froute&page=%2Fapi%2Fpublic%2F%5Bslug%5D%2Favailability%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fpublic%2F%5Bslug%5D%2Favailability%2Froute.ts&appDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./src/app/api/public/[slug]/availability/route.ts":
/*!*********************************************************!*\
  !*** ./src/app/api/public/[slug]/availability/route.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/db */ \"(rsc)/./src/lib/db.ts\");\n/* harmony import */ var _lib_availability__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/availability */ \"(rsc)/./src/lib/availability.ts\");\n\n\n\n/**\n * GET /api/public/{slug}/availability?service_id={id}&date=YYYY-MM-DD\n * \n * Returns available time slots for a service on a specific date\n * No authentication required - this is a public endpoint\n */ async function GET(request, { params }) {\n    try {\n        const { slug } = params;\n        const { searchParams } = new URL(request.url);\n        const serviceId = searchParams.get(\"service_id\");\n        const date = searchParams.get(\"date\");\n        if (!slug) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Subdomain is required\"\n            }, {\n                status: 400\n            });\n        }\n        if (!serviceId) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"service_id query parameter is required\"\n            }, {\n                status: 400\n            });\n        }\n        if (!date) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"date query parameter is required (YYYY-MM-DD)\"\n            }, {\n                status: 400\n            });\n        }\n        // Validate date format\n        const dateRegex = /^\\d{4}-\\d{2}-\\d{2}$/;\n        if (!dateRegex.test(date)) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Invalid date format. Use YYYY-MM-DD\"\n            }, {\n                status: 400\n            });\n        }\n        const supabase = (0,_lib_db__WEBPACK_IMPORTED_MODULE_1__.createAdminClient)();\n        // Get business by subdomain (only active or trial businesses are accessible)\n        const { data: business, error: businessError } = await supabase.from(\"businesses\").select(\"id, user_id, timezone, min_lead_time_minutes, max_advance_days\").eq(\"subdomain\", slug.toLowerCase()).in(\"subscription_status\", [\n            \"active\",\n            \"trial\"\n        ]).is(\"deleted_at\", null).single();\n        if (businessError) {\n            console.error(\"Business query error:\", businessError);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Business not found\",\n                details: businessError.message\n            }, {\n                status: 404\n            });\n        }\n        if (!business) {\n            console.error(\"Business not found for subdomain:\", slug);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Business not found\"\n            }, {\n                status: 404\n            });\n        }\n        // Generate availability slots\n        console.log(`[public-availability] Generating slots for service ${serviceId}, date ${date}, business ${business.id}`);\n        const slots = await (0,_lib_availability__WEBPACK_IMPORTED_MODULE_2__.generateAvailabilitySlots)({\n            serviceId,\n            date,\n            businessId: business.id,\n            userId: business.user_id,\n            businessTimezone: business.timezone,\n            minLeadTimeMinutes: business.min_lead_time_minutes,\n            maxAdvanceDays: business.max_advance_days\n        });\n        console.log(`[public-availability] Generated ${slots.length} slots for service ${serviceId}, date ${date}`);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            slots,\n            service_id: serviceId,\n            date\n        });\n    } catch (error) {\n        console.error(\"Error in public availability:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Internal server error\",\n            details: error instanceof Error ? error.message : \"Unknown error\"\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvYXBwL2FwaS9wdWJsaWMvW3NsdWddL2F2YWlsYWJpbGl0eS9yb3V0ZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTJDO0FBQ0U7QUFDa0I7QUFFL0Q7Ozs7O0NBS0MsR0FDTSxlQUFlRyxJQUNwQkMsT0FBZ0IsRUFDaEIsRUFBRUMsTUFBTSxFQUFnQztJQUV4QyxJQUFJO1FBQ0YsTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBR0Q7UUFDakIsTUFBTSxFQUFFRSxZQUFZLEVBQUUsR0FBRyxJQUFJQyxJQUFJSixRQUFRSyxHQUFHO1FBQzVDLE1BQU1DLFlBQVlILGFBQWFJLEdBQUcsQ0FBQztRQUNuQyxNQUFNQyxPQUFPTCxhQUFhSSxHQUFHLENBQUM7UUFFOUIsSUFBSSxDQUFDTCxNQUFNO1lBQ1QsT0FBT04scURBQVlBLENBQUNhLElBQUksQ0FDdEI7Z0JBQUVDLE9BQU87WUFBd0IsR0FDakM7Z0JBQUVDLFFBQVE7WUFBSTtRQUVsQjtRQUVBLElBQUksQ0FBQ0wsV0FBVztZQUNkLE9BQU9WLHFEQUFZQSxDQUFDYSxJQUFJLENBQ3RCO2dCQUFFQyxPQUFPO1lBQXlDLEdBQ2xEO2dCQUFFQyxRQUFRO1lBQUk7UUFFbEI7UUFFQSxJQUFJLENBQUNILE1BQU07WUFDVCxPQUFPWixxREFBWUEsQ0FBQ2EsSUFBSSxDQUN0QjtnQkFBRUMsT0FBTztZQUFnRCxHQUN6RDtnQkFBRUMsUUFBUTtZQUFJO1FBRWxCO1FBRUEsdUJBQXVCO1FBQ3ZCLE1BQU1DLFlBQVk7UUFDbEIsSUFBSSxDQUFDQSxVQUFVQyxJQUFJLENBQUNMLE9BQU87WUFDekIsT0FBT1oscURBQVlBLENBQUNhLElBQUksQ0FDdEI7Z0JBQUVDLE9BQU87WUFBc0MsR0FDL0M7Z0JBQUVDLFFBQVE7WUFBSTtRQUVsQjtRQUVBLE1BQU1HLFdBQVdqQiwwREFBaUJBO1FBRWxDLDZFQUE2RTtRQUM3RSxNQUFNLEVBQUVrQixNQUFNQyxRQUFRLEVBQUVOLE9BQU9PLGFBQWEsRUFBRSxHQUFHLE1BQU1ILFNBQ3BESSxJQUFJLENBQUMsY0FDTEMsTUFBTSxDQUFDLGtFQUNQQyxFQUFFLENBQUMsYUFBYWxCLEtBQUttQixXQUFXLElBQ2hDQyxFQUFFLENBQUMsdUJBQXVCO1lBQUM7WUFBVTtTQUFRLEVBQzdDQyxFQUFFLENBQUMsY0FBYyxNQUNqQkMsTUFBTTtRQUVULElBQUlQLGVBQWU7WUFDakJRLFFBQVFmLEtBQUssQ0FBQyx5QkFBeUJPO1lBQ3ZDLE9BQU9yQixxREFBWUEsQ0FBQ2EsSUFBSSxDQUN0QjtnQkFBRUMsT0FBTztnQkFBc0JnQixTQUFTVCxjQUFjVSxPQUFPO1lBQUMsR0FDOUQ7Z0JBQUVoQixRQUFRO1lBQUk7UUFFbEI7UUFFQSxJQUFJLENBQUNLLFVBQVU7WUFDYlMsUUFBUWYsS0FBSyxDQUFDLHFDQUFxQ1I7WUFDbkQsT0FBT04scURBQVlBLENBQUNhLElBQUksQ0FDdEI7Z0JBQUVDLE9BQU87WUFBcUIsR0FDOUI7Z0JBQUVDLFFBQVE7WUFBSTtRQUVsQjtRQUVBLDhCQUE4QjtRQUM5QmMsUUFBUUcsR0FBRyxDQUFDLENBQUMsbURBQW1ELEVBQUV0QixVQUFVLE9BQU8sRUFBRUUsS0FBSyxXQUFXLEVBQUVRLFNBQVNhLEVBQUUsQ0FBQyxDQUFDO1FBQ3BILE1BQU1DLFFBQVEsTUFBTWhDLDRFQUF5QkEsQ0FBQztZQUM1Q1E7WUFDQUU7WUFDQXVCLFlBQVlmLFNBQVNhLEVBQUU7WUFDdkJHLFFBQVFoQixTQUFTaUIsT0FBTztZQUN4QkMsa0JBQWtCbEIsU0FBU21CLFFBQVE7WUFDbkNDLG9CQUFvQnBCLFNBQVNxQixxQkFBcUI7WUFDbERDLGdCQUFnQnRCLFNBQVN1QixnQkFBZ0I7UUFDM0M7UUFFQWQsUUFBUUcsR0FBRyxDQUFDLENBQUMsZ0NBQWdDLEVBQUVFLE1BQU1VLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRWxDLFVBQVUsT0FBTyxFQUFFRSxLQUFLLENBQUM7UUFFMUcsT0FBT1oscURBQVlBLENBQUNhLElBQUksQ0FBQztZQUN2QnFCO1lBQ0FXLFlBQVluQztZQUNaRTtRQUNGO0lBQ0YsRUFBRSxPQUFPRSxPQUFPO1FBQ2RlLFFBQVFmLEtBQUssQ0FBQyxpQ0FBaUNBO1FBQy9DLE9BQU9kLHFEQUFZQSxDQUFDYSxJQUFJLENBQ3RCO1lBQUVDLE9BQU87WUFBeUJnQixTQUFTaEIsaUJBQWlCZ0MsUUFBUWhDLE1BQU1pQixPQUFPLEdBQUc7UUFBZ0IsR0FDcEc7WUFBRWhCLFFBQVE7UUFBSTtJQUVsQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vc3JjL2FwcC9hcGkvcHVibGljL1tzbHVnXS9hdmFpbGFiaWxpdHkvcm91dGUudHM/NjRjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcic7XG5pbXBvcnQgeyBjcmVhdGVBZG1pbkNsaWVudCB9IGZyb20gJ0AvbGliL2RiJztcbmltcG9ydCB7IGdlbmVyYXRlQXZhaWxhYmlsaXR5U2xvdHMgfSBmcm9tICdAL2xpYi9hdmFpbGFiaWxpdHknO1xuXG4vKipcbiAqIEdFVCAvYXBpL3B1YmxpYy97c2x1Z30vYXZhaWxhYmlsaXR5P3NlcnZpY2VfaWQ9e2lkfSZkYXRlPVlZWVktTU0tRERcbiAqIFxuICogUmV0dXJucyBhdmFpbGFibGUgdGltZSBzbG90cyBmb3IgYSBzZXJ2aWNlIG9uIGEgc3BlY2lmaWMgZGF0ZVxuICogTm8gYXV0aGVudGljYXRpb24gcmVxdWlyZWQgLSB0aGlzIGlzIGEgcHVibGljIGVuZHBvaW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBHRVQoXG4gIHJlcXVlc3Q6IFJlcXVlc3QsXG4gIHsgcGFyYW1zIH06IHsgcGFyYW1zOiB7IHNsdWc6IHN0cmluZyB9IH1cbikge1xuICB0cnkge1xuICAgIGNvbnN0IHsgc2x1ZyB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHsgc2VhcmNoUGFyYW1zIH0gPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBjb25zdCBzZXJ2aWNlSWQgPSBzZWFyY2hQYXJhbXMuZ2V0KCdzZXJ2aWNlX2lkJyk7XG4gICAgY29uc3QgZGF0ZSA9IHNlYXJjaFBhcmFtcy5nZXQoJ2RhdGUnKTtcblxuICAgIGlmICghc2x1Zykge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnU3ViZG9tYWluIGlzIHJlcXVpcmVkJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFzZXJ2aWNlSWQpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ3NlcnZpY2VfaWQgcXVlcnkgcGFyYW1ldGVyIGlzIHJlcXVpcmVkJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFkYXRlKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdkYXRlIHF1ZXJ5IHBhcmFtZXRlciBpcyByZXF1aXJlZCAoWVlZWS1NTS1ERCknIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBkYXRlIGZvcm1hdFxuICAgIGNvbnN0IGRhdGVSZWdleCA9IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0kLztcbiAgICBpZiAoIWRhdGVSZWdleC50ZXN0KGRhdGUpKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdJbnZhbGlkIGRhdGUgZm9ybWF0LiBVc2UgWVlZWS1NTS1ERCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQWRtaW5DbGllbnQoKTtcblxuICAgIC8vIEdldCBidXNpbmVzcyBieSBzdWJkb21haW4gKG9ubHkgYWN0aXZlIG9yIHRyaWFsIGJ1c2luZXNzZXMgYXJlIGFjY2Vzc2libGUpXG4gICAgY29uc3QgeyBkYXRhOiBidXNpbmVzcywgZXJyb3I6IGJ1c2luZXNzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYnVzaW5lc3NlcycpXG4gICAgICAuc2VsZWN0KCdpZCwgdXNlcl9pZCwgdGltZXpvbmUsIG1pbl9sZWFkX3RpbWVfbWludXRlcywgbWF4X2FkdmFuY2VfZGF5cycpXG4gICAgICAuZXEoJ3N1YmRvbWFpbicsIHNsdWcudG9Mb3dlckNhc2UoKSlcbiAgICAgIC5pbignc3Vic2NyaXB0aW9uX3N0YXR1cycsIFsnYWN0aXZlJywgJ3RyaWFsJ10pXG4gICAgICAuaXMoJ2RlbGV0ZWRfYXQnLCBudWxsKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKGJ1c2luZXNzRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0J1c2luZXNzIHF1ZXJ5IGVycm9yOicsIGJ1c2luZXNzRXJyb3IpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnQnVzaW5lc3Mgbm90IGZvdW5kJywgZGV0YWlsczogYnVzaW5lc3NFcnJvci5tZXNzYWdlIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDQgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWJ1c2luZXNzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdCdXNpbmVzcyBub3QgZm91bmQgZm9yIHN1YmRvbWFpbjonLCBzbHVnKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0J1c2luZXNzIG5vdCBmb3VuZCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwNCB9XG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIGF2YWlsYWJpbGl0eSBzbG90c1xuICAgIGNvbnNvbGUubG9nKGBbcHVibGljLWF2YWlsYWJpbGl0eV0gR2VuZXJhdGluZyBzbG90cyBmb3Igc2VydmljZSAke3NlcnZpY2VJZH0sIGRhdGUgJHtkYXRlfSwgYnVzaW5lc3MgJHtidXNpbmVzcy5pZH1gKTtcbiAgICBjb25zdCBzbG90cyA9IGF3YWl0IGdlbmVyYXRlQXZhaWxhYmlsaXR5U2xvdHMoe1xuICAgICAgc2VydmljZUlkLFxuICAgICAgZGF0ZSxcbiAgICAgIGJ1c2luZXNzSWQ6IGJ1c2luZXNzLmlkLFxuICAgICAgdXNlcklkOiBidXNpbmVzcy51c2VyX2lkLFxuICAgICAgYnVzaW5lc3NUaW1lem9uZTogYnVzaW5lc3MudGltZXpvbmUsXG4gICAgICBtaW5MZWFkVGltZU1pbnV0ZXM6IGJ1c2luZXNzLm1pbl9sZWFkX3RpbWVfbWludXRlcyxcbiAgICAgIG1heEFkdmFuY2VEYXlzOiBidXNpbmVzcy5tYXhfYWR2YW5jZV9kYXlzLFxuICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coYFtwdWJsaWMtYXZhaWxhYmlsaXR5XSBHZW5lcmF0ZWQgJHtzbG90cy5sZW5ndGh9IHNsb3RzIGZvciBzZXJ2aWNlICR7c2VydmljZUlkfSwgZGF0ZSAke2RhdGV9YCk7XG5cbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgc2xvdHMsXG4gICAgICBzZXJ2aWNlX2lkOiBzZXJ2aWNlSWQsXG4gICAgICBkYXRlLFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHB1YmxpYyBhdmFpbGFiaWxpdHk6JywgZXJyb3IpO1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHsgZXJyb3I6ICdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InLCBkZXRhaWxzOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyB9LFxuICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgKTtcbiAgfVxufVxuXG5cbiJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJjcmVhdGVBZG1pbkNsaWVudCIsImdlbmVyYXRlQXZhaWxhYmlsaXR5U2xvdHMiLCJHRVQiLCJyZXF1ZXN0IiwicGFyYW1zIiwic2x1ZyIsInNlYXJjaFBhcmFtcyIsIlVSTCIsInVybCIsInNlcnZpY2VJZCIsImdldCIsImRhdGUiLCJqc29uIiwiZXJyb3IiLCJzdGF0dXMiLCJkYXRlUmVnZXgiLCJ0ZXN0Iiwic3VwYWJhc2UiLCJkYXRhIiwiYnVzaW5lc3MiLCJidXNpbmVzc0Vycm9yIiwiZnJvbSIsInNlbGVjdCIsImVxIiwidG9Mb3dlckNhc2UiLCJpbiIsImlzIiwic2luZ2xlIiwiY29uc29sZSIsImRldGFpbHMiLCJtZXNzYWdlIiwibG9nIiwiaWQiLCJzbG90cyIsImJ1c2luZXNzSWQiLCJ1c2VySWQiLCJ1c2VyX2lkIiwiYnVzaW5lc3NUaW1lem9uZSIsInRpbWV6b25lIiwibWluTGVhZFRpbWVNaW51dGVzIiwibWluX2xlYWRfdGltZV9taW51dGVzIiwibWF4QWR2YW5jZURheXMiLCJtYXhfYWR2YW5jZV9kYXlzIiwibGVuZ3RoIiwic2VydmljZV9pZCIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/public/[slug]/availability/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/availability.ts":
/*!*********************************!*\
  !*** ./src/lib/availability.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateAvailabilitySlots: () => (/* binding */ generateAvailabilitySlots)\n/* harmony export */ });\n/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./db */ \"(rsc)/./src/lib/db.ts\");\n/* harmony import */ var date_fns_tz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! date-fns-tz */ \"(rsc)/../../node_modules/date-fns-tz/dist/esm/index.js\");\n\n\nconst SLOT_DURATION_MINUTES = 15;\nconst DEFAULT_MIN_LEAD_TIME_MINUTES = 120; // 2 hours\nconst DEFAULT_MAX_ADVANCE_DAYS = 60;\n/**\n * Generate available time slots for a service on a specific date\n */ async function generateAvailabilitySlots(params) {\n    const { serviceId, date, businessId, userId, businessTimezone, minLeadTimeMinutes, maxAdvanceDays } = params;\n    const supabase = (0,_db__WEBPACK_IMPORTED_MODULE_0__.createAdminClient)();\n    // Use provided business settings or fetch them if not provided\n    let timezone = businessTimezone || \"America/New_York\";\n    let minLeadTime = minLeadTimeMinutes ?? DEFAULT_MIN_LEAD_TIME_MINUTES;\n    let maxAdvance = maxAdvanceDays ?? DEFAULT_MAX_ADVANCE_DAYS;\n    // If business settings not provided, fetch them from database\n    if (businessTimezone === undefined || minLeadTimeMinutes === undefined || maxAdvanceDays === undefined) {\n        const { data: business } = await supabase.from(\"businesses\").select(\"timezone, min_lead_time_minutes, max_advance_days\").eq(\"id\", businessId).single();\n        if (!business) {\n            throw new Error(\"Business not found\");\n        }\n        timezone = business.timezone || \"America/New_York\";\n        // Use database values if not provided as params, fall back to defaults\n        if (minLeadTimeMinutes === undefined) {\n            minLeadTime = business.min_lead_time_minutes ?? DEFAULT_MIN_LEAD_TIME_MINUTES;\n        }\n        if (maxAdvanceDays === undefined) {\n            maxAdvance = business.max_advance_days ?? DEFAULT_MAX_ADVANCE_DAYS;\n        }\n    }\n    // Parse the date in the business timezone and get weekday (0-6, Sunday=0)\n    // Create a date string at midnight in business timezone, convert to UTC, then back to business timezone to get correct weekday\n    const targetDateStr = `${date}T00:00:00`;\n    // Parse as if in business timezone, then convert to UTC Date\n    const targetDateLocal = new Date(targetDateStr);\n    // Validate input date\n    if (isNaN(targetDateLocal.getTime())) {\n        console.error(`[availability] Invalid date string: ${targetDateStr}`);\n        return [];\n    }\n    // Validate timezone\n    if (!timezone || typeof timezone !== \"string\") {\n        console.error(`[availability] Invalid timezone: ${timezone}`);\n        return [];\n    }\n    let targetDateUTC;\n    try {\n        targetDateUTC = (0,date_fns_tz__WEBPACK_IMPORTED_MODULE_1__.fromZonedTime)(targetDateLocal, timezone);\n        // Validate converted date\n        if (isNaN(targetDateUTC.getTime())) {\n            console.error(`[availability] Invalid date after timezone conversion:`, {\n                date,\n                targetDateStr,\n                timezone,\n                targetDateLocal: targetDateLocal.toISOString()\n            });\n            return [];\n        }\n    } catch (error) {\n        console.error(`[availability] Error converting timezone:`, error, {\n            date,\n            targetDateStr,\n            timezone\n        });\n        return [];\n    }\n    const targetDateInTimezone = (0,date_fns_tz__WEBPACK_IMPORTED_MODULE_1__.toZonedTime)(targetDateUTC, timezone);\n    const weekday = targetDateInTimezone.getDay(); // Get weekday in business timezone\n    // Get service duration\n    const { data: service } = await supabase.from(\"services\").select(\"duration_min\").eq(\"id\", serviceId).single();\n    if (!service) {\n        throw new Error(\"Service not found\");\n    }\n    const serviceDurationMinutes = service.duration_min;\n    // First, try to get staff from staff_services associations\n    let staffIds = [];\n    const { data: staffServices } = await supabase.from(\"staff_services\").select(\"staff_id\").eq(\"service_id\", serviceId).eq(\"business_id\", businessId);\n    if (staffServices && staffServices.length > 0) {\n        staffIds = staffServices.map((ss)=>ss.staff_id);\n        console.log(`[availability] Found ${staffIds.length} staff from staff_services for service ${serviceId}`);\n    } else {\n        // If no staff_services associations exist, get staff from availability_rules directly\n        // This handles cases where staff associations weren't created during onboarding\n        console.log(`[availability] No staff_services found, checking availability_rules for service ${serviceId}`);\n        const { data: rulesWithStaff } = await supabase.from(\"availability_rules\").select(\"staff_id\").eq(\"business_id\", businessId).eq(\"service_id\", serviceId).eq(\"rule_type\", \"weekly\").is(\"deleted_at\", null);\n        if (rulesWithStaff && rulesWithStaff.length > 0) {\n            // Get unique staff IDs from rules\n            const uniqueStaffIds = [\n                ...new Set(rulesWithStaff.map((r)=>r.staff_id))\n            ];\n            staffIds = uniqueStaffIds;\n            console.log(`[availability] Found ${staffIds.length} staff from availability_rules for service ${serviceId}`);\n        }\n    }\n    if (staffIds.length === 0) {\n        console.log(`[availability] No staff found for service ${serviceId}`);\n        return [];\n    }\n    // Get staff names\n    const { data: staffList } = await supabase.from(\"staff\").select(\"id, name\").in(\"id\", staffIds).eq(\"business_id\", businessId).eq(\"is_active\", true).is(\"deleted_at\", null);\n    if (!staffList || staffList.length === 0) {\n        console.log(`[availability] No active staff found for IDs:`, staffIds);\n        return [];\n    }\n    const staffMap = new Map(staffList.map((s)=>[\n            s.id,\n            s.name\n        ]));\n    console.log(`[availability] Staff map:`, Array.from(staffMap.entries()));\n    // Get availability rules for this service, staff, and weekday\n    // Also filter by business_id to ensure we get the right rules\n    const { data: rules, error: rulesError } = await supabase.from(\"availability_rules\").select(\"staff_id, weekday, start_time, end_time\").eq(\"business_id\", businessId).eq(\"service_id\", serviceId).in(\"staff_id\", staffIds.length > 0 ? staffIds : [\n        \"00000000-0000-0000-0000-000000000000\"\n    ]) // Prevent empty array\n    .eq(\"weekday\", weekday).eq(\"rule_type\", \"weekly\").is(\"deleted_at\", null);\n    if (rulesError) {\n        console.error(`[availability] Error fetching rules for ${date}:`, rulesError);\n    }\n    if (!rules || rules.length === 0) {\n        console.log(`[availability] No rules found for service ${serviceId}, date ${date}, weekday ${weekday}, staffIds:`, staffIds);\n        return [];\n    }\n    console.log(`[availability] Found ${rules.length} rules for service ${serviceId}, date ${date}, weekday ${weekday}`);\n    // Get blackouts for this date (staff-specific and global)\n    const dayStart = new Date(`${date}T00:00:00Z`);\n    const dayEnd = new Date(`${date}T23:59:59Z`);\n    const { data: blackouts } = await supabase.from(\"blackouts\").select(\"staff_id, start_at, end_at\").eq(\"business_id\", businessId).lte(\"start_at\", dayEnd.toISOString()).gte(\"end_at\", dayStart.toISOString()).is(\"deleted_at\", null);\n    // Get existing bookings for this date and staff\n    const { data: bookings } = await supabase.from(\"bookings\").select(\"staff_id, start_at, end_at\").eq(\"business_id\", businessId).in(\"staff_id\", staffIds).gte(\"start_at\", dayStart.toISOString()).lte(\"start_at\", dayEnd.toISOString()).in(\"status\", [\n        \"pending\",\n        \"scheduled\",\n        \"held\"\n    ]).is(\"deleted_at\", null);\n    // Helper to check if a time overlaps with blackouts\n    const isInBlackout = (start, end, staffId)=>{\n        if (!blackouts) return false;\n        return blackouts.some((blackout)=>{\n            // Global blackout (staff_id is null)\n            if (!blackout.staff_id) {\n                return start < new Date(blackout.end_at) && end > new Date(blackout.start_at);\n            }\n            // Staff-specific blackout\n            if (blackout.staff_id === staffId) {\n                return start < new Date(blackout.end_at) && end > new Date(blackout.start_at);\n            }\n            return false;\n        });\n    };\n    // Helper to check if a time overlaps with existing bookings\n    const isOverlappingBooking = (start, end, staffId)=>{\n        if (!bookings) return false;\n        return bookings.some((booking)=>{\n            if (booking.staff_id === staffId) {\n                const bookingStart = new Date(booking.start_at);\n                const bookingEnd = new Date(booking.end_at);\n                return start < bookingEnd && end > bookingStart;\n            }\n            return false;\n        });\n    };\n    const slots = [];\n    const now = new Date();\n    const minStartTime = new Date(now.getTime() + minLeadTime * 60 * 1000);\n    const maxAdvanceDate = new Date(now.getTime() + maxAdvance * 24 * 60 * 60 * 1000);\n    // Validate targetDateUTC before logging\n    const targetDateUTCStr = isNaN(targetDateUTC.getTime()) ? \"Invalid Date\" : targetDateUTC.toISOString();\n    console.log(`[availability] Slot generation params:`, {\n        date,\n        weekday,\n        now: now.toISOString(),\n        minStartTime: minStartTime.toISOString(),\n        maxAdvanceDate: maxAdvanceDate.toISOString(),\n        targetDateUTC: targetDateUTCStr,\n        minLeadTime,\n        maxAdvance,\n        rulesCount: rules.length\n    });\n    // If targetDateUTC is invalid, return early\n    if (isNaN(targetDateUTC.getTime())) {\n        console.error(`[availability] Invalid targetDateUTC for date ${date}, timezone ${timezone}`);\n        return [];\n    }\n    // If the target date is too far in advance, return empty\n    // Use UTC date for comparison\n    const targetDateUTCForComparison = targetDateUTC;\n    if (targetDateUTCForComparison > maxAdvanceDate) {\n        console.log(`[availability] Target date ${targetDateUTCForComparison.toISOString()} is beyond max advance date ${maxAdvanceDate.toISOString()}`);\n        return [];\n    }\n    let totalSlotsChecked = 0;\n    let slotsFilteredByLeadTime = 0;\n    let slotsFilteredByPast = 0;\n    let slotsFilteredByBlackout = 0;\n    let slotsFilteredByBooking = 0;\n    // Process each rule\n    for (const rule of rules){\n        const staffId = rule.staff_id;\n        const staffName = staffMap.get(staffId);\n        if (!staffName) {\n            console.log(`[availability] Skipping rule - staff name not found for ${staffId}`);\n            continue;\n        }\n        // Parse start_time and end_time (HH:mm format in business timezone)\n        // Parse date components\n        const [year, month, day] = date.split(\"-\").map(Number);\n        const [startHour, startMin] = rule.start_time.split(\":\").map(Number);\n        const [endHour, endMin] = rule.end_time.split(\":\").map(Number);\n        // Validate timezone\n        if (!timezone || typeof timezone !== \"string\") {\n            console.error(`[availability] Invalid timezone:`, timezone);\n            continue;\n        }\n        // Create a date string in ISO format, then parse it\n        // The key: we create the date as if it's in UTC, then use fromZonedTime to treat it as business timezone\n        const ruleStartStr = `${year}-${String(month).padStart(2, \"0\")}-${String(day).padStart(2, \"0\")}T${String(startHour).padStart(2, \"0\")}:${String(startMin).padStart(2, \"0\")}:00`;\n        const ruleEndStr = `${year}-${String(month).padStart(2, \"0\")}-${String(day).padStart(2, \"0\")}T${String(endHour).padStart(2, \"0\")}:${String(endMin).padStart(2, \"0\")}:00`;\n        // Create Date objects - these represent the wall-clock time\n        // We'll treat them as if they're in the business timezone\n        const ruleStartLocal = new Date(ruleStartStr);\n        const ruleEndLocal = new Date(ruleEndStr);\n        // Validate input dates\n        if (isNaN(ruleStartLocal.getTime()) || isNaN(ruleEndLocal.getTime())) {\n            console.error(`[availability] Invalid date created from:`, {\n                ruleStartStr,\n                ruleEndStr,\n                date,\n                startTime: rule.start_time,\n                endTime: rule.end_time\n            });\n            continue;\n        }\n        // fromZonedTime: treats the input Date as representing a time in the given timezone,\n        // and returns the equivalent Date in UTC\n        let ruleStartUTC;\n        let ruleEndUTC;\n        try {\n            ruleStartUTC = (0,date_fns_tz__WEBPACK_IMPORTED_MODULE_1__.fromZonedTime)(ruleStartLocal, timezone);\n            ruleEndUTC = (0,date_fns_tz__WEBPACK_IMPORTED_MODULE_1__.fromZonedTime)(ruleEndLocal, timezone);\n            // Validate the converted dates\n            if (isNaN(ruleStartUTC.getTime()) || isNaN(ruleEndUTC.getTime())) {\n                console.error(`[availability] Invalid date after timezone conversion:`, {\n                    date,\n                    startTime: rule.start_time,\n                    endTime: rule.end_time,\n                    timezone,\n                    ruleStartLocal: ruleStartLocal.toISOString(),\n                    ruleEndLocal: ruleEndLocal.toISOString()\n                });\n                continue;\n            }\n        } catch (error) {\n            console.error(`[availability] Error converting timezone for rule:`, error, {\n                date,\n                startTime: rule.start_time,\n                endTime: rule.end_time,\n                timezone\n            });\n            continue;\n        }\n        console.log(`[availability] Processing rule:`, {\n            staffId,\n            staffName,\n            startTime: rule.start_time,\n            endTime: rule.end_time,\n            ruleStartUTC: ruleStartUTC.toISOString(),\n            ruleEndUTC: ruleEndUTC.toISOString()\n        });\n        // Walk in 15-minute increments (working in UTC)\n        let currentStart = new Date(ruleStartUTC);\n        const ruleEndTime = new Date(ruleEndUTC);\n        while(currentStart < ruleEndTime){\n            const slotEnd = new Date(currentStart.getTime() + serviceDurationMinutes * 60 * 1000);\n            totalSlotsChecked++;\n            // Check if slot fits within rule end time\n            if (slotEnd > ruleEndTime) {\n                break;\n            }\n            // Check lead time (must be after minimum lead time from now)\n            if (currentStart < minStartTime) {\n                slotsFilteredByLeadTime++;\n                currentStart = new Date(currentStart.getTime() + SLOT_DURATION_MINUTES * 60 * 1000);\n                continue;\n            }\n            // Check if slot is in the past\n            if (currentStart < now) {\n                slotsFilteredByPast++;\n                currentStart = new Date(currentStart.getTime() + SLOT_DURATION_MINUTES * 60 * 1000);\n                continue;\n            }\n            // Check blackouts\n            if (isInBlackout(currentStart, slotEnd, staffId)) {\n                slotsFilteredByBlackout++;\n                currentStart = new Date(currentStart.getTime() + SLOT_DURATION_MINUTES * 60 * 1000);\n                continue;\n            }\n            // Check existing bookings\n            if (isOverlappingBooking(currentStart, slotEnd, staffId)) {\n                slotsFilteredByBooking++;\n                currentStart = new Date(currentStart.getTime() + SLOT_DURATION_MINUTES * 60 * 1000);\n                continue;\n            }\n            // Valid slot - ensure times are in UTC ISO format\n            slots.push({\n                staff_id: staffId,\n                staff_name: staffName,\n                start_at: new Date(currentStart).toISOString(),\n                end_at: new Date(slotEnd).toISOString()\n            });\n            // Move to next 15-minute slot\n            currentStart = new Date(currentStart.getTime() + SLOT_DURATION_MINUTES * 60 * 1000);\n        }\n    }\n    console.log(`[availability] Slot generation summary:`, {\n        totalSlotsChecked,\n        slotsGenerated: slots.length,\n        filteredByLeadTime: slotsFilteredByLeadTime,\n        filteredByPast: slotsFilteredByPast,\n        filteredByBlackout: slotsFilteredByBlackout,\n        filteredByBooking: slotsFilteredByBooking\n    });\n    // Sort slots by start time\n    slots.sort((a, b)=>new Date(a.start_at).getTime() - new Date(b.start_at).getTime());\n    return slots;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFlLElBQUkxRixLQUFLMEYsYUFBYXhGLE9BQU8sS0FBSzlCLHdCQUF3QixLQUFLO1FBQ2hGO0lBQ0Y7SUFFQStCLFFBQVFnQixHQUFHLENBQUMsQ0FBQyx1Q0FBdUMsQ0FBQyxFQUFFO1FBQ3JEMEM7UUFDQWtDLGdCQUFnQnpDLE1BQU12QyxNQUFNO1FBQzVCaUYsb0JBQW9CbEM7UUFDcEJtQyxnQkFBZ0JsQztRQUNoQm1DLG9CQUFvQmxDO1FBQ3BCbUMsbUJBQW1CbEM7SUFDckI7SUFFQSwyQkFBMkI7SUFDM0JYLE1BQU04QyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTSxJQUFJdEcsS0FBS3FHLEVBQUVwRCxRQUFRLEVBQUUvQyxPQUFPLEtBQUssSUFBSUYsS0FBS3NHLEVBQUVyRCxRQUFRLEVBQUUvQyxPQUFPO0lBRWxGLE9BQU9vRDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vc3JjL2xpYi9hdmFpbGFiaWxpdHkudHM/MWI1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVBZG1pbkNsaWVudCB9IGZyb20gJy4vZGInO1xuaW1wb3J0IHsgZnJvbVpvbmVkVGltZSwgdG9ab25lZFRpbWUgfSBmcm9tICdkYXRlLWZucy10eic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXZhaWxhYmlsaXR5U2xvdCB7XG4gIHN0YWZmX2lkOiBzdHJpbmc7XG4gIHN0YWZmX25hbWU6IHN0cmluZztcbiAgc3RhcnRfYXQ6IHN0cmluZzsgLy8gSVNPIHRpbWVzdGFtcFxuICBlbmRfYXQ6IHN0cmluZzsgLy8gSVNPIHRpbWVzdGFtcFxufVxuXG5pbnRlcmZhY2UgQXZhaWxhYmlsaXR5UGFyYW1zIHtcbiAgc2VydmljZUlkOiBzdHJpbmc7XG4gIGRhdGU6IHN0cmluZzsgLy8gWVlZWS1NTS1ERFxuICBidXNpbmVzc0lkOiBzdHJpbmc7XG4gIHVzZXJJZDogc3RyaW5nO1xuICBidXNpbmVzc1RpbWV6b25lPzogc3RyaW5nIHwgbnVsbDtcbiAgbWluTGVhZFRpbWVNaW51dGVzPzogbnVtYmVyIHwgbnVsbDtcbiAgbWF4QWR2YW5jZURheXM/OiBudW1iZXIgfCBudWxsO1xufVxuXG5pbnRlcmZhY2UgQXZhaWxhYmlsaXR5UnVsZSB7XG4gIHN0YWZmX2lkOiBzdHJpbmc7XG4gIHdlZWtkYXk6IG51bWJlcjtcbiAgc3RhcnRfdGltZTogc3RyaW5nOyAvLyBISDptbVxuICBlbmRfdGltZTogc3RyaW5nOyAvLyBISDptbVxufVxuXG5pbnRlcmZhY2UgQmxhY2tvdXQge1xuICBzdGFmZl9pZDogc3RyaW5nIHwgbnVsbDtcbiAgc3RhcnRfYXQ6IHN0cmluZztcbiAgZW5kX2F0OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBFeGlzdGluZ0Jvb2tpbmcge1xuICBzdGFmZl9pZDogc3RyaW5nO1xuICBzdGFydF9hdDogc3RyaW5nO1xuICBlbmRfYXQ6IHN0cmluZztcbn1cblxuY29uc3QgU0xPVF9EVVJBVElPTl9NSU5VVEVTID0gMTU7XG5jb25zdCBERUZBVUxUX01JTl9MRUFEX1RJTUVfTUlOVVRFUyA9IDEyMDsgLy8gMiBob3Vyc1xuY29uc3QgREVGQVVMVF9NQVhfQURWQU5DRV9EQVlTID0gNjA7XG5cbi8qKlxuICogR2VuZXJhdGUgYXZhaWxhYmxlIHRpbWUgc2xvdHMgZm9yIGEgc2VydmljZSBvbiBhIHNwZWNpZmljIGRhdGVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlQXZhaWxhYmlsaXR5U2xvdHMoXG4gIHBhcmFtczogQXZhaWxhYmlsaXR5UGFyYW1zXG4pOiBQcm9taXNlPEF2YWlsYWJpbGl0eVNsb3RbXT4ge1xuICBjb25zdCB7IHNlcnZpY2VJZCwgZGF0ZSwgYnVzaW5lc3NJZCwgdXNlcklkLCBidXNpbmVzc1RpbWV6b25lLCBtaW5MZWFkVGltZU1pbnV0ZXMsIG1heEFkdmFuY2VEYXlzIH0gPSBwYXJhbXM7XG5cbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVBZG1pbkNsaWVudCgpO1xuXG4gIC8vIFVzZSBwcm92aWRlZCBidXNpbmVzcyBzZXR0aW5ncyBvciBmZXRjaCB0aGVtIGlmIG5vdCBwcm92aWRlZFxuICBsZXQgdGltZXpvbmUgPSBidXNpbmVzc1RpbWV6b25lIHx8ICdBbWVyaWNhL05ld19Zb3JrJztcbiAgbGV0IG1pbkxlYWRUaW1lID0gbWluTGVhZFRpbWVNaW51dGVzID8/IERFRkFVTFRfTUlOX0xFQURfVElNRV9NSU5VVEVTO1xuICBsZXQgbWF4QWR2YW5jZSA9IG1heEFkdmFuY2VEYXlzID8/IERFRkFVTFRfTUFYX0FEVkFOQ0VfREFZUztcblxuICAvLyBJZiBidXNpbmVzcyBzZXR0aW5ncyBub3QgcHJvdmlkZWQsIGZldGNoIHRoZW0gZnJvbSBkYXRhYmFzZVxuICBpZiAoYnVzaW5lc3NUaW1lem9uZSA9PT0gdW5kZWZpbmVkIHx8IG1pbkxlYWRUaW1lTWludXRlcyA9PT0gdW5kZWZpbmVkIHx8IG1heEFkdmFuY2VEYXlzID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB7IGRhdGE6IGJ1c2luZXNzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2J1c2luZXNzZXMnKVxuICAgICAgLnNlbGVjdCgndGltZXpvbmUsIG1pbl9sZWFkX3RpbWVfbWludXRlcywgbWF4X2FkdmFuY2VfZGF5cycpXG4gICAgICAuZXEoJ2lkJywgYnVzaW5lc3NJZClcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmICghYnVzaW5lc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQnVzaW5lc3Mgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgdGltZXpvbmUgPSBidXNpbmVzcy50aW1lem9uZSB8fCAnQW1lcmljYS9OZXdfWW9yayc7XG4gICAgXG4gICAgLy8gVXNlIGRhdGFiYXNlIHZhbHVlcyBpZiBub3QgcHJvdmlkZWQgYXMgcGFyYW1zLCBmYWxsIGJhY2sgdG8gZGVmYXVsdHNcbiAgICBpZiAobWluTGVhZFRpbWVNaW51dGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG1pbkxlYWRUaW1lID0gYnVzaW5lc3MubWluX2xlYWRfdGltZV9taW51dGVzID8/IERFRkFVTFRfTUlOX0xFQURfVElNRV9NSU5VVEVTO1xuICAgIH1cbiAgICBpZiAobWF4QWR2YW5jZURheXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbWF4QWR2YW5jZSA9IGJ1c2luZXNzLm1heF9hZHZhbmNlX2RheXMgPz8gREVGQVVMVF9NQVhfQURWQU5DRV9EQVlTO1xuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlIHRoZSBkYXRlIGluIHRoZSBidXNpbmVzcyB0aW1lem9uZSBhbmQgZ2V0IHdlZWtkYXkgKDAtNiwgU3VuZGF5PTApXG4gIC8vIENyZWF0ZSBhIGRhdGUgc3RyaW5nIGF0IG1pZG5pZ2h0IGluIGJ1c2luZXNzIHRpbWV6b25lLCBjb252ZXJ0IHRvIFVUQywgdGhlbiBiYWNrIHRvIGJ1c2luZXNzIHRpbWV6b25lIHRvIGdldCBjb3JyZWN0IHdlZWtkYXlcbiAgY29uc3QgdGFyZ2V0RGF0ZVN0ciA9IGAke2RhdGV9VDAwOjAwOjAwYDtcbiAgLy8gUGFyc2UgYXMgaWYgaW4gYnVzaW5lc3MgdGltZXpvbmUsIHRoZW4gY29udmVydCB0byBVVEMgRGF0ZVxuICBjb25zdCB0YXJnZXREYXRlTG9jYWwgPSBuZXcgRGF0ZSh0YXJnZXREYXRlU3RyKTtcbiAgXG4gIC8vIFZhbGlkYXRlIGlucHV0IGRhdGVcbiAgaWYgKGlzTmFOKHRhcmdldERhdGVMb2NhbC5nZXRUaW1lKCkpKSB7XG4gICAgY29uc29sZS5lcnJvcihgW2F2YWlsYWJpbGl0eV0gSW52YWxpZCBkYXRlIHN0cmluZzogJHt0YXJnZXREYXRlU3RyfWApO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBcbiAgLy8gVmFsaWRhdGUgdGltZXpvbmVcbiAgaWYgKCF0aW1lem9uZSB8fCB0eXBlb2YgdGltZXpvbmUgIT09ICdzdHJpbmcnKSB7XG4gICAgY29uc29sZS5lcnJvcihgW2F2YWlsYWJpbGl0eV0gSW52YWxpZCB0aW1lem9uZTogJHt0aW1lem9uZX1gKTtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgXG4gIGxldCB0YXJnZXREYXRlVVRDOiBEYXRlO1xuICB0cnkge1xuICAgIHRhcmdldERhdGVVVEMgPSBmcm9tWm9uZWRUaW1lKHRhcmdldERhdGVMb2NhbCwgdGltZXpvbmUpO1xuICAgIFxuICAgIC8vIFZhbGlkYXRlIGNvbnZlcnRlZCBkYXRlXG4gICAgaWYgKGlzTmFOKHRhcmdldERhdGVVVEMuZ2V0VGltZSgpKSkge1xuICAgICAgY29uc29sZS5lcnJvcihgW2F2YWlsYWJpbGl0eV0gSW52YWxpZCBkYXRlIGFmdGVyIHRpbWV6b25lIGNvbnZlcnNpb246YCwge1xuICAgICAgICBkYXRlLFxuICAgICAgICB0YXJnZXREYXRlU3RyLFxuICAgICAgICB0aW1lem9uZSxcbiAgICAgICAgdGFyZ2V0RGF0ZUxvY2FsOiB0YXJnZXREYXRlTG9jYWwudG9JU09TdHJpbmcoKSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBbYXZhaWxhYmlsaXR5XSBFcnJvciBjb252ZXJ0aW5nIHRpbWV6b25lOmAsIGVycm9yLCB7XG4gICAgICBkYXRlLFxuICAgICAgdGFyZ2V0RGF0ZVN0cixcbiAgICAgIHRpbWV6b25lLFxuICAgIH0pO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBcbiAgY29uc3QgdGFyZ2V0RGF0ZUluVGltZXpvbmUgPSB0b1pvbmVkVGltZSh0YXJnZXREYXRlVVRDLCB0aW1lem9uZSk7XG4gIGNvbnN0IHdlZWtkYXkgPSB0YXJnZXREYXRlSW5UaW1lem9uZS5nZXREYXkoKTsgLy8gR2V0IHdlZWtkYXkgaW4gYnVzaW5lc3MgdGltZXpvbmVcblxuICAvLyBHZXQgc2VydmljZSBkdXJhdGlvblxuICBjb25zdCB7IGRhdGE6IHNlcnZpY2UgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3NlcnZpY2VzJylcbiAgICAuc2VsZWN0KCdkdXJhdGlvbl9taW4nKVxuICAgIC5lcSgnaWQnLCBzZXJ2aWNlSWQpXG4gICAgLnNpbmdsZSgpO1xuXG4gIGlmICghc2VydmljZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2VydmljZSBub3QgZm91bmQnKTtcbiAgfVxuXG4gIGNvbnN0IHNlcnZpY2VEdXJhdGlvbk1pbnV0ZXMgPSBzZXJ2aWNlLmR1cmF0aW9uX21pbjtcblxuICAvLyBGaXJzdCwgdHJ5IHRvIGdldCBzdGFmZiBmcm9tIHN0YWZmX3NlcnZpY2VzIGFzc29jaWF0aW9uc1xuICBsZXQgc3RhZmZJZHM6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IHsgZGF0YTogc3RhZmZTZXJ2aWNlcyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgnc3RhZmZfc2VydmljZXMnKVxuICAgIC5zZWxlY3QoJ3N0YWZmX2lkJylcbiAgICAuZXEoJ3NlcnZpY2VfaWQnLCBzZXJ2aWNlSWQpXG4gICAgLmVxKCdidXNpbmVzc19pZCcsIGJ1c2luZXNzSWQpO1xuXG4gIGlmIChzdGFmZlNlcnZpY2VzICYmIHN0YWZmU2VydmljZXMubGVuZ3RoID4gMCkge1xuICAgIHN0YWZmSWRzID0gc3RhZmZTZXJ2aWNlcy5tYXAoc3MgPT4gc3Muc3RhZmZfaWQpO1xuICAgIGNvbnNvbGUubG9nKGBbYXZhaWxhYmlsaXR5XSBGb3VuZCAke3N0YWZmSWRzLmxlbmd0aH0gc3RhZmYgZnJvbSBzdGFmZl9zZXJ2aWNlcyBmb3Igc2VydmljZSAke3NlcnZpY2VJZH1gKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBubyBzdGFmZl9zZXJ2aWNlcyBhc3NvY2lhdGlvbnMgZXhpc3QsIGdldCBzdGFmZiBmcm9tIGF2YWlsYWJpbGl0eV9ydWxlcyBkaXJlY3RseVxuICAgIC8vIFRoaXMgaGFuZGxlcyBjYXNlcyB3aGVyZSBzdGFmZiBhc3NvY2lhdGlvbnMgd2VyZW4ndCBjcmVhdGVkIGR1cmluZyBvbmJvYXJkaW5nXG4gICAgY29uc29sZS5sb2coYFthdmFpbGFiaWxpdHldIE5vIHN0YWZmX3NlcnZpY2VzIGZvdW5kLCBjaGVja2luZyBhdmFpbGFiaWxpdHlfcnVsZXMgZm9yIHNlcnZpY2UgJHtzZXJ2aWNlSWR9YCk7XG4gICAgY29uc3QgeyBkYXRhOiBydWxlc1dpdGhTdGFmZiB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdhdmFpbGFiaWxpdHlfcnVsZXMnKVxuICAgICAgLnNlbGVjdCgnc3RhZmZfaWQnKVxuICAgICAgLmVxKCdidXNpbmVzc19pZCcsIGJ1c2luZXNzSWQpXG4gICAgICAuZXEoJ3NlcnZpY2VfaWQnLCBzZXJ2aWNlSWQpXG4gICAgICAuZXEoJ3J1bGVfdHlwZScsICd3ZWVrbHknKVxuICAgICAgLmlzKCdkZWxldGVkX2F0JywgbnVsbCk7XG4gICAgXG4gICAgaWYgKHJ1bGVzV2l0aFN0YWZmICYmIHJ1bGVzV2l0aFN0YWZmLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIEdldCB1bmlxdWUgc3RhZmYgSURzIGZyb20gcnVsZXNcbiAgICAgIGNvbnN0IHVuaXF1ZVN0YWZmSWRzID0gWy4uLm5ldyBTZXQocnVsZXNXaXRoU3RhZmYubWFwKHIgPT4gci5zdGFmZl9pZCkpXTtcbiAgICAgIHN0YWZmSWRzID0gdW5pcXVlU3RhZmZJZHM7XG4gICAgICBjb25zb2xlLmxvZyhgW2F2YWlsYWJpbGl0eV0gRm91bmQgJHtzdGFmZklkcy5sZW5ndGh9IHN0YWZmIGZyb20gYXZhaWxhYmlsaXR5X3J1bGVzIGZvciBzZXJ2aWNlICR7c2VydmljZUlkfWApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFmZklkcy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zb2xlLmxvZyhgW2F2YWlsYWJpbGl0eV0gTm8gc3RhZmYgZm91bmQgZm9yIHNlcnZpY2UgJHtzZXJ2aWNlSWR9YCk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLy8gR2V0IHN0YWZmIG5hbWVzXG4gIGNvbnN0IHsgZGF0YTogc3RhZmZMaXN0IH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdzdGFmZicpXG4gICAgLnNlbGVjdCgnaWQsIG5hbWUnKVxuICAgIC5pbignaWQnLCBzdGFmZklkcylcbiAgICAuZXEoJ2J1c2luZXNzX2lkJywgYnVzaW5lc3NJZClcbiAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG4gICAgLmlzKCdkZWxldGVkX2F0JywgbnVsbCk7XG5cbiAgaWYgKCFzdGFmZkxpc3QgfHwgc3RhZmZMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGUubG9nKGBbYXZhaWxhYmlsaXR5XSBObyBhY3RpdmUgc3RhZmYgZm91bmQgZm9yIElEczpgLCBzdGFmZklkcyk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3Qgc3RhZmZNYXAgPSBuZXcgTWFwKHN0YWZmTGlzdC5tYXAocyA9PiBbcy5pZCwgcy5uYW1lXSkpO1xuICBjb25zb2xlLmxvZyhgW2F2YWlsYWJpbGl0eV0gU3RhZmYgbWFwOmAsIEFycmF5LmZyb20oc3RhZmZNYXAuZW50cmllcygpKSk7XG5cbiAgLy8gR2V0IGF2YWlsYWJpbGl0eSBydWxlcyBmb3IgdGhpcyBzZXJ2aWNlLCBzdGFmZiwgYW5kIHdlZWtkYXlcbiAgLy8gQWxzbyBmaWx0ZXIgYnkgYnVzaW5lc3NfaWQgdG8gZW5zdXJlIHdlIGdldCB0aGUgcmlnaHQgcnVsZXNcbiAgY29uc3QgeyBkYXRhOiBydWxlcywgZXJyb3I6IHJ1bGVzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ2F2YWlsYWJpbGl0eV9ydWxlcycpXG4gICAgLnNlbGVjdCgnc3RhZmZfaWQsIHdlZWtkYXksIHN0YXJ0X3RpbWUsIGVuZF90aW1lJylcbiAgICAuZXEoJ2J1c2luZXNzX2lkJywgYnVzaW5lc3NJZClcbiAgICAuZXEoJ3NlcnZpY2VfaWQnLCBzZXJ2aWNlSWQpXG4gICAgLmluKCdzdGFmZl9pZCcsIHN0YWZmSWRzLmxlbmd0aCA+IDAgPyBzdGFmZklkcyA6IFsnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJ10pIC8vIFByZXZlbnQgZW1wdHkgYXJyYXlcbiAgICAuZXEoJ3dlZWtkYXknLCB3ZWVrZGF5KVxuICAgIC5lcSgncnVsZV90eXBlJywgJ3dlZWtseScpXG4gICAgLmlzKCdkZWxldGVkX2F0JywgbnVsbCk7XG5cbiAgaWYgKHJ1bGVzRXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBbYXZhaWxhYmlsaXR5XSBFcnJvciBmZXRjaGluZyBydWxlcyBmb3IgJHtkYXRlfTpgLCBydWxlc0Vycm9yKTtcbiAgfVxuXG4gIGlmICghcnVsZXMgfHwgcnVsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc29sZS5sb2coYFthdmFpbGFiaWxpdHldIE5vIHJ1bGVzIGZvdW5kIGZvciBzZXJ2aWNlICR7c2VydmljZUlkfSwgZGF0ZSAke2RhdGV9LCB3ZWVrZGF5ICR7d2Vla2RheX0sIHN0YWZmSWRzOmAsIHN0YWZmSWRzKTtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zb2xlLmxvZyhgW2F2YWlsYWJpbGl0eV0gRm91bmQgJHtydWxlcy5sZW5ndGh9IHJ1bGVzIGZvciBzZXJ2aWNlICR7c2VydmljZUlkfSwgZGF0ZSAke2RhdGV9LCB3ZWVrZGF5ICR7d2Vla2RheX1gKTtcblxuICAvLyBHZXQgYmxhY2tvdXRzIGZvciB0aGlzIGRhdGUgKHN0YWZmLXNwZWNpZmljIGFuZCBnbG9iYWwpXG4gIGNvbnN0IGRheVN0YXJ0ID0gbmV3IERhdGUoYCR7ZGF0ZX1UMDA6MDA6MDBaYCk7XG4gIGNvbnN0IGRheUVuZCA9IG5ldyBEYXRlKGAke2RhdGV9VDIzOjU5OjU5WmApO1xuXG4gIGNvbnN0IHsgZGF0YTogYmxhY2tvdXRzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdibGFja291dHMnKVxuICAgIC5zZWxlY3QoJ3N0YWZmX2lkLCBzdGFydF9hdCwgZW5kX2F0JylcbiAgICAuZXEoJ2J1c2luZXNzX2lkJywgYnVzaW5lc3NJZClcbiAgICAubHRlKCdzdGFydF9hdCcsIGRheUVuZC50b0lTT1N0cmluZygpKVxuICAgIC5ndGUoJ2VuZF9hdCcsIGRheVN0YXJ0LnRvSVNPU3RyaW5nKCkpXG4gICAgLmlzKCdkZWxldGVkX2F0JywgbnVsbCk7XG5cbiAgLy8gR2V0IGV4aXN0aW5nIGJvb2tpbmdzIGZvciB0aGlzIGRhdGUgYW5kIHN0YWZmXG4gIGNvbnN0IHsgZGF0YTogYm9va2luZ3MgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ2Jvb2tpbmdzJylcbiAgICAuc2VsZWN0KCdzdGFmZl9pZCwgc3RhcnRfYXQsIGVuZF9hdCcpXG4gICAgLmVxKCdidXNpbmVzc19pZCcsIGJ1c2luZXNzSWQpXG4gICAgLmluKCdzdGFmZl9pZCcsIHN0YWZmSWRzKVxuICAgIC5ndGUoJ3N0YXJ0X2F0JywgZGF5U3RhcnQudG9JU09TdHJpbmcoKSlcbiAgICAubHRlKCdzdGFydF9hdCcsIGRheUVuZC50b0lTT1N0cmluZygpKVxuICAgIC5pbignc3RhdHVzJywgWydwZW5kaW5nJywgJ3NjaGVkdWxlZCcsICdoZWxkJ10pXG4gICAgLmlzKCdkZWxldGVkX2F0JywgbnVsbCk7XG5cbiAgLy8gSGVscGVyIHRvIGNoZWNrIGlmIGEgdGltZSBvdmVybGFwcyB3aXRoIGJsYWNrb3V0c1xuICBjb25zdCBpc0luQmxhY2tvdXQgPSAoc3RhcnQ6IERhdGUsIGVuZDogRGF0ZSwgc3RhZmZJZDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKCFibGFja291dHMpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gYmxhY2tvdXRzLnNvbWUoYmxhY2tvdXQgPT4ge1xuICAgICAgLy8gR2xvYmFsIGJsYWNrb3V0IChzdGFmZl9pZCBpcyBudWxsKVxuICAgICAgaWYgKCFibGFja291dC5zdGFmZl9pZCkge1xuICAgICAgICByZXR1cm4gc3RhcnQgPCBuZXcgRGF0ZShibGFja291dC5lbmRfYXQpICYmIGVuZCA+IG5ldyBEYXRlKGJsYWNrb3V0LnN0YXJ0X2F0KTtcbiAgICAgIH1cbiAgICAgIC8vIFN0YWZmLXNwZWNpZmljIGJsYWNrb3V0XG4gICAgICBpZiAoYmxhY2tvdXQuc3RhZmZfaWQgPT09IHN0YWZmSWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0IDwgbmV3IERhdGUoYmxhY2tvdXQuZW5kX2F0KSAmJiBlbmQgPiBuZXcgRGF0ZShibGFja291dC5zdGFydF9hdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gSGVscGVyIHRvIGNoZWNrIGlmIGEgdGltZSBvdmVybGFwcyB3aXRoIGV4aXN0aW5nIGJvb2tpbmdzXG4gIGNvbnN0IGlzT3ZlcmxhcHBpbmdCb29raW5nID0gKHN0YXJ0OiBEYXRlLCBlbmQ6IERhdGUsIHN0YWZmSWQ6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIGlmICghYm9va2luZ3MpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gYm9va2luZ3Muc29tZShib29raW5nID0+IHtcbiAgICAgIGlmIChib29raW5nLnN0YWZmX2lkID09PSBzdGFmZklkKSB7XG4gICAgICAgIGNvbnN0IGJvb2tpbmdTdGFydCA9IG5ldyBEYXRlKGJvb2tpbmcuc3RhcnRfYXQpO1xuICAgICAgICBjb25zdCBib29raW5nRW5kID0gbmV3IERhdGUoYm9va2luZy5lbmRfYXQpO1xuICAgICAgICByZXR1cm4gc3RhcnQgPCBib29raW5nRW5kICYmIGVuZCA+IGJvb2tpbmdTdGFydDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBzbG90czogQXZhaWxhYmlsaXR5U2xvdFtdID0gW107XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gIGNvbnN0IG1pblN0YXJ0VGltZSA9IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgKyBtaW5MZWFkVGltZSAqIDYwICogMTAwMCk7XG4gIGNvbnN0IG1heEFkdmFuY2VEYXRlID0gbmV3IERhdGUobm93LmdldFRpbWUoKSArIG1heEFkdmFuY2UgKiAyNCAqIDYwICogNjAgKiAxMDAwKTtcblxuICAvLyBWYWxpZGF0ZSB0YXJnZXREYXRlVVRDIGJlZm9yZSBsb2dnaW5nXG4gIGNvbnN0IHRhcmdldERhdGVVVENTdHIgPSBpc05hTih0YXJnZXREYXRlVVRDLmdldFRpbWUoKSkgPyAnSW52YWxpZCBEYXRlJyA6IHRhcmdldERhdGVVVEMudG9JU09TdHJpbmcoKTtcbiAgXG4gIGNvbnNvbGUubG9nKGBbYXZhaWxhYmlsaXR5XSBTbG90IGdlbmVyYXRpb24gcGFyYW1zOmAsIHtcbiAgICBkYXRlLFxuICAgIHdlZWtkYXksXG4gICAgbm93OiBub3cudG9JU09TdHJpbmcoKSxcbiAgICBtaW5TdGFydFRpbWU6IG1pblN0YXJ0VGltZS50b0lTT1N0cmluZygpLFxuICAgIG1heEFkdmFuY2VEYXRlOiBtYXhBZHZhbmNlRGF0ZS50b0lTT1N0cmluZygpLFxuICAgIHRhcmdldERhdGVVVEM6IHRhcmdldERhdGVVVENTdHIsXG4gICAgbWluTGVhZFRpbWUsXG4gICAgbWF4QWR2YW5jZSxcbiAgICBydWxlc0NvdW50OiBydWxlcy5sZW5ndGgsXG4gIH0pO1xuICBcbiAgLy8gSWYgdGFyZ2V0RGF0ZVVUQyBpcyBpbnZhbGlkLCByZXR1cm4gZWFybHlcbiAgaWYgKGlzTmFOKHRhcmdldERhdGVVVEMuZ2V0VGltZSgpKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYFthdmFpbGFiaWxpdHldIEludmFsaWQgdGFyZ2V0RGF0ZVVUQyBmb3IgZGF0ZSAke2RhdGV9LCB0aW1lem9uZSAke3RpbWV6b25lfWApO1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIElmIHRoZSB0YXJnZXQgZGF0ZSBpcyB0b28gZmFyIGluIGFkdmFuY2UsIHJldHVybiBlbXB0eVxuICAvLyBVc2UgVVRDIGRhdGUgZm9yIGNvbXBhcmlzb25cbiAgY29uc3QgdGFyZ2V0RGF0ZVVUQ0ZvckNvbXBhcmlzb24gPSB0YXJnZXREYXRlVVRDO1xuICBpZiAodGFyZ2V0RGF0ZVVUQ0ZvckNvbXBhcmlzb24gPiBtYXhBZHZhbmNlRGF0ZSkge1xuICAgIGNvbnNvbGUubG9nKGBbYXZhaWxhYmlsaXR5XSBUYXJnZXQgZGF0ZSAke3RhcmdldERhdGVVVENGb3JDb21wYXJpc29uLnRvSVNPU3RyaW5nKCl9IGlzIGJleW9uZCBtYXggYWR2YW5jZSBkYXRlICR7bWF4QWR2YW5jZURhdGUudG9JU09TdHJpbmcoKX1gKTtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBsZXQgdG90YWxTbG90c0NoZWNrZWQgPSAwO1xuICBsZXQgc2xvdHNGaWx0ZXJlZEJ5TGVhZFRpbWUgPSAwO1xuICBsZXQgc2xvdHNGaWx0ZXJlZEJ5UGFzdCA9IDA7XG4gIGxldCBzbG90c0ZpbHRlcmVkQnlCbGFja291dCA9IDA7XG4gIGxldCBzbG90c0ZpbHRlcmVkQnlCb29raW5nID0gMDtcblxuICAvLyBQcm9jZXNzIGVhY2ggcnVsZVxuICBmb3IgKGNvbnN0IHJ1bGUgb2YgcnVsZXMpIHtcbiAgICBjb25zdCBzdGFmZklkID0gcnVsZS5zdGFmZl9pZDtcbiAgICBjb25zdCBzdGFmZk5hbWUgPSBzdGFmZk1hcC5nZXQoc3RhZmZJZCk7XG4gICAgaWYgKCFzdGFmZk5hbWUpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbYXZhaWxhYmlsaXR5XSBTa2lwcGluZyBydWxlIC0gc3RhZmYgbmFtZSBub3QgZm91bmQgZm9yICR7c3RhZmZJZH1gKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIHN0YXJ0X3RpbWUgYW5kIGVuZF90aW1lIChISDptbSBmb3JtYXQgaW4gYnVzaW5lc3MgdGltZXpvbmUpXG4gICAgLy8gUGFyc2UgZGF0ZSBjb21wb25lbnRzXG4gICAgY29uc3QgW3llYXIsIG1vbnRoLCBkYXldID0gZGF0ZS5zcGxpdCgnLScpLm1hcChOdW1iZXIpO1xuICAgIGNvbnN0IFtzdGFydEhvdXIsIHN0YXJ0TWluXSA9IHJ1bGUuc3RhcnRfdGltZS5zcGxpdCgnOicpLm1hcChOdW1iZXIpO1xuICAgIGNvbnN0IFtlbmRIb3VyLCBlbmRNaW5dID0gcnVsZS5lbmRfdGltZS5zcGxpdCgnOicpLm1hcChOdW1iZXIpO1xuICAgIFxuICAgIC8vIFZhbGlkYXRlIHRpbWV6b25lXG4gICAgaWYgKCF0aW1lem9uZSB8fCB0eXBlb2YgdGltZXpvbmUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBbYXZhaWxhYmlsaXR5XSBJbnZhbGlkIHRpbWV6b25lOmAsIHRpbWV6b25lKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBDcmVhdGUgYSBkYXRlIHN0cmluZyBpbiBJU08gZm9ybWF0LCB0aGVuIHBhcnNlIGl0XG4gICAgLy8gVGhlIGtleTogd2UgY3JlYXRlIHRoZSBkYXRlIGFzIGlmIGl0J3MgaW4gVVRDLCB0aGVuIHVzZSBmcm9tWm9uZWRUaW1lIHRvIHRyZWF0IGl0IGFzIGJ1c2luZXNzIHRpbWV6b25lXG4gICAgY29uc3QgcnVsZVN0YXJ0U3RyID0gYCR7eWVhcn0tJHtTdHJpbmcobW9udGgpLnBhZFN0YXJ0KDIsICcwJyl9LSR7U3RyaW5nKGRheSkucGFkU3RhcnQoMiwgJzAnKX1UJHtTdHJpbmcoc3RhcnRIb3VyKS5wYWRTdGFydCgyLCAnMCcpfToke1N0cmluZyhzdGFydE1pbikucGFkU3RhcnQoMiwgJzAnKX06MDBgO1xuICAgIGNvbnN0IHJ1bGVFbmRTdHIgPSBgJHt5ZWFyfS0ke1N0cmluZyhtb250aCkucGFkU3RhcnQoMiwgJzAnKX0tJHtTdHJpbmcoZGF5KS5wYWRTdGFydCgyLCAnMCcpfVQke1N0cmluZyhlbmRIb3VyKS5wYWRTdGFydCgyLCAnMCcpfToke1N0cmluZyhlbmRNaW4pLnBhZFN0YXJ0KDIsICcwJyl9OjAwYDtcbiAgICBcbiAgICAvLyBDcmVhdGUgRGF0ZSBvYmplY3RzIC0gdGhlc2UgcmVwcmVzZW50IHRoZSB3YWxsLWNsb2NrIHRpbWVcbiAgICAvLyBXZSdsbCB0cmVhdCB0aGVtIGFzIGlmIHRoZXkncmUgaW4gdGhlIGJ1c2luZXNzIHRpbWV6b25lXG4gICAgY29uc3QgcnVsZVN0YXJ0TG9jYWwgPSBuZXcgRGF0ZShydWxlU3RhcnRTdHIpO1xuICAgIGNvbnN0IHJ1bGVFbmRMb2NhbCA9IG5ldyBEYXRlKHJ1bGVFbmRTdHIpO1xuICAgIFxuICAgIC8vIFZhbGlkYXRlIGlucHV0IGRhdGVzXG4gICAgaWYgKGlzTmFOKHJ1bGVTdGFydExvY2FsLmdldFRpbWUoKSkgfHwgaXNOYU4ocnVsZUVuZExvY2FsLmdldFRpbWUoKSkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFthdmFpbGFiaWxpdHldIEludmFsaWQgZGF0ZSBjcmVhdGVkIGZyb206YCwge1xuICAgICAgICBydWxlU3RhcnRTdHIsXG4gICAgICAgIHJ1bGVFbmRTdHIsXG4gICAgICAgIGRhdGUsXG4gICAgICAgIHN0YXJ0VGltZTogcnVsZS5zdGFydF90aW1lLFxuICAgICAgICBlbmRUaW1lOiBydWxlLmVuZF90aW1lLFxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gZnJvbVpvbmVkVGltZTogdHJlYXRzIHRoZSBpbnB1dCBEYXRlIGFzIHJlcHJlc2VudGluZyBhIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLFxuICAgIC8vIGFuZCByZXR1cm5zIHRoZSBlcXVpdmFsZW50IERhdGUgaW4gVVRDXG4gICAgbGV0IHJ1bGVTdGFydFVUQzogRGF0ZTtcbiAgICBsZXQgcnVsZUVuZFVUQzogRGF0ZTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgcnVsZVN0YXJ0VVRDID0gZnJvbVpvbmVkVGltZShydWxlU3RhcnRMb2NhbCwgdGltZXpvbmUpO1xuICAgICAgcnVsZUVuZFVUQyA9IGZyb21ab25lZFRpbWUocnVsZUVuZExvY2FsLCB0aW1lem9uZSk7XG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBjb252ZXJ0ZWQgZGF0ZXNcbiAgICAgIGlmIChpc05hTihydWxlU3RhcnRVVEMuZ2V0VGltZSgpKSB8fCBpc05hTihydWxlRW5kVVRDLmdldFRpbWUoKSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgW2F2YWlsYWJpbGl0eV0gSW52YWxpZCBkYXRlIGFmdGVyIHRpbWV6b25lIGNvbnZlcnNpb246YCwge1xuICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgc3RhcnRUaW1lOiBydWxlLnN0YXJ0X3RpbWUsXG4gICAgICAgICAgZW5kVGltZTogcnVsZS5lbmRfdGltZSxcbiAgICAgICAgICB0aW1lem9uZSxcbiAgICAgICAgICBydWxlU3RhcnRMb2NhbDogcnVsZVN0YXJ0TG9jYWwudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBydWxlRW5kTG9jYWw6IHJ1bGVFbmRMb2NhbC50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFthdmFpbGFiaWxpdHldIEVycm9yIGNvbnZlcnRpbmcgdGltZXpvbmUgZm9yIHJ1bGU6YCwgZXJyb3IsIHtcbiAgICAgICAgZGF0ZSxcbiAgICAgICAgc3RhcnRUaW1lOiBydWxlLnN0YXJ0X3RpbWUsXG4gICAgICAgIGVuZFRpbWU6IHJ1bGUuZW5kX3RpbWUsXG4gICAgICAgIHRpbWV6b25lLFxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgW2F2YWlsYWJpbGl0eV0gUHJvY2Vzc2luZyBydWxlOmAsIHtcbiAgICAgIHN0YWZmSWQsXG4gICAgICBzdGFmZk5hbWUsXG4gICAgICBzdGFydFRpbWU6IHJ1bGUuc3RhcnRfdGltZSxcbiAgICAgIGVuZFRpbWU6IHJ1bGUuZW5kX3RpbWUsXG4gICAgICBydWxlU3RhcnRVVEM6IHJ1bGVTdGFydFVUQy50b0lTT1N0cmluZygpLFxuICAgICAgcnVsZUVuZFVUQzogcnVsZUVuZFVUQy50b0lTT1N0cmluZygpLFxuICAgIH0pO1xuXG4gICAgLy8gV2FsayBpbiAxNS1taW51dGUgaW5jcmVtZW50cyAod29ya2luZyBpbiBVVEMpXG4gICAgbGV0IGN1cnJlbnRTdGFydCA9IG5ldyBEYXRlKHJ1bGVTdGFydFVUQyk7XG4gICAgY29uc3QgcnVsZUVuZFRpbWUgPSBuZXcgRGF0ZShydWxlRW5kVVRDKTtcblxuICAgIHdoaWxlIChjdXJyZW50U3RhcnQgPCBydWxlRW5kVGltZSkge1xuICAgICAgY29uc3Qgc2xvdEVuZCA9IG5ldyBEYXRlKGN1cnJlbnRTdGFydC5nZXRUaW1lKCkgKyBzZXJ2aWNlRHVyYXRpb25NaW51dGVzICogNjAgKiAxMDAwKTtcbiAgICAgIHRvdGFsU2xvdHNDaGVja2VkKys7XG5cbiAgICAgIC8vIENoZWNrIGlmIHNsb3QgZml0cyB3aXRoaW4gcnVsZSBlbmQgdGltZVxuICAgICAgaWYgKHNsb3RFbmQgPiBydWxlRW5kVGltZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgbGVhZCB0aW1lIChtdXN0IGJlIGFmdGVyIG1pbmltdW0gbGVhZCB0aW1lIGZyb20gbm93KVxuICAgICAgaWYgKGN1cnJlbnRTdGFydCA8IG1pblN0YXJ0VGltZSkge1xuICAgICAgICBzbG90c0ZpbHRlcmVkQnlMZWFkVGltZSsrO1xuICAgICAgICBjdXJyZW50U3RhcnQgPSBuZXcgRGF0ZShjdXJyZW50U3RhcnQuZ2V0VGltZSgpICsgU0xPVF9EVVJBVElPTl9NSU5VVEVTICogNjAgKiAxMDAwKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHNsb3QgaXMgaW4gdGhlIHBhc3RcbiAgICAgIGlmIChjdXJyZW50U3RhcnQgPCBub3cpIHtcbiAgICAgICAgc2xvdHNGaWx0ZXJlZEJ5UGFzdCsrO1xuICAgICAgICBjdXJyZW50U3RhcnQgPSBuZXcgRGF0ZShjdXJyZW50U3RhcnQuZ2V0VGltZSgpICsgU0xPVF9EVVJBVElPTl9NSU5VVEVTICogNjAgKiAxMDAwKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGJsYWNrb3V0c1xuICAgICAgaWYgKGlzSW5CbGFja291dChjdXJyZW50U3RhcnQsIHNsb3RFbmQsIHN0YWZmSWQpKSB7XG4gICAgICAgIHNsb3RzRmlsdGVyZWRCeUJsYWNrb3V0Kys7XG4gICAgICAgIGN1cnJlbnRTdGFydCA9IG5ldyBEYXRlKGN1cnJlbnRTdGFydC5nZXRUaW1lKCkgKyBTTE9UX0RVUkFUSU9OX01JTlVURVMgKiA2MCAqIDEwMDApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZXhpc3RpbmcgYm9va2luZ3NcbiAgICAgIGlmIChpc092ZXJsYXBwaW5nQm9va2luZyhjdXJyZW50U3RhcnQsIHNsb3RFbmQsIHN0YWZmSWQpKSB7XG4gICAgICAgIHNsb3RzRmlsdGVyZWRCeUJvb2tpbmcrKztcbiAgICAgICAgY3VycmVudFN0YXJ0ID0gbmV3IERhdGUoY3VycmVudFN0YXJ0LmdldFRpbWUoKSArIFNMT1RfRFVSQVRJT05fTUlOVVRFUyAqIDYwICogMTAwMCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBWYWxpZCBzbG90IC0gZW5zdXJlIHRpbWVzIGFyZSBpbiBVVEMgSVNPIGZvcm1hdFxuICAgICAgc2xvdHMucHVzaCh7XG4gICAgICAgIHN0YWZmX2lkOiBzdGFmZklkLFxuICAgICAgICBzdGFmZl9uYW1lOiBzdGFmZk5hbWUsXG4gICAgICAgIHN0YXJ0X2F0OiBuZXcgRGF0ZShjdXJyZW50U3RhcnQpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGVuZF9hdDogbmV3IERhdGUoc2xvdEVuZCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb3ZlIHRvIG5leHQgMTUtbWludXRlIHNsb3RcbiAgICAgIGN1cnJlbnRTdGFydCA9IG5ldyBEYXRlKGN1cnJlbnRTdGFydC5nZXRUaW1lKCkgKyBTTE9UX0RVUkFUSU9OX01JTlVURVMgKiA2MCAqIDEwMDApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnNvbGUubG9nKGBbYXZhaWxhYmlsaXR5XSBTbG90IGdlbmVyYXRpb24gc3VtbWFyeTpgLCB7XG4gICAgdG90YWxTbG90c0NoZWNrZWQsXG4gICAgc2xvdHNHZW5lcmF0ZWQ6IHNsb3RzLmxlbmd0aCxcbiAgICBmaWx0ZXJlZEJ5TGVhZFRpbWU6IHNsb3RzRmlsdGVyZWRCeUxlYWRUaW1lLFxuICAgIGZpbHRlcmVkQnlQYXN0OiBzbG90c0ZpbHRlcmVkQnlQYXN0LFxuICAgIGZpbHRlcmVkQnlCbGFja291dDogc2xvdHNGaWx0ZXJlZEJ5QmxhY2tvdXQsXG4gICAgZmlsdGVyZWRCeUJvb2tpbmc6IHNsb3RzRmlsdGVyZWRCeUJvb2tpbmcsXG4gIH0pO1xuXG4gIC8vIFNvcnQgc2xvdHMgYnkgc3RhcnQgdGltZVxuICBzbG90cy5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShhLnN0YXJ0X2F0KS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShiLnN0YXJ0X2F0KS5nZXRUaW1lKCkpO1xuXG4gIHJldHVybiBzbG90cztcbn1cblxuXG4iXSwibmFtZXMiOlsiY3JlYXRlQWRtaW5DbGllbnQiLCJmcm9tWm9uZWRUaW1lIiwidG9ab25lZFRpbWUiLCJTTE9UX0RVUkFUSU9OX01JTlVURVMiLCJERUZBVUxUX01JTl9MRUFEX1RJTUVfTUlOVVRFUyIsIkRFRkFVTFRfTUFYX0FEVkFOQ0VfREFZUyIsImdlbmVyYXRlQXZhaWxhYmlsaXR5U2xvdHMiLCJwYXJhbXMiLCJzZXJ2aWNlSWQiLCJkYXRlIiwiYnVzaW5lc3NJZCIsInVzZXJJZCIsImJ1c2luZXNzVGltZXpvbmUiLCJtaW5MZWFkVGltZU1pbnV0ZXMiLCJtYXhBZHZhbmNlRGF5cyIsInN1cGFiYXNlIiwidGltZXpvbmUiLCJtaW5MZWFkVGltZSIsIm1heEFkdmFuY2UiLCJ1bmRlZmluZWQiLCJkYXRhIiwiYnVzaW5lc3MiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJzaW5nbGUiLCJFcnJvciIsIm1pbl9sZWFkX3RpbWVfbWludXRlcyIsIm1heF9hZHZhbmNlX2RheXMiLCJ0YXJnZXREYXRlU3RyIiwidGFyZ2V0RGF0ZUxvY2FsIiwiRGF0ZSIsImlzTmFOIiwiZ2V0VGltZSIsImNvbnNvbGUiLCJlcnJvciIsInRhcmdldERhdGVVVEMiLCJ0b0lTT1N0cmluZyIsInRhcmdldERhdGVJblRpbWV6b25lIiwid2Vla2RheSIsImdldERheSIsInNlcnZpY2UiLCJzZXJ2aWNlRHVyYXRpb25NaW51dGVzIiwiZHVyYXRpb25fbWluIiwic3RhZmZJZHMiLCJzdGFmZlNlcnZpY2VzIiwibGVuZ3RoIiwibWFwIiwic3MiLCJzdGFmZl9pZCIsImxvZyIsInJ1bGVzV2l0aFN0YWZmIiwiaXMiLCJ1bmlxdWVTdGFmZklkcyIsIlNldCIsInIiLCJzdGFmZkxpc3QiLCJpbiIsInN0YWZmTWFwIiwiTWFwIiwicyIsImlkIiwibmFtZSIsIkFycmF5IiwiZW50cmllcyIsInJ1bGVzIiwicnVsZXNFcnJvciIsImRheVN0YXJ0IiwiZGF5RW5kIiwiYmxhY2tvdXRzIiwibHRlIiwiZ3RlIiwiYm9va2luZ3MiLCJpc0luQmxhY2tvdXQiLCJzdGFydCIsImVuZCIsInN0YWZmSWQiLCJzb21lIiwiYmxhY2tvdXQiLCJlbmRfYXQiLCJzdGFydF9hdCIsImlzT3ZlcmxhcHBpbmdCb29raW5nIiwiYm9va2luZyIsImJvb2tpbmdTdGFydCIsImJvb2tpbmdFbmQiLCJzbG90cyIsIm5vdyIsIm1pblN0YXJ0VGltZSIsIm1heEFkdmFuY2VEYXRlIiwidGFyZ2V0RGF0ZVVUQ1N0ciIsInJ1bGVzQ291bnQiLCJ0YXJnZXREYXRlVVRDRm9yQ29tcGFyaXNvbiIsInRvdGFsU2xvdHNDaGVja2VkIiwic2xvdHNGaWx0ZXJlZEJ5TGVhZFRpbWUiLCJzbG90c0ZpbHRlcmVkQnlQYXN0Iiwic2xvdHNGaWx0ZXJlZEJ5QmxhY2tvdXQiLCJzbG90c0ZpbHRlcmVkQnlCb29raW5nIiwicnVsZSIsInN0YWZmTmFtZSIsImdldCIsInllYXIiLCJtb250aCIsImRheSIsInNwbGl0IiwiTnVtYmVyIiwic3RhcnRIb3VyIiwic3RhcnRNaW4iLCJzdGFydF90aW1lIiwiZW5kSG91ciIsImVuZE1pbiIsImVuZF90aW1lIiwicnVsZVN0YXJ0U3RyIiwiU3RyaW5nIiwicGFkU3RhcnQiLCJydWxlRW5kU3RyIiwicnVsZVN0YXJ0TG9jYWwiLCJydWxlRW5kTG9jYWwiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwicnVsZVN0YXJ0VVRDIiwicnVsZUVuZFVUQyIsImN1cnJlbnRTdGFydCIsInJ1bGVFbmRUaW1lIiwic2xvdEVuZCIsInB1c2giLCJzdGFmZl9uYW1lIiwic2xvdHNHZW5lcmF0ZWQiLCJmaWx0ZXJlZEJ5TGVhZFRpbWUiLCJmaWx0ZXJlZEJ5UGFzdCIsImZpbHRlcmVkQnlCbGFja291dCIsImZpbHRlcmVkQnlCb29raW5nIiwic29ydCIsImEiLCJiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/availability.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/db.ts":
/*!***********************!*\
  !*** ./src/lib/db.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAdminClient: () => (/* binding */ createAdminClient),\n/* harmony export */   createClientClient: () => (/* binding */ createClientClient),\n/* harmony export */   createServerClient: () => (/* binding */ createServerClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/../../node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var next_headers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/headers */ \"(rsc)/./node_modules/next/dist/api/headers.js\");\n\n\n/**\n * Get Supabase client for server-side operations\n * \n * This function returns different clients based on context:\n * - If called from an authenticated API route, uses the user's JWT from Authorization header (respects RLS)\n * - If called from a public route or background job, uses service role (bypasses RLS)\n * \n * Usage in API routes:\n * ```ts\n * const supabase = await createServerClient();\n * const { data } = await supabase.from('businesses').select('*');\n * ```\n */ async function createServerClient() {\n    const supabaseUrl = \"https://rgwooqakdvrchfwrdnyx.supabase.co\";\n    const supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJnd29vcWFrZHZyY2hmd3Jkbnl4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMzOTQyNDEsImV4cCI6MjA3ODk3MDI0MX0.YpX0dYf_iueJVR1oK5SvREnO765JAKxriy2csdAEZlI\";\n    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n    if (!supabaseUrl) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_URL environment variable\");\n    }\n    if (!supabaseAnonKey && !supabaseServiceKey) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_ANON_KEY or SUPABASE_SERVICE_ROLE_KEY environment variable\");\n    }\n    // Try to get the user's JWT from Authorization header (for API routes)\n    let accessToken;\n    try {\n        const headersList = await (0,next_headers__WEBPACK_IMPORTED_MODULE_0__.headers)();\n        const authHeader = headersList.get(\"authorization\");\n        if (authHeader?.startsWith(\"Bearer \")) {\n            accessToken = authHeader.substring(7);\n        }\n    } catch  {\n    // Not in a headers context\n    }\n    // If we have a user token from header, use anon key with that token (respects RLS)\n    if (accessToken && supabaseAnonKey) {\n        return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${accessToken}`\n                }\n            }\n        });\n    }\n    // Try to get session from cookies (Supabase stores session in cookies)\n    try {\n        const cookieStore = await (0,next_headers__WEBPACK_IMPORTED_MODULE_0__.cookies)();\n        const allCookies = cookieStore.getAll();\n        // Try to extract access token from cookies first\n        const supabaseUrlObj = new URL(supabaseUrl);\n        const projectRef = supabaseUrlObj.hostname.split(\".\")[0];\n        // Look for Supabase auth token cookie\n        // Try sb-api-auth-token first as it's the most common\n        const authCookieNames = [\n            `sb-api-auth-token`,\n            `sb-${projectRef}-auth-token`\n        ];\n        let accessToken;\n        for (const cookieName of authCookieNames){\n            const cookie = cookieStore.get(cookieName);\n            if (cookie?.value) {\n                // Log first 100 chars to see format (without exposing full token)\n                const preview = cookie.value.substring(0, 100);\n                console.log(`[createServerClient] Checking cookie: ${cookieName}, length: ${cookie.value.length}, preview: ${preview}...`);\n                try {\n                    // Try URL decoding first\n                    let decodedValue = cookie.value;\n                    try {\n                        decodedValue = decodeURIComponent(cookie.value);\n                    } catch  {\n                    // Not URL encoded\n                    }\n                    // Try parsing as JSON\n                    try {\n                        const session = JSON.parse(decodedValue);\n                        console.log(`[createServerClient] Parsed ${cookieName} as JSON, type:`, Array.isArray(session) ? \"array\" : typeof session, \"keys:\", Object.keys(session || {}));\n                        // Check if it's an array (Supabase sometimes stores tokens as array)\n                        if (Array.isArray(session) && session.length > 0) {\n                            console.log(`[createServerClient] Array has ${session.length} elements, checking each...`);\n                            // Try each element to find a valid JWT\n                            for(let i = 0; i < session.length; i++){\n                                const element = session[i];\n                                if (typeof element === \"string\") {\n                                    // Remove any quotes or extra characters\n                                    let cleanToken = element.trim();\n                                    if (cleanToken.startsWith('\"') && cleanToken.endsWith('\"') || cleanToken.startsWith(\"'\") && cleanToken.endsWith(\"'\")) {\n                                        cleanToken = cleanToken.slice(1, -1);\n                                    }\n                                    // Check if it looks like a JWT (has 3 parts separated by dots)\n                                    const parts = cleanToken.split(\".\");\n                                    if (parts.length === 3 && cleanToken.length > 100) {\n                                        console.log(`[createServerClient] Found valid JWT structure in element ${i}, using it as access token`);\n                                        // Use this token - even if signature validation fails later, \n                                        // Supabase might still accept it for RLS if the payload is valid\n                                        accessToken = cleanToken;\n                                        break;\n                                    }\n                                }\n                                // If element is an object, check for access_token\n                                if (element && typeof element === \"object\" && element.access_token) {\n                                    console.log(`[createServerClient] Found access_token in element ${i}: ${cookieName}`);\n                                    accessToken = element.access_token;\n                                    break;\n                                }\n                            }\n                            if (accessToken) {\n                                break;\n                            }\n                            // If no single element works, try joining all string elements\n                            const allStrings = session.filter((e)=>typeof e === \"string\");\n                            if (allStrings.length > 0) {\n                                const joined = allStrings.join(\"\");\n                                const parts = joined.split(\".\");\n                                if (parts.length === 3 && joined.length > 100) {\n                                    console.log(\"[createServerClient] Found JWT by joining array elements\");\n                                    accessToken = joined;\n                                    break;\n                                }\n                            }\n                        }\n                        if (session?.access_token) {\n                            console.log(`[createServerClient] Found access_token in ${cookieName}`);\n                            accessToken = session.access_token;\n                            break;\n                        }\n                        // Check for nested session object\n                        if (session?.session?.access_token) {\n                            console.log(`[createServerClient] Found access_token in nested session: ${cookieName}`);\n                            accessToken = session.session.access_token;\n                            break;\n                        }\n                    } catch (parseError) {\n                        // Not JSON, might be direct JWT token\n                        console.log(`[createServerClient] ${cookieName} is not JSON, checking if JWT`);\n                        if (decodedValue.length > 100 && decodedValue.includes(\".\")) {\n                            console.log(`[createServerClient] Using ${cookieName} as direct JWT token`);\n                            accessToken = decodedValue;\n                            break;\n                        }\n                    }\n                } catch (error) {\n                    console.error(`[createServerClient] Error processing ${cookieName}:`, error);\n                }\n            }\n        }\n        // If we found an access token, use it directly\n        if (accessToken && supabaseAnonKey) {\n            return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey, {\n                global: {\n                    headers: {\n                        Authorization: `Bearer ${accessToken}`\n                    }\n                },\n                auth: {\n                    persistSession: false,\n                    autoRefreshToken: false\n                }\n            });\n        }\n        // Fallback: Build cookie header for Supabase to read\n        const cookieHeader = allCookies.map((c)=>`${c.name}=${c.value}`).join(\"; \");\n        if (cookieHeader && supabaseAnonKey) {\n            // Create client with cookies - Supabase will extract session from cookies\n            return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey, {\n                global: {\n                    headers: {\n                        Cookie: cookieHeader\n                    }\n                },\n                auth: {\n                    persistSession: false,\n                    autoRefreshToken: false\n                }\n            });\n        }\n    } catch (error) {\n        console.error(\"Error reading cookies in createServerClient:\", error);\n    // Not in a cookies context, continue\n    }\n    // For public routes or background jobs, use service role key\n    // WARNING: This bypasses RLS - only use when necessary\n    if (supabaseServiceKey) {\n        return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseServiceKey, {\n            auth: {\n                autoRefreshToken: false,\n                persistSession: false\n            }\n        });\n    }\n    // Fallback to anon key (for public read operations)\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey);\n}\n/**\n * Get Supabase client with service role (bypasses RLS)\n * \n * Use this ONLY for:\n * - Background jobs\n * - Webhook handlers\n * - Admin operations that need to bypass RLS\n * \n * Usage:\n * ```ts\n * const supabase = createAdminClient();\n * const { data } = await supabase.from('businesses').select('*');\n * ```\n */ function createAdminClient() {\n    const supabaseUrl = \"https://rgwooqakdvrchfwrdnyx.supabase.co\";\n    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n    if (!supabaseUrl) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_URL environment variable\");\n    }\n    if (!supabaseServiceKey) {\n        throw new Error(\"Missing SUPABASE_SERVICE_ROLE_KEY environment variable\");\n    }\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseServiceKey, {\n        auth: {\n            autoRefreshToken: false,\n            persistSession: false\n        }\n    });\n}\n/**\n * Get Supabase client for client-side operations\n * \n * This should be used in React components or client-side code.\n * It uses the anon key and relies on Supabase Auth for authentication.\n * \n * Usage in client components:\n * ```ts\n * 'use client';\n * const supabase = createClientClient();\n * ```\n */ function createClientClient() {\n    const supabaseUrl = \"https://rgwooqakdvrchfwrdnyx.supabase.co\";\n    const supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJnd29vcWFrZHZyY2hmd3Jkbnl4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMzOTQyNDEsImV4cCI6MjA3ODk3MDI0MX0.YpX0dYf_iueJVR1oK5SvREnO765JAKxriy2csdAEZlI\";\n    if (!supabaseUrl) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_URL environment variable\");\n    }\n    if (!supabaseAnonKey) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable\");\n    }\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDRjtBQUVBOzs7Ozs7Ozs7OztDQVdDLEdBQ00sU0FBU1E7SUFDZCxNQUFNbkUsY0FBY0MsMENBQW9DO0lBQ3hELE1BQU1HLGtCQUFrQkgsa05BQXlDO0lBRWpFLElBQUksQ0FBQ0QsYUFBYTtRQUNoQixNQUFNLElBQUlRLE1BQU07SUFDbEI7SUFFQSxJQUFJLENBQUNKLGlCQUFpQjtRQUNwQixNQUFNLElBQUlJLE1BQU07SUFDbEI7SUFFQSxPQUFPWixtRUFBWUEsQ0FBQ0ksYUFBYUk7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9zcmMvbGliL2RiLnRzPzllNGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50LCBTdXBhYmFzZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5pbXBvcnQgeyBjb29raWVzLCBoZWFkZXJzIH0gZnJvbSAnbmV4dC9oZWFkZXJzJztcblxuLyoqXG4gKiBHZXQgU3VwYWJhc2UgY2xpZW50IGZvciBzZXJ2ZXItc2lkZSBvcGVyYXRpb25zXG4gKiBcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBkaWZmZXJlbnQgY2xpZW50cyBiYXNlZCBvbiBjb250ZXh0OlxuICogLSBJZiBjYWxsZWQgZnJvbSBhbiBhdXRoZW50aWNhdGVkIEFQSSByb3V0ZSwgdXNlcyB0aGUgdXNlcidzIEpXVCBmcm9tIEF1dGhvcml6YXRpb24gaGVhZGVyIChyZXNwZWN0cyBSTFMpXG4gKiAtIElmIGNhbGxlZCBmcm9tIGEgcHVibGljIHJvdXRlIG9yIGJhY2tncm91bmQgam9iLCB1c2VzIHNlcnZpY2Ugcm9sZSAoYnlwYXNzZXMgUkxTKVxuICogXG4gKiBVc2FnZSBpbiBBUEkgcm91dGVzOlxuICogYGBgdHNcbiAqIGNvbnN0IHN1cGFiYXNlID0gYXdhaXQgY3JlYXRlU2VydmVyQ2xpZW50KCk7XG4gKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2J1c2luZXNzZXMnKS5zZWxlY3QoJyonKTtcbiAqIGBgYFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlU2VydmVyQ2xpZW50KCk6IFByb21pc2U8U3VwYWJhc2VDbGllbnQ+IHtcbiAgY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkw7XG4gIGNvbnN0IHN1cGFiYXNlQW5vbktleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZO1xuICBjb25zdCBzdXBhYmFzZVNlcnZpY2VLZXkgPSBwcm9jZXNzLmVudi5TVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZO1xuXG4gIGlmICghc3VwYWJhc2VVcmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIGVudmlyb25tZW50IHZhcmlhYmxlJyk7XG4gIH1cblxuICBpZiAoIXN1cGFiYXNlQW5vbktleSAmJiAhc3VwYWJhc2VTZXJ2aWNlS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ01pc3NpbmcgTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgb3IgU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSdcbiAgICApO1xuICB9XG5cbiAgLy8gVHJ5IHRvIGdldCB0aGUgdXNlcidzIEpXVCBmcm9tIEF1dGhvcml6YXRpb24gaGVhZGVyIChmb3IgQVBJIHJvdXRlcylcbiAgbGV0IGFjY2Vzc1Rva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IGhlYWRlcnNMaXN0ID0gYXdhaXQgaGVhZGVycygpO1xuICAgIGNvbnN0IGF1dGhIZWFkZXIgPSBoZWFkZXJzTGlzdC5nZXQoJ2F1dGhvcml6YXRpb24nKTtcbiAgICBpZiAoYXV0aEhlYWRlcj8uc3RhcnRzV2l0aCgnQmVhcmVyICcpKSB7XG4gICAgICBhY2Nlc3NUb2tlbiA9IGF1dGhIZWFkZXIuc3Vic3RyaW5nKDcpO1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgLy8gTm90IGluIGEgaGVhZGVycyBjb250ZXh0XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlIGEgdXNlciB0b2tlbiBmcm9tIGhlYWRlciwgdXNlIGFub24ga2V5IHdpdGggdGhhdCB0b2tlbiAocmVzcGVjdHMgUkxTKVxuICBpZiAoYWNjZXNzVG9rZW4gJiYgc3VwYWJhc2VBbm9uS2V5KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5LCB7XG4gICAgICBnbG9iYWw6IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRyeSB0byBnZXQgc2Vzc2lvbiBmcm9tIGNvb2tpZXMgKFN1cGFiYXNlIHN0b3JlcyBzZXNzaW9uIGluIGNvb2tpZXMpXG4gIHRyeSB7XG4gICAgY29uc3QgY29va2llU3RvcmUgPSBhd2FpdCBjb29raWVzKCk7XG4gICAgY29uc3QgYWxsQ29va2llcyA9IGNvb2tpZVN0b3JlLmdldEFsbCgpO1xuICAgIFxuICAgIC8vIFRyeSB0byBleHRyYWN0IGFjY2VzcyB0b2tlbiBmcm9tIGNvb2tpZXMgZmlyc3RcbiAgICBjb25zdCBzdXBhYmFzZVVybE9iaiA9IG5ldyBVUkwoc3VwYWJhc2VVcmwpO1xuICAgIGNvbnN0IHByb2plY3RSZWYgPSBzdXBhYmFzZVVybE9iai5ob3N0bmFtZS5zcGxpdCgnLicpWzBdO1xuICAgIFxuICAgIC8vIExvb2sgZm9yIFN1cGFiYXNlIGF1dGggdG9rZW4gY29va2llXG4gICAgLy8gVHJ5IHNiLWFwaS1hdXRoLXRva2VuIGZpcnN0IGFzIGl0J3MgdGhlIG1vc3QgY29tbW9uXG4gICAgY29uc3QgYXV0aENvb2tpZU5hbWVzID0gW1xuICAgICAgYHNiLWFwaS1hdXRoLXRva2VuYCxcbiAgICAgIGBzYi0ke3Byb2plY3RSZWZ9LWF1dGgtdG9rZW5gLFxuICAgIF07XG4gICAgXG4gICAgbGV0IGFjY2Vzc1Rva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCBjb29raWVOYW1lIG9mIGF1dGhDb29raWVOYW1lcykge1xuICAgICAgY29uc3QgY29va2llID0gY29va2llU3RvcmUuZ2V0KGNvb2tpZU5hbWUpO1xuICAgICAgaWYgKGNvb2tpZT8udmFsdWUpIHtcbiAgICAgICAgLy8gTG9nIGZpcnN0IDEwMCBjaGFycyB0byBzZWUgZm9ybWF0ICh3aXRob3V0IGV4cG9zaW5nIGZ1bGwgdG9rZW4pXG4gICAgICAgIGNvbnN0IHByZXZpZXcgPSBjb29raWUudmFsdWUuc3Vic3RyaW5nKDAsIDEwMCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbY3JlYXRlU2VydmVyQ2xpZW50XSBDaGVja2luZyBjb29raWU6ICR7Y29va2llTmFtZX0sIGxlbmd0aDogJHtjb29raWUudmFsdWUubGVuZ3RofSwgcHJldmlldzogJHtwcmV2aWV3fS4uLmApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRyeSBVUkwgZGVjb2RpbmcgZmlyc3RcbiAgICAgICAgICBsZXQgZGVjb2RlZFZhbHVlID0gY29va2llLnZhbHVlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWNvZGVkVmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoY29va2llLnZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIC8vIE5vdCBVUkwgZW5jb2RlZFxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgcGFyc2luZyBhcyBKU09OXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBKU09OLnBhcnNlKGRlY29kZWRWYWx1ZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NyZWF0ZVNlcnZlckNsaWVudF0gUGFyc2VkICR7Y29va2llTmFtZX0gYXMgSlNPTiwgdHlwZTpgLCBBcnJheS5pc0FycmF5KHNlc3Npb24pID8gJ2FycmF5JyA6IHR5cGVvZiBzZXNzaW9uLCAna2V5czonLCBPYmplY3Qua2V5cyhzZXNzaW9uIHx8IHt9KSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gYXJyYXkgKFN1cGFiYXNlIHNvbWV0aW1lcyBzdG9yZXMgdG9rZW5zIGFzIGFycmF5KVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2Vzc2lvbikgJiYgc2Vzc2lvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbY3JlYXRlU2VydmVyQ2xpZW50XSBBcnJheSBoYXMgJHtzZXNzaW9uLmxlbmd0aH0gZWxlbWVudHMsIGNoZWNraW5nIGVhY2guLi5gKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFRyeSBlYWNoIGVsZW1lbnQgdG8gZmluZCBhIHZhbGlkIEpXVFxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gc2Vzc2lvbltpXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW55IHF1b3RlcyBvciBleHRyYSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICBsZXQgY2xlYW5Ub2tlbiA9IGVsZW1lbnQudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgaWYgKChjbGVhblRva2VuLnN0YXJ0c1dpdGgoJ1wiJykgJiYgY2xlYW5Ub2tlbi5lbmRzV2l0aCgnXCInKSkgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgKGNsZWFuVG9rZW4uc3RhcnRzV2l0aChcIidcIikgJiYgY2xlYW5Ub2tlbi5lbmRzV2l0aChcIidcIikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuVG9rZW4gPSBjbGVhblRva2VuLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgbG9va3MgbGlrZSBhIEpXVCAoaGFzIDMgcGFydHMgc2VwYXJhdGVkIGJ5IGRvdHMpXG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGNsZWFuVG9rZW4uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDMgJiYgY2xlYW5Ub2tlbi5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtjcmVhdGVTZXJ2ZXJDbGllbnRdIEZvdW5kIHZhbGlkIEpXVCBzdHJ1Y3R1cmUgaW4gZWxlbWVudCAke2l9LCB1c2luZyBpdCBhcyBhY2Nlc3MgdG9rZW5gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoaXMgdG9rZW4gLSBldmVuIGlmIHNpZ25hdHVyZSB2YWxpZGF0aW9uIGZhaWxzIGxhdGVyLCBcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwYWJhc2UgbWlnaHQgc3RpbGwgYWNjZXB0IGl0IGZvciBSTFMgaWYgdGhlIHBheWxvYWQgaXMgdmFsaWRcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBjbGVhblRva2VuO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gSWYgZWxlbWVudCBpcyBhbiBvYmplY3QsIGNoZWNrIGZvciBhY2Nlc3NfdG9rZW5cbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudC5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbY3JlYXRlU2VydmVyQ2xpZW50XSBGb3VuZCBhY2Nlc3NfdG9rZW4gaW4gZWxlbWVudCAke2l9OiAke2Nvb2tpZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbiA9IGVsZW1lbnQuYWNjZXNzX3Rva2VuO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gSWYgbm8gc2luZ2xlIGVsZW1lbnQgd29ya3MsIHRyeSBqb2luaW5nIGFsbCBzdHJpbmcgZWxlbWVudHNcbiAgICAgICAgICAgICAgY29uc3QgYWxsU3RyaW5ncyA9IHNlc3Npb24uZmlsdGVyKGUgPT4gdHlwZW9mIGUgPT09ICdzdHJpbmcnKTtcbiAgICAgICAgICAgICAgaWYgKGFsbFN0cmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGpvaW5lZCA9IGFsbFN0cmluZ3Muam9pbignJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBqb2luZWQuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAzICYmIGpvaW5lZC5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbY3JlYXRlU2VydmVyQ2xpZW50XSBGb3VuZCBKV1QgYnkgam9pbmluZyBhcnJheSBlbGVtZW50cycpO1xuICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBqb2luZWQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHNlc3Npb24/LmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NyZWF0ZVNlcnZlckNsaWVudF0gRm91bmQgYWNjZXNzX3Rva2VuIGluICR7Y29va2llTmFtZX1gKTtcbiAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBzZXNzaW9uLmFjY2Vzc190b2tlbjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBuZXN0ZWQgc2Vzc2lvbiBvYmplY3RcbiAgICAgICAgICAgIGlmIChzZXNzaW9uPy5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtjcmVhdGVTZXJ2ZXJDbGllbnRdIEZvdW5kIGFjY2Vzc190b2tlbiBpbiBuZXN0ZWQgc2Vzc2lvbjogJHtjb29raWVOYW1lfWApO1xuICAgICAgICAgICAgICBhY2Nlc3NUb2tlbiA9IHNlc3Npb24uc2Vzc2lvbi5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIE5vdCBKU09OLCBtaWdodCBiZSBkaXJlY3QgSldUIHRva2VuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NyZWF0ZVNlcnZlckNsaWVudF0gJHtjb29raWVOYW1lfSBpcyBub3QgSlNPTiwgY2hlY2tpbmcgaWYgSldUYCk7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZFZhbHVlLmxlbmd0aCA+IDEwMCAmJiBkZWNvZGVkVmFsdWUuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NyZWF0ZVNlcnZlckNsaWVudF0gVXNpbmcgJHtjb29raWVOYW1lfSBhcyBkaXJlY3QgSldUIHRva2VuYCk7XG4gICAgICAgICAgICAgIGFjY2Vzc1Rva2VuID0gZGVjb2RlZFZhbHVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgW2NyZWF0ZVNlcnZlckNsaWVudF0gRXJyb3IgcHJvY2Vzc2luZyAke2Nvb2tpZU5hbWV9OmAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSBmb3VuZCBhbiBhY2Nlc3MgdG9rZW4sIHVzZSBpdCBkaXJlY3RseVxuICAgIGlmIChhY2Nlc3NUb2tlbiAmJiBzdXBhYmFzZUFub25LZXkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgICBnbG9iYWw6IHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgcGVyc2lzdFNlc3Npb246IGZhbHNlLFxuICAgICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrOiBCdWlsZCBjb29raWUgaGVhZGVyIGZvciBTdXBhYmFzZSB0byByZWFkXG4gICAgY29uc3QgY29va2llSGVhZGVyID0gYWxsQ29va2llcy5tYXAoYyA9PiBgJHtjLm5hbWV9PSR7Yy52YWx1ZX1gKS5qb2luKCc7ICcpO1xuICAgIFxuICAgIGlmIChjb29raWVIZWFkZXIgJiYgc3VwYWJhc2VBbm9uS2V5KSB7XG4gICAgICAvLyBDcmVhdGUgY2xpZW50IHdpdGggY29va2llcyAtIFN1cGFiYXNlIHdpbGwgZXh0cmFjdCBzZXNzaW9uIGZyb20gY29va2llc1xuICAgICAgcmV0dXJuIGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5LCB7XG4gICAgICAgIGdsb2JhbDoge1xuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIENvb2tpZTogY29va2llSGVhZGVyLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsIC8vIFdlJ3JlIGhhbmRsaW5nIGNvb2tpZXMgbWFudWFsbHlcbiAgICAgICAgICBhdXRvUmVmcmVzaFRva2VuOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWFkaW5nIGNvb2tpZXMgaW4gY3JlYXRlU2VydmVyQ2xpZW50OicsIGVycm9yKTtcbiAgICAvLyBOb3QgaW4gYSBjb29raWVzIGNvbnRleHQsIGNvbnRpbnVlXG4gIH1cblxuICAvLyBGb3IgcHVibGljIHJvdXRlcyBvciBiYWNrZ3JvdW5kIGpvYnMsIHVzZSBzZXJ2aWNlIHJvbGUga2V5XG4gIC8vIFdBUk5JTkc6IFRoaXMgYnlwYXNzZXMgUkxTIC0gb25seSB1c2Ugd2hlbiBuZWNlc3NhcnlcbiAgaWYgKHN1cGFiYXNlU2VydmljZUtleSkge1xuICAgIHJldHVybiBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlU2VydmljZUtleSwge1xuICAgICAgYXV0aDoge1xuICAgICAgICBhdXRvUmVmcmVzaFRva2VuOiBmYWxzZSxcbiAgICAgICAgcGVyc2lzdFNlc3Npb246IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEZhbGxiYWNrIHRvIGFub24ga2V5IChmb3IgcHVibGljIHJlYWQgb3BlcmF0aW9ucylcbiAgcmV0dXJuIGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5ISk7XG59XG5cbi8qKlxuICogR2V0IFN1cGFiYXNlIGNsaWVudCB3aXRoIHNlcnZpY2Ugcm9sZSAoYnlwYXNzZXMgUkxTKVxuICogXG4gKiBVc2UgdGhpcyBPTkxZIGZvcjpcbiAqIC0gQmFja2dyb3VuZCBqb2JzXG4gKiAtIFdlYmhvb2sgaGFuZGxlcnNcbiAqIC0gQWRtaW4gb3BlcmF0aW9ucyB0aGF0IG5lZWQgdG8gYnlwYXNzIFJMU1xuICogXG4gKiBVc2FnZTpcbiAqIGBgYHRzXG4gKiBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUFkbWluQ2xpZW50KCk7XG4gKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2J1c2luZXNzZXMnKS5zZWxlY3QoJyonKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWRtaW5DbGllbnQoKTogU3VwYWJhc2VDbGllbnQge1xuICBjb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTDtcbiAgY29uc3Qgc3VwYWJhc2VTZXJ2aWNlS2V5ID0gcHJvY2Vzcy5lbnYuU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWTtcblxuICBpZiAoIXN1cGFiYXNlVXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIE5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCBlbnZpcm9ubWVudCB2YXJpYWJsZScpO1xuICB9XG5cbiAgaWYgKCFzdXBhYmFzZVNlcnZpY2VLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZScpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VTZXJ2aWNlS2V5LCB7XG4gICAgYXV0aDoge1xuICAgICAgYXV0b1JlZnJlc2hUb2tlbjogZmFsc2UsXG4gICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsXG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IFN1cGFiYXNlIGNsaWVudCBmb3IgY2xpZW50LXNpZGUgb3BlcmF0aW9uc1xuICogXG4gKiBUaGlzIHNob3VsZCBiZSB1c2VkIGluIFJlYWN0IGNvbXBvbmVudHMgb3IgY2xpZW50LXNpZGUgY29kZS5cbiAqIEl0IHVzZXMgdGhlIGFub24ga2V5IGFuZCByZWxpZXMgb24gU3VwYWJhc2UgQXV0aCBmb3IgYXV0aGVudGljYXRpb24uXG4gKiBcbiAqIFVzYWdlIGluIGNsaWVudCBjb21wb25lbnRzOlxuICogYGBgdHNcbiAqICd1c2UgY2xpZW50JztcbiAqIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50Q2xpZW50KCk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNsaWVudENsaWVudCgpOiBTdXBhYmFzZUNsaWVudCB7XG4gIGNvbnN0IHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMO1xuICBjb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWTtcblxuICBpZiAoIXN1cGFiYXNlVXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIE5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCBlbnZpcm9ubWVudCB2YXJpYWJsZScpO1xuICB9XG5cbiAgaWYgKCFzdXBhYmFzZUFub25LZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGUnKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSk7XG59XG5cbiJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJjb29raWVzIiwiaGVhZGVycyIsImNyZWF0ZVNlcnZlckNsaWVudCIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlQW5vbktleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwic3VwYWJhc2VTZXJ2aWNlS2V5IiwiU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSIsIkVycm9yIiwiYWNjZXNzVG9rZW4iLCJoZWFkZXJzTGlzdCIsImF1dGhIZWFkZXIiLCJnZXQiLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwiZ2xvYmFsIiwiQXV0aG9yaXphdGlvbiIsImNvb2tpZVN0b3JlIiwiYWxsQ29va2llcyIsImdldEFsbCIsInN1cGFiYXNlVXJsT2JqIiwiVVJMIiwicHJvamVjdFJlZiIsImhvc3RuYW1lIiwic3BsaXQiLCJhdXRoQ29va2llTmFtZXMiLCJjb29raWVOYW1lIiwiY29va2llIiwidmFsdWUiLCJwcmV2aWV3IiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsImRlY29kZWRWYWx1ZSIsImRlY29kZVVSSUNvbXBvbmVudCIsInNlc3Npb24iLCJKU09OIiwicGFyc2UiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJrZXlzIiwiaSIsImVsZW1lbnQiLCJjbGVhblRva2VuIiwidHJpbSIsImVuZHNXaXRoIiwic2xpY2UiLCJwYXJ0cyIsImFjY2Vzc190b2tlbiIsImFsbFN0cmluZ3MiLCJmaWx0ZXIiLCJlIiwiam9pbmVkIiwiam9pbiIsInBhcnNlRXJyb3IiLCJpbmNsdWRlcyIsImVycm9yIiwiYXV0aCIsInBlcnNpc3RTZXNzaW9uIiwiYXV0b1JlZnJlc2hUb2tlbiIsImNvb2tpZUhlYWRlciIsIm1hcCIsImMiLCJuYW1lIiwiQ29va2llIiwiY3JlYXRlQWRtaW5DbGllbnQiLCJjcmVhdGVDbGllbnRDbGllbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/db.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@supabase","vendor-chunks/tslib","vendor-chunks/date-fns","vendor-chunks/date-fns-tz"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fpublic%2F%5Bslug%5D%2Favailability%2Froute&page=%2Fapi%2Fpublic%2F%5Bslug%5D%2Favailability%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fpublic%2F%5Bslug%5D%2Favailability%2Froute.ts&appDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();