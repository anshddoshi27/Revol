"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/business/onboarding/step-11-payment-setup/route";
exports.ids = ["app/api/business/onboarding/step-11-payment-setup/route"];
exports.modules = {

/***/ "../../client/components/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/client/components/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/action-async-storage.external.js");

/***/ }),

/***/ "../../client/components/request-async-storage.external":
/*!********************************************************************************!*\
  !*** external "next/dist/client/components/request-async-storage.external.js" ***!
  \********************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/request-async-storage.external.js");

/***/ }),

/***/ "../../client/components/static-generation-async-storage.external":
/*!******************************************************************************************!*\
  !*** external "next/dist/client/components/static-generation-async-storage.external.js" ***!
  \******************************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/static-generation-async-storage.external.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fbusiness%2Fonboarding%2Fstep-11-payment-setup%2Froute&page=%2Fapi%2Fbusiness%2Fonboarding%2Fstep-11-payment-setup%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fbusiness%2Fonboarding%2Fstep-11-payment-setup%2Froute.ts&appDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fbusiness%2Fonboarding%2Fstep-11-payment-setup%2Froute&page=%2Fapi%2Fbusiness%2Fonboarding%2Fstep-11-payment-setup%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fbusiness%2Fonboarding%2Fstep-11-payment-setup%2Froute.ts&appDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_3017387smacbookm_Downloads_Career_Tithi_apps_web_src_app_api_business_onboarding_step_11_payment_setup_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/business/onboarding/step-11-payment-setup/route.ts */ \"(rsc)/./src/app/api/business/onboarding/step-11-payment-setup/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/business/onboarding/step-11-payment-setup/route\",\n        pathname: \"/api/business/onboarding/step-11-payment-setup\",\n        filename: \"route\",\n        bundlePath: \"app/api/business/onboarding/step-11-payment-setup/route\"\n    },\n    resolvedPagePath: \"/Users/3017387smacbookm/Downloads/Career/Tithi/apps/web/src/app/api/business/onboarding/step-11-payment-setup/route.ts\",\n    nextConfigOutput,\n    userland: _Users_3017387smacbookm_Downloads_Career_Tithi_apps_web_src_app_api_business_onboarding_step_11_payment_setup_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/business/onboarding/step-11-payment-setup/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZidXNpbmVzcyUyRm9uYm9hcmRpbmclMkZzdGVwLTExLXBheW1lbnQtc2V0dXAlMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRmJ1c2luZXNzJTJGb25ib2FyZGluZyUyRnN0ZXAtMTEtcGF5bWVudC1zZXR1cCUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRmJ1c2luZXNzJTJGb25ib2FyZGluZyUyRnN0ZXAtMTEtcGF5bWVudC1zZXR1cCUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRjMwMTczODdzbWFjYm9va20lMkZEb3dubG9hZHMlMkZDYXJlZXIlMkZUaXRoaSUyRmFwcHMlMkZ3ZWIlMkZzcmMlMkZhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPSUyRlVzZXJzJTJGMzAxNzM4N3NtYWNib29rbSUyRkRvd25sb2FkcyUyRkNhcmVlciUyRlRpdGhpJTJGYXBwcyUyRndlYiZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD0mcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ2M7QUFDc0U7QUFDbko7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdIQUFtQjtBQUMzQztBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVk7QUFDWixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBaUU7QUFDekU7QUFDQTtBQUNBLFdBQVcsNEVBQVc7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUN1SDs7QUFFdkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvPzE3MDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiL1VzZXJzLzMwMTczODdzbWFjYm9va20vRG93bmxvYWRzL0NhcmVlci9UaXRoaS9hcHBzL3dlYi9zcmMvYXBwL2FwaS9idXNpbmVzcy9vbmJvYXJkaW5nL3N0ZXAtMTEtcGF5bWVudC1zZXR1cC9yb3V0ZS50c1wiO1xuLy8gV2UgaW5qZWN0IHRoZSBuZXh0Q29uZmlnT3V0cHV0IGhlcmUgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZW0gaW4gdGhlIHJvdXRlXG4vLyBtb2R1bGUuXG5jb25zdCBuZXh0Q29uZmlnT3V0cHV0ID0gXCJcIlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUm91dGVSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICBwYWdlOiBcIi9hcGkvYnVzaW5lc3Mvb25ib2FyZGluZy9zdGVwLTExLXBheW1lbnQtc2V0dXAvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9idXNpbmVzcy9vbmJvYXJkaW5nL3N0ZXAtMTEtcGF5bWVudC1zZXR1cFwiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvYnVzaW5lc3Mvb25ib2FyZGluZy9zdGVwLTExLXBheW1lbnQtc2V0dXAvcm91dGVcIlxuICAgIH0sXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCIvVXNlcnMvMzAxNzM4N3NtYWNib29rbS9Eb3dubG9hZHMvQ2FyZWVyL1RpdGhpL2FwcHMvd2ViL3NyYy9hcHAvYXBpL2J1c2luZXNzL29uYm9hcmRpbmcvc3RlcC0xMS1wYXltZW50LXNldHVwL3JvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MgfSA9IHJvdXRlTW9kdWxlO1xuY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IFwiL2FwaS9idXNpbmVzcy9vbmJvYXJkaW5nL3N0ZXAtMTEtcGF5bWVudC1zZXR1cC9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fbusiness%2Fonboarding%2Fstep-11-payment-setup%2Froute&page=%2Fapi%2Fbusiness%2Fonboarding%2Fstep-11-payment-setup%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fbusiness%2Fonboarding%2Fstep-11-payment-setup%2Froute.ts&appDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./src/app/api/business/onboarding/step-11-payment-setup/route.ts":
/*!************************************************************************!*\
  !*** ./src/app/api/business/onboarding/step-11-payment-setup/route.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST),\n/* harmony export */   PUT: () => (/* binding */ PUT)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/db */ \"(rsc)/./src/lib/db.ts\");\n/* harmony import */ var _lib_auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/auth */ \"(rsc)/./src/lib/auth.ts\");\n/* harmony import */ var _lib_stripe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/stripe */ \"(rsc)/./src/lib/stripe.ts\");\n\n\n\n\n/**\n * GET /api/business/onboarding/step-11-payment-setup\n * \n * Retrieves payment setup configuration\n */ async function GET(request) {\n    console.log(\"[step-11-payment-setup] API called - GET /api/business/onboarding/step-11-payment-setup\");\n    try {\n        const userId = await (0,_lib_auth__WEBPACK_IMPORTED_MODULE_2__.getCurrentUserId)();\n        if (!userId) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Unauthorized\"\n            }, {\n                status: 401\n            });\n        }\n        const businessId = await (0,_lib_auth__WEBPACK_IMPORTED_MODULE_2__.getCurrentBusinessId)();\n        if (!businessId) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Business not found\"\n            }, {\n                status: 404\n            });\n        }\n        const supabase = await (0,_lib_db__WEBPACK_IMPORTED_MODULE_1__.createServerClient)();\n        const { data: business, error } = await supabase.from(\"businesses\").select(\"stripe_connect_account_id, stripe_subscription_id, subscription_status, trial_ends_at, next_bill_at, notifications_enabled\").eq(\"id\", businessId).is(\"deleted_at\", null).maybeSingle();\n        if (error) {\n            console.error(\"[step-11-payment-setup] Error fetching business:\", error);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Failed to fetch payment setup data\"\n            }, {\n                status: 500\n            });\n        }\n        if (!business) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                paymentSetup: null\n            }, {\n                status: 200\n            });\n        }\n        // Determine connect status\n        let connectStatus = \"not_started\";\n        if (business.stripe_connect_account_id) {\n            // Check if account is fully onboarded by verifying with Stripe\n            try {\n                const { verifyConnectAccount } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/stripe */ \"(rsc)/./src/lib/stripe.ts\"));\n                const isValid = await verifyConnectAccount(business.stripe_connect_account_id);\n                connectStatus = isValid ? \"completed\" : \"in_progress\";\n            } catch  {\n                connectStatus = \"in_progress\";\n            }\n        }\n        // Get accepted payment methods from payment_methods table if it exists\n        let acceptedMethods = [\n            \"card\"\n        ]; // Default\n        try {\n            const { data: paymentMethods } = await supabase.from(\"payment_methods\").select(\"method\").eq(\"business_id\", businessId).eq(\"enabled\", true);\n            if (paymentMethods && paymentMethods.length > 0) {\n                acceptedMethods = paymentMethods.map((pm)=>pm.method);\n            }\n        } catch (error) {\n            // payment_methods table might not exist, use default\n            console.log(\"[step-11-payment-setup] Could not fetch payment methods, using default\");\n        }\n        // Get subscription status\n        const subscriptionStatus = business.subscription_status || \"trial\";\n        // Get payment method ID from Stripe subscription if available\n        let paymentMethodId;\n        if (business.stripe_subscription_id) {\n            try {\n                const stripe = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! stripe */ \"(rsc)/../../node_modules/stripe/esm/stripe.esm.node.js\")).then((m)=>new m.default(process.env.STRIPE_SECRET_KEY));\n                const subscription = await stripe.subscriptions.retrieve(business.stripe_subscription_id);\n                if (subscription.default_payment_method) {\n                    const pm = typeof subscription.default_payment_method === \"string\" ? subscription.default_payment_method : subscription.default_payment_method.id;\n                    paymentMethodId = pm;\n                }\n            } catch (error) {\n                console.error(\"[step-11-payment-setup] Error fetching payment method from Stripe:\", error);\n            }\n        }\n        const paymentSetup = {\n            connectStatus,\n            acceptedMethods,\n            subscriptionStatus,\n            trialEndsAt: business.trial_ends_at || undefined,\n            nextBillDate: business.next_bill_at || undefined,\n            paymentMethodId\n        };\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            paymentSetup\n        });\n    } catch (error) {\n        console.error(\"[step-11-payment-setup] Error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Internal server error\"\n        }, {\n            status: 500\n        });\n    }\n}\n/**\n * POST /api/business/onboarding/step-11-payment-setup\n * PUT /api/business/onboarding/step-11-payment-setup\n * \n * Sets up Stripe Connect account and subscription\n * \n * Body: {\n *   connectAccountId?: string,  // If returning from Stripe onboarding\n *   email: string,\n *   returnUrl?: string,\n *   refreshUrl?: string\n * }\n */ async function POST(request) {\n    return handlePaymentSetup(request);\n}\nasync function PUT(request) {\n    return handlePaymentSetup(request);\n}\nasync function handlePaymentSetup(request) {\n    console.log(\"[step-11-payment-setup] API called\");\n    try {\n        // Try to get user ID - with better error handling\n        let userId = await (0,_lib_auth__WEBPACK_IMPORTED_MODULE_2__.getCurrentUserId)();\n        // If getCurrentUserId fails, try to get it from Supabase client directly\n        if (!userId) {\n            console.log(\"[step-11-payment-setup] getCurrentUserId returned null, trying direct Supabase client...\");\n            try {\n                const supabase = await (0,_lib_db__WEBPACK_IMPORTED_MODULE_1__.createServerClient)();\n                const { data: { user }, error: userError } = await supabase.auth.getUser();\n                if (user && !userError) {\n                    userId = user.id;\n                    console.log(\"[step-11-payment-setup] Got user ID from direct Supabase client:\", userId);\n                } else {\n                    console.error(\"[step-11-payment-setup] Direct Supabase client also failed:\", userError);\n                }\n            } catch (error) {\n                console.error(\"[step-11-payment-setup] Error getting user from Supabase client:\", error);\n            }\n        }\n        if (!userId) {\n            console.error(\"[step-11-payment-setup] No user ID found - unauthorized\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Unauthorized - Please sign in again\"\n            }, {\n                status: 401\n            });\n        }\n        console.log(\"[step-11-payment-setup] User authenticated:\", userId);\n        // Parse request body first (we need it to potentially create business)\n        const body = await request.json();\n        console.log(\"[step-11-payment-setup] Request body:\", JSON.stringify(body, null, 2));\n        let businessId = await (0,_lib_auth__WEBPACK_IMPORTED_MODULE_2__.getCurrentBusinessId)();\n        // If no business exists, try to create one from the request body\n        // This handles cases where step 1 wasn't completed or the business was deleted\n        if (!businessId) {\n            console.log(\"[step-11-payment-setup] No business found, checking if we can create one from request body\");\n            // Check if we have business data in the request\n            if (body.businessName || body.business?.businessName) {\n                const businessName = body.businessName || body.business?.businessName || \"My Business\";\n                const industry = body.industry || body.business?.industry || \"other\";\n                console.log(\"[step-11-payment-setup] Creating business from request data:\", {\n                    businessName,\n                    industry\n                });\n                const { createAdminClient } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/db */ \"(rsc)/./src/lib/db.ts\"));\n                const adminSupabase = createAdminClient();\n                // First, ensure user exists in public.users table if it exists\n                // This handles the case where foreign key references public.users instead of auth.users\n                try {\n                    const { data: existingUser, error: checkUserError } = await adminSupabase.from(\"users\").select(\"id\").eq(\"id\", userId).maybeSingle();\n                    // If users table exists and user doesn't exist, create it\n                    if (!checkUserError && !existingUser) {\n                        console.log(\"[step-11-payment-setup] users table exists but user missing - creating user record\");\n                        // Get user email from auth\n                        let userEmail;\n                        try {\n                            const { createServerClient } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/db */ \"(rsc)/./src/lib/db.ts\"));\n                            const supabaseClient = await createServerClient();\n                            const { data: { user } } = await supabaseClient.auth.getUser();\n                            userEmail = user?.email || `user-${userId}@tithi.com`;\n                        } catch  {\n                            userEmail = `user-${userId}@tithi.com`;\n                        }\n                        const { error: createUserError } = await adminSupabase.from(\"users\").insert({\n                            id: userId,\n                            email: userEmail,\n                            created_at: new Date().toISOString(),\n                            updated_at: new Date().toISOString()\n                        });\n                        if (createUserError) {\n                            // If insert fails due to missing columns, try with just id\n                            if (createUserError.code === \"42703\" || createUserError.message?.includes(\"column\")) {\n                                const { error: minimalError } = await adminSupabase.from(\"users\").insert({\n                                    id: userId\n                                });\n                                if (minimalError) {\n                                    console.warn(\"[step-11-payment-setup] Could not create user record:\", minimalError);\n                                } else {\n                                    console.log(\"[step-11-payment-setup] Created minimal user record\");\n                                }\n                            } else {\n                                console.warn(\"[step-11-payment-setup] Could not create user record:\", createUserError);\n                            }\n                        } else {\n                            console.log(\"[step-11-payment-setup] User record created in users table\");\n                        }\n                    } else if (checkUserError && checkUserError.code !== \"PGRST116\") {\n                        console.warn(\"[step-11-payment-setup] Error checking users table:\", checkUserError);\n                    }\n                } catch (error) {\n                    // users table might not exist - that's okay\n                    console.log(\"[step-11-payment-setup] users table check failed (might not exist):\", error);\n                }\n                try {\n                    const { data: newBusiness, error: createError } = await adminSupabase.from(\"businesses\").insert({\n                        user_id: userId,\n                        name: businessName,\n                        industry: industry,\n                        subdomain: `temp-${Date.now()}`,\n                        timezone: \"America/New_York\"\n                    }).select(\"id\").single();\n                    if (createError || !newBusiness) {\n                        console.error(\"[step-11-payment-setup] Failed to create business:\", createError);\n                        // Check if it's a foreign key constraint error\n                        if (createError?.code === \"23503\" && createError?.message?.includes(\"users\")) {\n                            console.error(\"[step-11-payment-setup] FOREIGN KEY CONSTRAINT ERROR:\");\n                            console.error(\"[step-11-payment-setup] The businesses.user_id foreign key references a non-existent users table.\");\n                            console.error(\"[step-11-payment-setup] It should reference auth.users(id) instead.\");\n                            console.error(\"[step-11-payment-setup] Run migration: supabase/migrations/20250104000000_fix_businesses_user_id_fkey.sql\");\n                            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                                error: \"Database configuration issue: Foreign key constraint needs to be fixed.\",\n                                details: \"The businesses table has a foreign key that incorrectly references a users table (which doesn't exist). It should reference auth.users(id) instead.\",\n                                code: \"FOREIGN_KEY_VIOLATION\",\n                                solution: {\n                                    important: \"Make sure you are in the TITHI2 Supabase project (not TITHI)\",\n                                    quickFix: \"FIX_CONSTRAINT_TITHI2.sql (in project root)\",\n                                    instructions: [\n                                        \"1. Go to Supabase Dashboard and SELECT THE TITHI2 PROJECT\",\n                                        \"2. Navigate to SQL Editor\",\n                                        \"3. Open the file: FIX_CONSTRAINT_TITHI2.sql (in your project root)\",\n                                        \"4. Copy ALL the SQL from that file\",\n                                        \"5. Paste into SQL Editor and click Run\",\n                                        '6. Check the output - it should show: referenced_schema = \"auth\" and referenced_table = \"users\"',\n                                        '7. If you see \"✅ SUCCESS\", the fix worked!'\n                                    ],\n                                    alternative: \"Or run: supabase db push (if you have Supabase CLI linked to TITHI2)\"\n                                }\n                            }, {\n                                status: 500\n                            });\n                        }\n                        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                            error: \"Business not found and could not be created. Please complete step 1 (Business) first.\",\n                            details: createError?.message\n                        }, {\n                            status: 400\n                        });\n                    }\n                    businessId = newBusiness.id;\n                    console.log(\"[step-11-payment-setup] Created business:\", businessId);\n                } catch (error) {\n                    console.error(\"[step-11-payment-setup] Error creating business:\", error);\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                        error: \"Business not found. Please complete step 1 (Business) first to create your business profile.\",\n                        details: error instanceof Error ? error.message : \"Unknown error\"\n                    }, {\n                        status: 400\n                    });\n                }\n            } else {\n                console.error(\"[step-11-payment-setup] Business not found for user:\", userId);\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Business not found. Please complete step 1 (Business) first to create your business profile.\"\n                }, {\n                    status: 400\n                });\n            }\n        }\n        console.log(\"[step-11-payment-setup] Business ID:\", businessId);\n        // Frontend sends PaymentSetupConfig, but we also accept direct Stripe Connect params\n        const { connectAccountId, email, returnUrl, refreshUrl, acceptedMethods: requestedMethods } = body;\n        const supabase = await (0,_lib_db__WEBPACK_IMPORTED_MODULE_1__.createServerClient)();\n        // Get user's email from session if not provided in body\n        let userEmail = email;\n        if (!userEmail) {\n            try {\n                // Try to get user from Supabase auth\n                const { data: { user }, error: userError } = await supabase.auth.getUser();\n                if (!userError && user?.email) {\n                    userEmail = user.email;\n                    console.log(\"[step-11-payment-setup] Got email from user session:\", userEmail);\n                } else {\n                    console.warn(\"[step-11-payment-setup] Could not get email from auth.getUser(), error:\", userError);\n                    // Use a default email format as fallback (shouldn't happen in production)\n                    userEmail = `user-${userId}@tithi.com`;\n                    console.log(\"[step-11-payment-setup] Using fallback email:\", userEmail);\n                }\n            } catch (error) {\n                console.error(\"[step-11-payment-setup] Error getting email:\", error);\n                // Use a default email format as fallback\n                userEmail = `user-${userId}@tithi.com`;\n                console.log(\"[step-11-payment-setup] Using fallback email after error:\", userEmail);\n            }\n        }\n        if (!userEmail) {\n            console.error(\"[step-11-payment-setup] No email found - cannot proceed\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Email is required. Please ensure you are logged in with a valid email address.\"\n            }, {\n                status: 400\n            });\n        }\n        // Get business info including notifications_enabled\n        const { data: business, error: businessError } = await supabase.from(\"businesses\").select(\"id, name, stripe_connect_account_id, stripe_customer_id, stripe_subscription_id, notifications_enabled\").eq(\"id\", businessId).single();\n        if (businessError || !business) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Business not found\"\n            }, {\n                status: 404\n            });\n        }\n        let accountId = business.stripe_connect_account_id || connectAccountId;\n        // If account ID provided (returning from Stripe), verify it\n        if (connectAccountId) {\n            const isValid = await (0,_lib_stripe__WEBPACK_IMPORTED_MODULE_3__.verifyConnectAccount)(connectAccountId);\n            if (!isValid) {\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Stripe Connect account verification failed. Please complete onboarding.\"\n                }, {\n                    status: 400\n                });\n            }\n            accountId = connectAccountId;\n            // Save the verified account ID\n            await supabase.from(\"businesses\").update({\n                stripe_connect_account_id: accountId,\n                updated_at: new Date().toISOString()\n            }).eq(\"id\", businessId);\n        }\n        // If no account ID yet, create one and get Account Link\n        if (!accountId) {\n            accountId = await (0,_lib_stripe__WEBPACK_IMPORTED_MODULE_3__.createConnectAccount)(userId, userEmail);\n            // Save the account ID (will be verified after onboarding completes)\n            await supabase.from(\"businesses\").update({\n                stripe_connect_account_id: accountId,\n                updated_at: new Date().toISOString()\n            }).eq(\"id\", businessId);\n            // Create Account Link for onboarding\n            // Redirect to /onboarding (the actual onboarding page, not /onboarding/payment-setup)\n            const defaultReturnUrl = returnUrl || `${\"http://localhost:3000\" || 0}/onboarding`;\n            const defaultRefreshUrl = refreshUrl || `${\"http://localhost:3000\" || 0}/onboarding`;\n            const accountLinkUrl = await (0,_lib_stripe__WEBPACK_IMPORTED_MODULE_3__.createAccountLink)(accountId, defaultReturnUrl, defaultRefreshUrl);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: true,\n                accountLinkUrl,\n                connectAccountId: accountId,\n                message: \"Please complete Stripe Connect onboarding\"\n            });\n        }\n        // Verify account is ready\n        const isVerified = await (0,_lib_stripe__WEBPACK_IMPORTED_MODULE_3__.verifyConnectAccount)(accountId);\n        if (!isVerified) {\n            const defaultReturnUrl = returnUrl || `${\"http://localhost:3000\" || 0}/onboarding`;\n            const defaultRefreshUrl = refreshUrl || `${\"http://localhost:3000\" || 0}/onboarding`;\n            const accountLinkUrl = await (0,_lib_stripe__WEBPACK_IMPORTED_MODULE_3__.createAccountLink)(accountId, defaultReturnUrl, defaultRefreshUrl);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                accountLinkUrl,\n                connectAccountId: accountId,\n                message: \"Please complete Stripe Connect onboarding\"\n            });\n        }\n        // Create or get Stripe Customer for subscription\n        let customerId;\n        if (business.stripe_customer_id) {\n            customerId = business.stripe_customer_id;\n        } else {\n            const businessName = business.name || \"Business Owner\";\n            const newCustomerId = await (0,_lib_stripe__WEBPACK_IMPORTED_MODULE_3__.createOrGetCustomer)(userEmail, businessName, {\n                business_id: businessId,\n                user_id: userId\n            });\n            customerId = newCustomerId;\n            await supabase.from(\"businesses\").update({\n                stripe_customer_id: customerId,\n                updated_at: new Date().toISOString()\n            }).eq(\"id\", businessId);\n        }\n        // Create subscription if not exists\n        // Note: Subscription will be in 'incomplete' or 'trialing' state until owner adds payment method\n        // The frontend should handle collecting payment method for the subscription\n        let subscriptionId = business.stripe_subscription_id;\n        // Select the correct Stripe price ID based on notifications_enabled\n        // \n        // Pricing:\n        // - Basic Plan ($11.99/month): notifications_enabled = false\n        //   → Uses STRIPE_PLAN_PRICE_ID_WITHOUT_NOTIFICATIONS\n        // - Pro Plan ($21.99/month): notifications_enabled = true\n        //   → Uses STRIPE_PLAN_PRICE_ID_WITH_NOTIFICATIONS\n        //\n        // The user selects this in onboarding Step 8 (Notifications step)\n        // which saves notifications_enabled to the businesses table.\n        const notificationsEnabled = business.notifications_enabled === true; // Explicitly check for true\n        const planType = notificationsEnabled ? \"Pro\" : \"Basic\";\n        const planPrice = notificationsEnabled ? 21.99 : 11.99;\n        console.log(`Creating subscription for business ${businessId}:`);\n        console.log(`  - notifications_enabled: ${business.notifications_enabled}`);\n        console.log(`  - Plan: ${planType} ($${planPrice}/month)`);\n        const priceIdWithNotifications = process.env.STRIPE_PLAN_PRICE_ID_WITH_NOTIFICATIONS || process.env.NEXT_PUBLIC_STRIPE_PLAN_PRICE_ID_WITH_NOTIFICATIONS;\n        const priceIdWithoutNotifications = process.env.STRIPE_PLAN_PRICE_ID_WITHOUT_NOTIFICATIONS || process.env.NEXT_PUBLIC_STRIPE_PLAN_PRICE_ID_WITHOUT_NOTIFICATIONS;\n        // Fallback to single price ID if separate ones not configured\n        const fallbackPriceId = process.env.STRIPE_PLAN_PRICE_ID || process.env.NEXT_PUBLIC_STRIPE_PLAN_PRICE_ID;\n        const stripePriceId = notificationsEnabled ? priceIdWithNotifications || fallbackPriceId : priceIdWithoutNotifications || fallbackPriceId;\n        console.log(`  - Selected Stripe Price ID: ${stripePriceId}`);\n        console.log(`  - Price ID source: ${notificationsEnabled ? \"WITH_NOTIFICATIONS\" : \"WITHOUT_NOTIFICATIONS\"}`);\n        if (!subscriptionId) {\n            if (!stripePriceId) {\n                console.error(\"No Stripe price ID configured. Please set STRIPE_PLAN_PRICE_ID or STRIPE_PLAN_PRICE_ID_WITH/WITHOUT_NOTIFICATIONS\");\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Subscription price not configured. Please contact support.\",\n                    details: \"Missing Stripe price ID in environment variables\"\n                }, {\n                    status: 500\n                });\n            }\n            try {\n                // Add metadata to subscription so webhooks can find the business\n                // Note: paymentMethodId can be passed if owner already provided it in the request\n                const bodyPaymentMethodId = body.paymentMethodId;\n                const subscription = await (0,_lib_stripe__WEBPACK_IMPORTED_MODULE_3__.createSubscription)(customerId, stripePriceId, {\n                    business_id: businessId,\n                    user_id: userId\n                }, bodyPaymentMethodId);\n                subscriptionId = subscription.subscriptionId;\n                // Calculate next_bill_at from current_period_end (or trial_end if in trial)\n                // For trial, next_bill_at is when trial ends\n                const nextBillAt = subscription.trial_end ? new Date(subscription.trial_end * 1000).toISOString() : subscription.current_period_end ? new Date(subscription.current_period_end * 1000).toISOString() : null;\n                // Determine subscription status\n                // 'trialing' = trial, 'active' = active, 'incomplete' = needs payment method\n                let subscriptionStatus = \"trial\";\n                if (subscription.status === \"active\") {\n                    subscriptionStatus = \"active\";\n                } else if (subscription.status === \"trialing\") {\n                    subscriptionStatus = \"trial\";\n                } else if (subscription.status === \"incomplete\" || subscription.status === \"incomplete_expired\") {\n                    subscriptionStatus = \"trial\"; // Treat incomplete as trial until payment method added\n                }\n                // Save subscription details including the price ID and plan type\n                const { error: updateError } = await supabase.from(\"businesses\").update({\n                    stripe_subscription_id: subscriptionId,\n                    stripe_price_id: stripePriceId,\n                    subscription_status: subscriptionStatus,\n                    trial_ends_at: subscription.trial_end ? new Date(subscription.trial_end * 1000).toISOString() : null,\n                    next_bill_at: nextBillAt,\n                    updated_at: new Date().toISOString()\n                }).eq(\"id\", businessId);\n                if (updateError) {\n                    console.error(\"Error saving subscription to database:\", updateError);\n                    throw updateError;\n                }\n                // Verify the subscription was saved correctly\n                const { data: verifiedBusiness, error: verifyError } = await supabase.from(\"businesses\").select(\"stripe_subscription_id, stripe_price_id, notifications_enabled, subscription_status\").eq(\"id\", businessId).single();\n                if (verifyError) {\n                    console.error(\"Error verifying subscription save:\", verifyError);\n                } else {\n                    console.log(\"Subscription saved successfully:\");\n                    console.log(`  - Subscription ID: ${verifiedBusiness.stripe_subscription_id}`);\n                    console.log(`  - Price ID: ${verifiedBusiness.stripe_price_id}`);\n                    console.log(`  - Notifications enabled: ${verifiedBusiness.notifications_enabled}`);\n                    console.log(`  - Status: ${verifiedBusiness.subscription_status}`);\n                    console.log(`  - Plan: ${verifiedBusiness.notifications_enabled ? \"Pro ($21.99/month)\" : \"Basic ($11.99/month)\"}`);\n                }\n            } catch (subscriptionError) {\n                console.error(\"Error creating subscription:\", subscriptionError);\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Failed to create subscription\",\n                    details: subscriptionError instanceof Error ? subscriptionError.message : \"Unknown error\"\n                }, {\n                    status: 500\n                });\n            }\n        }\n        // Save accepted payment methods if provided\n        if (requestedMethods && Array.isArray(requestedMethods) && requestedMethods.length > 0) {\n            try {\n                // First, disable all existing payment methods for this business\n                await supabase.from(\"payment_methods\").update({\n                    enabled: false\n                }).eq(\"business_id\", businessId);\n                // Then, insert or update the requested methods\n                const methodsToSave = requestedMethods.map((method)=>({\n                        business_id: businessId,\n                        user_id: userId,\n                        method: method === \"wallets\" ? \"apple_pay\" : method,\n                        enabled: true,\n                        created_at: new Date().toISOString(),\n                        updated_at: new Date().toISOString()\n                    }));\n                // If 'wallets' is in the list, also add google_pay\n                if (requestedMethods.includes(\"wallets\")) {\n                    methodsToSave.push({\n                        business_id: businessId,\n                        user_id: userId,\n                        method: \"google_pay\",\n                        enabled: true,\n                        created_at: new Date().toISOString(),\n                        updated_at: new Date().toISOString()\n                    });\n                }\n                // Always ensure 'card' is enabled\n                if (!requestedMethods.includes(\"card\")) {\n                    methodsToSave.push({\n                        business_id: businessId,\n                        user_id: userId,\n                        method: \"card\",\n                        enabled: true,\n                        created_at: new Date().toISOString(),\n                        updated_at: new Date().toISOString()\n                    });\n                }\n                // Upsert payment methods\n                const { error: paymentMethodsError } = await supabase.from(\"payment_methods\").upsert(methodsToSave, {\n                    onConflict: \"business_id,method\",\n                    ignoreDuplicates: false\n                });\n                if (paymentMethodsError) {\n                    console.error(\"[step-11-payment-setup] Error saving payment methods:\", paymentMethodsError);\n                // Don't fail the request if payment methods save fails\n                } else {\n                    console.log(\"[step-11-payment-setup] Saved payment methods:\", methodsToSave.map((m)=>m.method));\n                }\n            } catch (error) {\n                // payment_methods table might not exist, log and continue\n                console.log(\"[step-11-payment-setup] Could not save payment methods (table might not exist):\", error);\n            }\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            connectAccountId: accountId,\n            subscriptionId: subscriptionId || null,\n            message: \"Payment setup completed successfully\"\n        });\n    } catch (error) {\n        console.error(\"Error in step-11-payment-setup:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Internal server error\",\n            details: error instanceof Error ? error.message : \"Unknown error\"\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvYXBwL2FwaS9idXNpbmVzcy9vbmJvYXJkaW5nL3N0ZXAtMTEtcGF5bWVudC1zZXR1cC9yb3V0ZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTJDO0FBQ0c7QUFDc0I7QUFPOUM7QUFFdEI7Ozs7Q0FJQyxHQUNNLGVBQWVTLElBQUlDLE9BQWdCO0lBQ3hDQyxRQUFRQyxHQUFHLENBQUM7SUFDWixJQUFJO1FBQ0YsTUFBTUMsU0FBUyxNQUFNWCwyREFBZ0JBO1FBQ3JDLElBQUksQ0FBQ1csUUFBUTtZQUNYLE9BQU9iLHFEQUFZQSxDQUFDYyxJQUFJLENBQ3RCO2dCQUFFQyxPQUFPO1lBQWUsR0FDeEI7Z0JBQUVDLFFBQVE7WUFBSTtRQUVsQjtRQUVBLE1BQU1DLGFBQWEsTUFBTWQsK0RBQW9CQTtRQUM3QyxJQUFJLENBQUNjLFlBQVk7WUFDZixPQUFPakIscURBQVlBLENBQUNjLElBQUksQ0FDdEI7Z0JBQUVDLE9BQU87WUFBcUIsR0FDOUI7Z0JBQUVDLFFBQVE7WUFBSTtRQUVsQjtRQUVBLE1BQU1FLFdBQVcsTUFBTWpCLDJEQUFrQkE7UUFDekMsTUFBTSxFQUFFa0IsTUFBTUMsUUFBUSxFQUFFTCxLQUFLLEVBQUUsR0FBRyxNQUFNRyxTQUNyQ0csSUFBSSxDQUFDLGNBQ0xDLE1BQU0sQ0FBQyw4SEFDUEMsRUFBRSxDQUFDLE1BQU1OLFlBQ1RPLEVBQUUsQ0FBQyxjQUFjLE1BQ2pCQyxXQUFXO1FBRWQsSUFBSVYsT0FBTztZQUNUSixRQUFRSSxLQUFLLENBQUMsb0RBQW9EQTtZQUNsRSxPQUFPZixxREFBWUEsQ0FBQ2MsSUFBSSxDQUN0QjtnQkFBRUMsT0FBTztZQUFxQyxHQUM5QztnQkFBRUMsUUFBUTtZQUFJO1FBRWxCO1FBRUEsSUFBSSxDQUFDSSxVQUFVO1lBQ2IsT0FBT3BCLHFEQUFZQSxDQUFDYyxJQUFJLENBQ3RCO2dCQUFFWSxjQUFjO1lBQUssR0FDckI7Z0JBQUVWLFFBQVE7WUFBSTtRQUVsQjtRQUVBLDJCQUEyQjtRQUMzQixJQUFJVyxnQkFBNkQ7UUFDakUsSUFBSVAsU0FBU1EseUJBQXlCLEVBQUU7WUFDdEMsK0RBQStEO1lBQy9ELElBQUk7Z0JBQ0YsTUFBTSxFQUFFdEIsb0JBQW9CLEVBQUUsR0FBRyxNQUFNLHFJQUFPO2dCQUM5QyxNQUFNdUIsVUFBVSxNQUFNdkIscUJBQXFCYyxTQUFTUSx5QkFBeUI7Z0JBQzdFRCxnQkFBZ0JFLFVBQVUsY0FBYztZQUMxQyxFQUFFLE9BQU07Z0JBQ05GLGdCQUFnQjtZQUNsQjtRQUNGO1FBRUEsdUVBQXVFO1FBQ3ZFLElBQUlHLGtCQUE0QjtZQUFDO1NBQU8sRUFBRSxVQUFVO1FBQ3BELElBQUk7WUFDRixNQUFNLEVBQUVYLE1BQU1ZLGNBQWMsRUFBRSxHQUFHLE1BQU1iLFNBQ3BDRyxJQUFJLENBQUMsbUJBQ0xDLE1BQU0sQ0FBQyxVQUNQQyxFQUFFLENBQUMsZUFBZU4sWUFDbEJNLEVBQUUsQ0FBQyxXQUFXO1lBRWpCLElBQUlRLGtCQUFrQkEsZUFBZUMsTUFBTSxHQUFHLEdBQUc7Z0JBQy9DRixrQkFBa0JDLGVBQWVFLEdBQUcsQ0FBQ0MsQ0FBQUEsS0FBTUEsR0FBR0MsTUFBTTtZQUN0RDtRQUNGLEVBQUUsT0FBT3BCLE9BQU87WUFDZCxxREFBcUQ7WUFDckRKLFFBQVFDLEdBQUcsQ0FBQztRQUNkO1FBRUEsMEJBQTBCO1FBQzFCLE1BQU13QixxQkFBcUIsU0FBVUMsbUJBQW1CLElBQW1EO1FBRTNHLDhEQUE4RDtRQUM5RCxJQUFJQztRQUNKLElBQUlsQixTQUFTbUIsc0JBQXNCLEVBQUU7WUFDbkMsSUFBSTtnQkFDRixNQUFNQyxTQUFTLE1BQU0sNEpBQU8sQ0FBVUMsSUFBSSxDQUFDQyxDQUFBQSxJQUFLLElBQUlBLEVBQUVDLE9BQU8sQ0FBQ0MsUUFBUUMsR0FBRyxDQUFDQyxpQkFBaUI7Z0JBQzNGLE1BQU1DLGVBQWUsTUFBTVAsT0FBT1EsYUFBYSxDQUFDQyxRQUFRLENBQUM3QixTQUFTbUIsc0JBQXNCO2dCQUN4RixJQUFJUSxhQUFhRyxzQkFBc0IsRUFBRTtvQkFDdkMsTUFBTWhCLEtBQUssT0FBT2EsYUFBYUcsc0JBQXNCLEtBQUssV0FDdERILGFBQWFHLHNCQUFzQixHQUNuQ0gsYUFBYUcsc0JBQXNCLENBQUNDLEVBQUU7b0JBQzFDYixrQkFBa0JKO2dCQUNwQjtZQUNGLEVBQUUsT0FBT25CLE9BQU87Z0JBQ2RKLFFBQVFJLEtBQUssQ0FBQyxzRUFBc0VBO1lBQ3RGO1FBQ0Y7UUFFQSxNQUFNVyxlQUFlO1lBQ25CQztZQUNBRztZQUNBTTtZQUNBZ0IsYUFBYWhDLFNBQVNpQyxhQUFhLElBQUlDO1lBQ3ZDQyxjQUFjbkMsU0FBU29DLFlBQVksSUFBSUY7WUFDdkNoQjtRQUNGO1FBRUEsT0FBT3RDLHFEQUFZQSxDQUFDYyxJQUFJLENBQUM7WUFDdkJZO1FBQ0Y7SUFDRixFQUFFLE9BQU9YLE9BQU87UUFDZEosUUFBUUksS0FBSyxDQUFDLGtDQUFrQ0E7UUFDaEQsT0FBT2YscURBQVlBLENBQUNjLElBQUksQ0FDdEI7WUFBRUMsT0FBTztRQUF3QixHQUNqQztZQUFFQyxRQUFRO1FBQUk7SUFFbEI7QUFDRjtBQUVBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLGVBQWV5QyxLQUFLL0MsT0FBZ0I7SUFDekMsT0FBT2dELG1CQUFtQmhEO0FBQzVCO0FBRU8sZUFBZWlELElBQUlqRCxPQUFnQjtJQUN4QyxPQUFPZ0QsbUJBQW1CaEQ7QUFDNUI7QUFFQSxlQUFlZ0QsbUJBQW1CaEQsT0FBZ0I7SUFDaERDLFFBQVFDLEdBQUcsQ0FBQztJQUNaLElBQUk7UUFDRixrREFBa0Q7UUFDbEQsSUFBSUMsU0FBUyxNQUFNWCwyREFBZ0JBO1FBRW5DLHlFQUF5RTtRQUN6RSxJQUFJLENBQUNXLFFBQVE7WUFDWEYsUUFBUUMsR0FBRyxDQUFDO1lBQ1osSUFBSTtnQkFDRixNQUFNTSxXQUFXLE1BQU1qQiwyREFBa0JBO2dCQUN6QyxNQUFNLEVBQUVrQixNQUFNLEVBQUV5QyxJQUFJLEVBQUUsRUFBRTdDLE9BQU84QyxTQUFTLEVBQUUsR0FBRyxNQUFNM0MsU0FBUzRDLElBQUksQ0FBQ0MsT0FBTztnQkFFeEUsSUFBSUgsUUFBUSxDQUFDQyxXQUFXO29CQUN0QmhELFNBQVMrQyxLQUFLVCxFQUFFO29CQUNoQnhDLFFBQVFDLEdBQUcsQ0FBQyxvRUFBb0VDO2dCQUNsRixPQUFPO29CQUNMRixRQUFRSSxLQUFLLENBQUMsK0RBQStEOEM7Z0JBQy9FO1lBQ0YsRUFBRSxPQUFPOUMsT0FBTztnQkFDZEosUUFBUUksS0FBSyxDQUFDLG9FQUFvRUE7WUFDcEY7UUFDRjtRQUVBLElBQUksQ0FBQ0YsUUFBUTtZQUNYRixRQUFRSSxLQUFLLENBQUM7WUFDZCxPQUFPZixxREFBWUEsQ0FBQ2MsSUFBSSxDQUN0QjtnQkFBRUMsT0FBTztZQUFzQyxHQUMvQztnQkFBRUMsUUFBUTtZQUFJO1FBRWxCO1FBQ0FMLFFBQVFDLEdBQUcsQ0FBQywrQ0FBK0NDO1FBRTNELHVFQUF1RTtRQUN2RSxNQUFNbUQsT0FBTyxNQUFNdEQsUUFBUUksSUFBSTtRQUMvQkgsUUFBUUMsR0FBRyxDQUFDLHlDQUF5Q3FELEtBQUtDLFNBQVMsQ0FBQ0YsTUFBTSxNQUFNO1FBRWhGLElBQUkvQyxhQUFhLE1BQU1kLCtEQUFvQkE7UUFFM0MsaUVBQWlFO1FBQ2pFLCtFQUErRTtRQUMvRSxJQUFJLENBQUNjLFlBQVk7WUFDZk4sUUFBUUMsR0FBRyxDQUFDO1lBRVosZ0RBQWdEO1lBQ2hELElBQUlvRCxLQUFLRyxZQUFZLElBQUlILEtBQUs1QyxRQUFRLEVBQUUrQyxjQUFjO2dCQUNwRCxNQUFNQSxlQUFlSCxLQUFLRyxZQUFZLElBQUlILEtBQUs1QyxRQUFRLEVBQUUrQyxnQkFBZ0I7Z0JBQ3pFLE1BQU1DLFdBQVdKLEtBQUtJLFFBQVEsSUFBSUosS0FBSzVDLFFBQVEsRUFBRWdELFlBQVk7Z0JBRTdEekQsUUFBUUMsR0FBRyxDQUFDLGdFQUFnRTtvQkFBRXVEO29CQUFjQztnQkFBUztnQkFFckcsTUFBTSxFQUFFQyxpQkFBaUIsRUFBRSxHQUFHLE1BQU0sNkhBQU87Z0JBQzNDLE1BQU1DLGdCQUFnQkQ7Z0JBRXRCLCtEQUErRDtnQkFDL0Qsd0ZBQXdGO2dCQUN4RixJQUFJO29CQUNGLE1BQU0sRUFBRWxELE1BQU1vRCxZQUFZLEVBQUV4RCxPQUFPeUQsY0FBYyxFQUFFLEdBQUcsTUFBTUYsY0FDekRqRCxJQUFJLENBQUMsU0FDTEMsTUFBTSxDQUFDLE1BQ1BDLEVBQUUsQ0FBQyxNQUFNVixRQUNUWSxXQUFXO29CQUVkLDBEQUEwRDtvQkFDMUQsSUFBSSxDQUFDK0Msa0JBQWtCLENBQUNELGNBQWM7d0JBQ3BDNUQsUUFBUUMsR0FBRyxDQUFDO3dCQUVaLDJCQUEyQjt3QkFDM0IsSUFBSTZEO3dCQUNKLElBQUk7NEJBQ0YsTUFBTSxFQUFFeEUsa0JBQWtCLEVBQUUsR0FBRyxNQUFNLDZIQUFPOzRCQUM1QyxNQUFNeUUsaUJBQWlCLE1BQU16RTs0QkFDN0IsTUFBTSxFQUFFa0IsTUFBTSxFQUFFeUMsSUFBSSxFQUFFLEVBQUUsR0FBRyxNQUFNYyxlQUFlWixJQUFJLENBQUNDLE9BQU87NEJBQzVEVSxZQUFZYixNQUFNZSxTQUFTLENBQUMsS0FBSyxFQUFFOUQsT0FBTyxVQUFVLENBQUM7d0JBQ3ZELEVBQUUsT0FBTTs0QkFDTjRELFlBQVksQ0FBQyxLQUFLLEVBQUU1RCxPQUFPLFVBQVUsQ0FBQzt3QkFDeEM7d0JBRUEsTUFBTSxFQUFFRSxPQUFPNkQsZUFBZSxFQUFFLEdBQUcsTUFBTU4sY0FDdENqRCxJQUFJLENBQUMsU0FDTHdELE1BQU0sQ0FBQzs0QkFDTjFCLElBQUl0Qzs0QkFDSjhELE9BQU9GOzRCQUNQSyxZQUFZLElBQUlDLE9BQU9DLFdBQVc7NEJBQ2xDQyxZQUFZLElBQUlGLE9BQU9DLFdBQVc7d0JBQ3BDO3dCQUVGLElBQUlKLGlCQUFpQjs0QkFDbkIsMkRBQTJEOzRCQUMzRCxJQUFJQSxnQkFBZ0JNLElBQUksS0FBSyxXQUFXTixnQkFBZ0JPLE9BQU8sRUFBRUMsU0FBUyxXQUFXO2dDQUNuRixNQUFNLEVBQUVyRSxPQUFPc0UsWUFBWSxFQUFFLEdBQUcsTUFBTWYsY0FDbkNqRCxJQUFJLENBQUMsU0FDTHdELE1BQU0sQ0FBQztvQ0FBRTFCLElBQUl0QztnQ0FBTztnQ0FDdkIsSUFBSXdFLGNBQWM7b0NBQ2hCMUUsUUFBUTJFLElBQUksQ0FBQyx5REFBeUREO2dDQUN4RSxPQUFPO29DQUNMMUUsUUFBUUMsR0FBRyxDQUFDO2dDQUNkOzRCQUNGLE9BQU87Z0NBQ0xELFFBQVEyRSxJQUFJLENBQUMseURBQXlEVjs0QkFDeEU7d0JBQ0YsT0FBTzs0QkFDTGpFLFFBQVFDLEdBQUcsQ0FBQzt3QkFDZDtvQkFDRixPQUFPLElBQUk0RCxrQkFBa0JBLGVBQWVVLElBQUksS0FBSyxZQUFZO3dCQUMvRHZFLFFBQVEyRSxJQUFJLENBQUMsdURBQXVEZDtvQkFDdEU7Z0JBQ0YsRUFBRSxPQUFPekQsT0FBTztvQkFDZCw0Q0FBNEM7b0JBQzVDSixRQUFRQyxHQUFHLENBQUMsdUVBQXVFRztnQkFDckY7Z0JBRUEsSUFBSTtvQkFDRixNQUFNLEVBQUVJLE1BQU1vRSxXQUFXLEVBQUV4RSxPQUFPeUUsV0FBVyxFQUFFLEdBQUcsTUFBTWxCLGNBQ3JEakQsSUFBSSxDQUFDLGNBQ0x3RCxNQUFNLENBQUM7d0JBQ05ZLFNBQVM1RTt3QkFDVDZFLE1BQU12Qjt3QkFDTkMsVUFBVUE7d0JBQ1Z1QixXQUFXLENBQUMsS0FBSyxFQUFFWixLQUFLYSxHQUFHLEdBQUcsQ0FBQzt3QkFDL0JDLFVBQVU7b0JBQ1osR0FDQ3ZFLE1BQU0sQ0FBQyxNQUNQd0UsTUFBTTtvQkFFVCxJQUFJTixlQUFlLENBQUNELGFBQWE7d0JBQy9CNUUsUUFBUUksS0FBSyxDQUFDLHNEQUFzRHlFO3dCQUVwRSwrQ0FBK0M7d0JBQy9DLElBQUlBLGFBQWFOLFNBQVMsV0FBV00sYUFBYUwsU0FBU0MsU0FBUyxVQUFVOzRCQUM1RXpFLFFBQVFJLEtBQUssQ0FBQzs0QkFDZEosUUFBUUksS0FBSyxDQUFDOzRCQUNkSixRQUFRSSxLQUFLLENBQUM7NEJBQ2RKLFFBQVFJLEtBQUssQ0FBQzs0QkFFZCxPQUFPZixxREFBWUEsQ0FBQ2MsSUFBSSxDQUN0QjtnQ0FDRUMsT0FBTztnQ0FDUGdGLFNBQVM7Z0NBQ1RiLE1BQU07Z0NBQ05jLFVBQVU7b0NBQ1JDLFdBQVc7b0NBQ1hDLFVBQVU7b0NBQ1ZDLGNBQWM7d0NBQ1o7d0NBQ0E7d0NBQ0E7d0NBQ0E7d0NBQ0E7d0NBQ0E7d0NBQ0E7cUNBQ0Q7b0NBQ0RDLGFBQWE7Z0NBQ2Y7NEJBQ0YsR0FDQTtnQ0FBRXBGLFFBQVE7NEJBQUk7d0JBRWxCO3dCQUVBLE9BQU9oQixxREFBWUEsQ0FBQ2MsSUFBSSxDQUN0Qjs0QkFBRUMsT0FBTzs0QkFBeUZnRixTQUFTUCxhQUFhTDt3QkFBUSxHQUNoSTs0QkFBRW5FLFFBQVE7d0JBQUk7b0JBRWxCO29CQUVBQyxhQUFhc0UsWUFBWXBDLEVBQUU7b0JBQzNCeEMsUUFBUUMsR0FBRyxDQUFDLDZDQUE2Q0s7Z0JBQzNELEVBQUUsT0FBT0YsT0FBTztvQkFDZEosUUFBUUksS0FBSyxDQUFDLG9EQUFvREE7b0JBQ2xFLE9BQU9mLHFEQUFZQSxDQUFDYyxJQUFJLENBQ3RCO3dCQUFFQyxPQUFPO3dCQUFnR2dGLFNBQVNoRixpQkFBaUJzRixRQUFRdEYsTUFBTW9FLE9BQU8sR0FBRztvQkFBZ0IsR0FDM0s7d0JBQUVuRSxRQUFRO29CQUFJO2dCQUVsQjtZQUNGLE9BQU87Z0JBQ0xMLFFBQVFJLEtBQUssQ0FBQyx3REFBd0RGO2dCQUN0RSxPQUFPYixxREFBWUEsQ0FBQ2MsSUFBSSxDQUN0QjtvQkFBRUMsT0FBTztnQkFBK0YsR0FDeEc7b0JBQUVDLFFBQVE7Z0JBQUk7WUFFbEI7UUFDRjtRQUVBTCxRQUFRQyxHQUFHLENBQUMsd0NBQXdDSztRQUVwRCxxRkFBcUY7UUFDckYsTUFBTSxFQUFFcUYsZ0JBQWdCLEVBQUUzQixLQUFLLEVBQUU0QixTQUFTLEVBQUVDLFVBQVUsRUFBRTFFLGlCQUFpQjJFLGdCQUFnQixFQUFFLEdBQUd6QztRQUU5RixNQUFNOUMsV0FBVyxNQUFNakIsMkRBQWtCQTtRQUV6Qyx3REFBd0Q7UUFDeEQsSUFBSXdFLFlBQVlFO1FBQ2hCLElBQUksQ0FBQ0YsV0FBVztZQUNkLElBQUk7Z0JBQ0YscUNBQXFDO2dCQUNyQyxNQUFNLEVBQUV0RCxNQUFNLEVBQUV5QyxJQUFJLEVBQUUsRUFBRTdDLE9BQU84QyxTQUFTLEVBQUUsR0FBRyxNQUFNM0MsU0FBUzRDLElBQUksQ0FBQ0MsT0FBTztnQkFDeEUsSUFBSSxDQUFDRixhQUFhRCxNQUFNZSxPQUFPO29CQUM3QkYsWUFBWWIsS0FBS2UsS0FBSztvQkFDdEJoRSxRQUFRQyxHQUFHLENBQUMsd0RBQXdENkQ7Z0JBQ3RFLE9BQU87b0JBQ0w5RCxRQUFRMkUsSUFBSSxDQUFDLDJFQUEyRXpCO29CQUN4RiwwRUFBMEU7b0JBQzFFWSxZQUFZLENBQUMsS0FBSyxFQUFFNUQsT0FBTyxVQUFVLENBQUM7b0JBQ3RDRixRQUFRQyxHQUFHLENBQUMsaURBQWlENkQ7Z0JBQy9EO1lBQ0YsRUFBRSxPQUFPMUQsT0FBTztnQkFDZEosUUFBUUksS0FBSyxDQUFDLGdEQUFnREE7Z0JBQzlELHlDQUF5QztnQkFDekMwRCxZQUFZLENBQUMsS0FBSyxFQUFFNUQsT0FBTyxVQUFVLENBQUM7Z0JBQ3RDRixRQUFRQyxHQUFHLENBQUMsNkRBQTZENkQ7WUFDM0U7UUFDRjtRQUVBLElBQUksQ0FBQ0EsV0FBVztZQUNkOUQsUUFBUUksS0FBSyxDQUFDO1lBQ2QsT0FBT2YscURBQVlBLENBQUNjLElBQUksQ0FDdEI7Z0JBQUVDLE9BQU87WUFBaUYsR0FDMUY7Z0JBQUVDLFFBQVE7WUFBSTtRQUVsQjtRQUVBLG9EQUFvRDtRQUNwRCxNQUFNLEVBQUVHLE1BQU1DLFFBQVEsRUFBRUwsT0FBTzJGLGFBQWEsRUFBRSxHQUFHLE1BQU14RixTQUNwREcsSUFBSSxDQUFDLGNBQ0xDLE1BQU0sQ0FBQywwR0FDUEMsRUFBRSxDQUFDLE1BQU1OLFlBQ1Q2RSxNQUFNO1FBRVQsSUFBSVksaUJBQWlCLENBQUN0RixVQUFVO1lBQzlCLE9BQU9wQixxREFBWUEsQ0FBQ2MsSUFBSSxDQUN0QjtnQkFBRUMsT0FBTztZQUFxQixHQUM5QjtnQkFBRUMsUUFBUTtZQUFJO1FBRWxCO1FBRUEsSUFBSTJGLFlBQVl2RixTQUFTUSx5QkFBeUIsSUFBSTBFO1FBRXRELDREQUE0RDtRQUM1RCxJQUFJQSxrQkFBa0I7WUFDcEIsTUFBTXpFLFVBQVUsTUFBTXZCLGlFQUFvQkEsQ0FBQ2dHO1lBQzNDLElBQUksQ0FBQ3pFLFNBQVM7Z0JBQ1osT0FBTzdCLHFEQUFZQSxDQUFDYyxJQUFJLENBQ3RCO29CQUFFQyxPQUFPO2dCQUEwRSxHQUNuRjtvQkFBRUMsUUFBUTtnQkFBSTtZQUVsQjtZQUNBMkYsWUFBWUw7WUFFWiwrQkFBK0I7WUFDL0IsTUFBTXBGLFNBQ0hHLElBQUksQ0FBQyxjQUNMdUYsTUFBTSxDQUFDO2dCQUNOaEYsMkJBQTJCK0U7Z0JBQzNCMUIsWUFBWSxJQUFJRixPQUFPQyxXQUFXO1lBQ3BDLEdBQ0N6RCxFQUFFLENBQUMsTUFBTU47UUFDZDtRQUVBLHdEQUF3RDtRQUN4RCxJQUFJLENBQUMwRixXQUFXO1lBQ2RBLFlBQVksTUFBTXZHLGlFQUFvQkEsQ0FBQ1MsUUFBUTREO1lBRS9DLG9FQUFvRTtZQUNwRSxNQUFNdkQsU0FDSEcsSUFBSSxDQUFDLGNBQ0x1RixNQUFNLENBQUM7Z0JBQ05oRiwyQkFBMkIrRTtnQkFDM0IxQixZQUFZLElBQUlGLE9BQU9DLFdBQVc7WUFDcEMsR0FDQ3pELEVBQUUsQ0FBQyxNQUFNTjtZQUVaLHFDQUFxQztZQUNyQyxzRkFBc0Y7WUFDdEYsTUFBTTRGLG1CQUFtQk4sYUFBYSxDQUFDLEVBQUUzRCx1QkFBK0IsSUFBSSxFQUF3QixXQUFXLENBQUM7WUFDaEgsTUFBTW1FLG9CQUFvQlAsY0FBYyxDQUFDLEVBQUU1RCx1QkFBK0IsSUFBSSxFQUF3QixXQUFXLENBQUM7WUFFbEgsTUFBTW9FLGlCQUFpQixNQUFNM0csOERBQWlCQSxDQUFDc0csV0FBV0Usa0JBQWtCRTtZQUU1RSxPQUFPL0cscURBQVlBLENBQUNjLElBQUksQ0FBQztnQkFDdkJtRyxTQUFTO2dCQUNURDtnQkFDQVYsa0JBQWtCSztnQkFDbEJ4QixTQUFTO1lBQ1g7UUFDRjtRQUVBLDBCQUEwQjtRQUMxQixNQUFNK0IsYUFBYSxNQUFNNUcsaUVBQW9CQSxDQUFDcUc7UUFDOUMsSUFBSSxDQUFDTyxZQUFZO1lBQ2YsTUFBTUwsbUJBQW1CTixhQUFhLENBQUMsRUFBRTNELHVCQUErQixJQUFJLEVBQXdCLFdBQVcsQ0FBQztZQUNoSCxNQUFNbUUsb0JBQW9CUCxjQUFjLENBQUMsRUFBRTVELHVCQUErQixJQUFJLEVBQXdCLFdBQVcsQ0FBQztZQUVsSCxNQUFNb0UsaUJBQWlCLE1BQU0zRyw4REFBaUJBLENBQUNzRyxXQUFXRSxrQkFBa0JFO1lBRTVFLE9BQU8vRyxxREFBWUEsQ0FBQ2MsSUFBSSxDQUFDO2dCQUN2Qm1HLFNBQVM7Z0JBQ1REO2dCQUNBVixrQkFBa0JLO2dCQUNsQnhCLFNBQVM7WUFDWDtRQUNGO1FBRUEsaURBQWlEO1FBQ2pELElBQUlnQztRQUNKLElBQUkvRixTQUFTZ0csa0JBQWtCLEVBQUU7WUFDL0JELGFBQWEvRixTQUFTZ0csa0JBQWtCO1FBQzFDLE9BQU87WUFDTCxNQUFNakQsZUFBZS9DLFNBQVNzRSxJQUFJLElBQUk7WUFDdEMsTUFBTTJCLGdCQUFnQixNQUFNOUcsZ0VBQW1CQSxDQUFDa0UsV0FBV04sY0FBYztnQkFDdkVtRCxhQUFhckc7Z0JBQ2J3RSxTQUFTNUU7WUFDWDtZQUNBc0csYUFBYUU7WUFFYixNQUFNbkcsU0FDSEcsSUFBSSxDQUFDLGNBQ0x1RixNQUFNLENBQUM7Z0JBQ05RLG9CQUFvQkQ7Z0JBQ3BCbEMsWUFBWSxJQUFJRixPQUFPQyxXQUFXO1lBQ3BDLEdBQ0N6RCxFQUFFLENBQUMsTUFBTU47UUFDZDtRQUVBLG9DQUFvQztRQUNwQyxpR0FBaUc7UUFDakcsNEVBQTRFO1FBQzVFLElBQUlzRyxpQkFBaUJuRyxTQUFTbUIsc0JBQXNCO1FBRXBELG9FQUFvRTtRQUNwRSxHQUFHO1FBQ0gsV0FBVztRQUNYLDZEQUE2RDtRQUM3RCxzREFBc0Q7UUFDdEQsMERBQTBEO1FBQzFELG1EQUFtRDtRQUNuRCxFQUFFO1FBQ0Ysa0VBQWtFO1FBQ2xFLDZEQUE2RDtRQUM3RCxNQUFNaUYsdUJBQXVCcEcsU0FBU3FHLHFCQUFxQixLQUFLLE1BQU0sNEJBQTRCO1FBQ2xHLE1BQU1DLFdBQVdGLHVCQUF1QixRQUFRO1FBQ2hELE1BQU1HLFlBQVlILHVCQUF1QixRQUFRO1FBRWpEN0csUUFBUUMsR0FBRyxDQUFDLENBQUMsbUNBQW1DLEVBQUVLLFdBQVcsQ0FBQyxDQUFDO1FBQy9ETixRQUFRQyxHQUFHLENBQUMsQ0FBQywyQkFBMkIsRUFBRVEsU0FBU3FHLHFCQUFxQixDQUFDLENBQUM7UUFDMUU5RyxRQUFRQyxHQUFHLENBQUMsQ0FBQyxVQUFVLEVBQUU4RyxTQUFTLEdBQUcsRUFBRUMsVUFBVSxPQUFPLENBQUM7UUFFekQsTUFBTUMsMkJBQTJCaEYsUUFBUUMsR0FBRyxDQUFDZ0YsdUNBQXVDLElBQUlqRixRQUFRQyxHQUFHLENBQUNpRixtREFBbUQ7UUFDdkosTUFBTUMsOEJBQThCbkYsUUFBUUMsR0FBRyxDQUFDbUYsMENBQTBDLElBQUlwRixRQUFRQyxHQUFHLENBQUNvRixzREFBc0Q7UUFFaEssOERBQThEO1FBQzlELE1BQU1DLGtCQUFrQnRGLFFBQVFDLEdBQUcsQ0FBQ3NGLG9CQUFvQixJQUFJdkYsUUFBUUMsR0FBRyxDQUFDdUYsZ0NBQWdDO1FBRXhHLE1BQU1DLGdCQUFvQ2IsdUJBQ3JDSSw0QkFBNEJNLGtCQUM1QkgsK0JBQStCRztRQUVwQ3ZILFFBQVFDLEdBQUcsQ0FBQyxDQUFDLDhCQUE4QixFQUFFeUgsY0FBYyxDQUFDO1FBQzVEMUgsUUFBUUMsR0FBRyxDQUFDLENBQUMscUJBQXFCLEVBQUU0Ryx1QkFBdUIsdUJBQXVCLHdCQUF3QixDQUFDO1FBRTNHLElBQUksQ0FBQ0QsZ0JBQWdCO1lBQ25CLElBQUksQ0FBQ2MsZUFBZTtnQkFDbEIxSCxRQUFRSSxLQUFLLENBQUM7Z0JBQ2QsT0FBT2YscURBQVlBLENBQUNjLElBQUksQ0FDdEI7b0JBQ0VDLE9BQU87b0JBQ1BnRixTQUFTO2dCQUNYLEdBQ0E7b0JBQUUvRSxRQUFRO2dCQUFJO1lBRWxCO1lBQ0EsSUFBSTtnQkFDRixpRUFBaUU7Z0JBQ2pFLGtGQUFrRjtnQkFDbEYsTUFBTXNILHNCQUFzQnRFLEtBQUsxQixlQUFlO2dCQUNoRCxNQUFNUyxlQUFlLE1BQU12QywrREFBa0JBLENBQzNDMkcsWUFDQWtCLGVBQ0E7b0JBQ0VmLGFBQWFyRztvQkFDYndFLFNBQVM1RTtnQkFDWCxHQUNBeUg7Z0JBR0ZmLGlCQUFpQnhFLGFBQWF3RSxjQUFjO2dCQUU1Qyw0RUFBNEU7Z0JBQzVFLDZDQUE2QztnQkFDN0MsTUFBTWdCLGFBQWF4RixhQUFheUYsU0FBUyxHQUNyQyxJQUFJekQsS0FBS2hDLGFBQWF5RixTQUFTLEdBQUcsTUFBTXhELFdBQVcsS0FDbkRqQyxhQUFhMEYsa0JBQWtCLEdBQy9CLElBQUkxRCxLQUFLaEMsYUFBYTBGLGtCQUFrQixHQUFHLE1BQU16RCxXQUFXLEtBQzVEO2dCQUVKLGdDQUFnQztnQkFDaEMsNkVBQTZFO2dCQUM3RSxJQUFJNUMscUJBQXFCO2dCQUN6QixJQUFJVyxhQUFhL0IsTUFBTSxLQUFLLFVBQVU7b0JBQ3BDb0IscUJBQXFCO2dCQUN2QixPQUFPLElBQUlXLGFBQWEvQixNQUFNLEtBQUssWUFBWTtvQkFDN0NvQixxQkFBcUI7Z0JBQ3ZCLE9BQU8sSUFBSVcsYUFBYS9CLE1BQU0sS0FBSyxnQkFBZ0IrQixhQUFhL0IsTUFBTSxLQUFLLHNCQUFzQjtvQkFDL0ZvQixxQkFBcUIsU0FBUyx1REFBdUQ7Z0JBQ3ZGO2dCQUVBLGlFQUFpRTtnQkFDakUsTUFBTSxFQUFFckIsT0FBTzJILFdBQVcsRUFBRSxHQUFHLE1BQU14SCxTQUNsQ0csSUFBSSxDQUFDLGNBQ0x1RixNQUFNLENBQUM7b0JBQ05yRSx3QkFBd0JnRjtvQkFDeEJvQixpQkFBaUJOO29CQUNqQmhHLHFCQUFxQkQ7b0JBQ3JCaUIsZUFBZU4sYUFBYXlGLFNBQVMsR0FDakMsSUFBSXpELEtBQUtoQyxhQUFheUYsU0FBUyxHQUFHLE1BQU14RCxXQUFXLEtBQ25EO29CQUNKeEIsY0FBYytFO29CQUNkdEQsWUFBWSxJQUFJRixPQUFPQyxXQUFXO2dCQUNwQyxHQUNDekQsRUFBRSxDQUFDLE1BQU1OO2dCQUVaLElBQUl5SCxhQUFhO29CQUNmL0gsUUFBUUksS0FBSyxDQUFDLDBDQUEwQzJIO29CQUN4RCxNQUFNQTtnQkFDUjtnQkFFQSw4Q0FBOEM7Z0JBQzlDLE1BQU0sRUFBRXZILE1BQU15SCxnQkFBZ0IsRUFBRTdILE9BQU84SCxXQUFXLEVBQUUsR0FBRyxNQUFNM0gsU0FDMURHLElBQUksQ0FBQyxjQUNMQyxNQUFNLENBQUMsdUZBQ1BDLEVBQUUsQ0FBQyxNQUFNTixZQUNUNkUsTUFBTTtnQkFFVCxJQUFJK0MsYUFBYTtvQkFDZmxJLFFBQVFJLEtBQUssQ0FBQyxzQ0FBc0M4SDtnQkFDdEQsT0FBTztvQkFDTGxJLFFBQVFDLEdBQUcsQ0FBQztvQkFDWkQsUUFBUUMsR0FBRyxDQUFDLENBQUMscUJBQXFCLEVBQUVnSSxpQkFBaUJyRyxzQkFBc0IsQ0FBQyxDQUFDO29CQUM3RTVCLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLGNBQWMsRUFBRWdJLGlCQUFpQkQsZUFBZSxDQUFDLENBQUM7b0JBQy9EaEksUUFBUUMsR0FBRyxDQUFDLENBQUMsMkJBQTJCLEVBQUVnSSxpQkFBaUJuQixxQkFBcUIsQ0FBQyxDQUFDO29CQUNsRjlHLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLFlBQVksRUFBRWdJLGlCQUFpQnZHLG1CQUFtQixDQUFDLENBQUM7b0JBQ2pFMUIsUUFBUUMsR0FBRyxDQUFDLENBQUMsVUFBVSxFQUFFZ0ksaUJBQWlCbkIscUJBQXFCLEdBQUcsdUJBQXVCLHVCQUF1QixDQUFDO2dCQUNuSDtZQUNGLEVBQUUsT0FBT3FCLG1CQUFtQjtnQkFDMUJuSSxRQUFRSSxLQUFLLENBQUMsZ0NBQWdDK0g7Z0JBQzlDLE9BQU85SSxxREFBWUEsQ0FBQ2MsSUFBSSxDQUN0QjtvQkFDRUMsT0FBTztvQkFDUGdGLFNBQVMrQyw2QkFBNkJ6QyxRQUFReUMsa0JBQWtCM0QsT0FBTyxHQUFHO2dCQUM1RSxHQUNBO29CQUFFbkUsUUFBUTtnQkFBSTtZQUVsQjtRQUNGO1FBRUEsNENBQTRDO1FBQzVDLElBQUl5RixvQkFBb0JzQyxNQUFNQyxPQUFPLENBQUN2QyxxQkFBcUJBLGlCQUFpQnpFLE1BQU0sR0FBRyxHQUFHO1lBQ3RGLElBQUk7Z0JBQ0YsZ0VBQWdFO2dCQUNoRSxNQUFNZCxTQUNIRyxJQUFJLENBQUMsbUJBQ0x1RixNQUFNLENBQUM7b0JBQUVxQyxTQUFTO2dCQUFNLEdBQ3hCMUgsRUFBRSxDQUFDLGVBQWVOO2dCQUVyQiwrQ0FBK0M7Z0JBQy9DLE1BQU1pSSxnQkFBZ0J6QyxpQkFBaUJ4RSxHQUFHLENBQUMsQ0FBQ0UsU0FBb0I7d0JBQzlEbUYsYUFBYXJHO3dCQUNid0UsU0FBUzVFO3dCQUNUc0IsUUFBUUEsV0FBVyxZQUFZLGNBQWNBO3dCQUM3QzhHLFNBQVM7d0JBQ1RuRSxZQUFZLElBQUlDLE9BQU9DLFdBQVc7d0JBQ2xDQyxZQUFZLElBQUlGLE9BQU9DLFdBQVc7b0JBQ3BDO2dCQUVBLG1EQUFtRDtnQkFDbkQsSUFBSXlCLGlCQUFpQnJCLFFBQVEsQ0FBQyxZQUFZO29CQUN4QzhELGNBQWNDLElBQUksQ0FBQzt3QkFDakI3QixhQUFhckc7d0JBQ2J3RSxTQUFTNUU7d0JBQ1RzQixRQUFRO3dCQUNSOEcsU0FBUzt3QkFDVG5FLFlBQVksSUFBSUMsT0FBT0MsV0FBVzt3QkFDbENDLFlBQVksSUFBSUYsT0FBT0MsV0FBVztvQkFDcEM7Z0JBQ0Y7Z0JBRUEsa0NBQWtDO2dCQUNsQyxJQUFJLENBQUN5QixpQkFBaUJyQixRQUFRLENBQUMsU0FBUztvQkFDdEM4RCxjQUFjQyxJQUFJLENBQUM7d0JBQ2pCN0IsYUFBYXJHO3dCQUNid0UsU0FBUzVFO3dCQUNUc0IsUUFBUTt3QkFDUjhHLFNBQVM7d0JBQ1RuRSxZQUFZLElBQUlDLE9BQU9DLFdBQVc7d0JBQ2xDQyxZQUFZLElBQUlGLE9BQU9DLFdBQVc7b0JBQ3BDO2dCQUNGO2dCQUVBLHlCQUF5QjtnQkFDekIsTUFBTSxFQUFFakUsT0FBT3FJLG1CQUFtQixFQUFFLEdBQUcsTUFBTWxJLFNBQzFDRyxJQUFJLENBQUMsbUJBQ0xnSSxNQUFNLENBQUNILGVBQWU7b0JBQ3JCSSxZQUFZO29CQUNaQyxrQkFBa0I7Z0JBQ3BCO2dCQUVGLElBQUlILHFCQUFxQjtvQkFDdkJ6SSxRQUFRSSxLQUFLLENBQUMseURBQXlEcUk7Z0JBQ3ZFLHVEQUF1RDtnQkFDekQsT0FBTztvQkFDTHpJLFFBQVFDLEdBQUcsQ0FBQyxrREFBa0RzSSxjQUFjakgsR0FBRyxDQUFDUyxDQUFBQSxJQUFLQSxFQUFFUCxNQUFNO2dCQUMvRjtZQUNGLEVBQUUsT0FBT3BCLE9BQU87Z0JBQ2QsMERBQTBEO2dCQUMxREosUUFBUUMsR0FBRyxDQUFDLG1GQUFtRkc7WUFDakc7UUFDRjtRQUVBLE9BQU9mLHFEQUFZQSxDQUFDYyxJQUFJLENBQUM7WUFDdkJtRyxTQUFTO1lBQ1RYLGtCQUFrQks7WUFDbEJZLGdCQUFnQkEsa0JBQWtCO1lBQ2xDcEMsU0FBUztRQUNYO0lBQ0YsRUFBRSxPQUFPcEUsT0FBTztRQUNkSixRQUFRSSxLQUFLLENBQUMsbUNBQW1DQTtRQUNqRCxPQUFPZixxREFBWUEsQ0FBQ2MsSUFBSSxDQUN0QjtZQUFFQyxPQUFPO1lBQXlCZ0YsU0FBU2hGLGlCQUFpQnNGLFFBQVF0RixNQUFNb0UsT0FBTyxHQUFHO1FBQWdCLEdBQ3BHO1lBQUVuRSxRQUFRO1FBQUk7SUFFbEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL3NyYy9hcHAvYXBpL2J1c2luZXNzL29uYm9hcmRpbmcvc3RlcC0xMS1wYXltZW50LXNldHVwL3JvdXRlLnRzPzRhMzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuaW1wb3J0IHsgY3JlYXRlU2VydmVyQ2xpZW50IH0gZnJvbSAnQC9saWIvZGInO1xuaW1wb3J0IHsgZ2V0Q3VycmVudFVzZXJJZCwgZ2V0Q3VycmVudEJ1c2luZXNzSWQgfSBmcm9tICdAL2xpYi9hdXRoJztcbmltcG9ydCB7XG4gIGNyZWF0ZUNvbm5lY3RBY2NvdW50LFxuICBjcmVhdGVBY2NvdW50TGluayxcbiAgdmVyaWZ5Q29ubmVjdEFjY291bnQsXG4gIGNyZWF0ZU9yR2V0Q3VzdG9tZXIsXG4gIGNyZWF0ZVN1YnNjcmlwdGlvbixcbn0gZnJvbSAnQC9saWIvc3RyaXBlJztcblxuLyoqXG4gKiBHRVQgL2FwaS9idXNpbmVzcy9vbmJvYXJkaW5nL3N0ZXAtMTEtcGF5bWVudC1zZXR1cFxuICogXG4gKiBSZXRyaWV2ZXMgcGF5bWVudCBzZXR1cCBjb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBHRVQocmVxdWVzdDogUmVxdWVzdCkge1xuICBjb25zb2xlLmxvZygnW3N0ZXAtMTEtcGF5bWVudC1zZXR1cF0gQVBJIGNhbGxlZCAtIEdFVCAvYXBpL2J1c2luZXNzL29uYm9hcmRpbmcvc3RlcC0xMS1wYXltZW50LXNldHVwJyk7XG4gIHRyeSB7XG4gICAgY29uc3QgdXNlcklkID0gYXdhaXQgZ2V0Q3VycmVudFVzZXJJZCgpO1xuICAgIGlmICghdXNlcklkKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdVbmF1dGhvcml6ZWQnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDEgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBidXNpbmVzc0lkID0gYXdhaXQgZ2V0Q3VycmVudEJ1c2luZXNzSWQoKTtcbiAgICBpZiAoIWJ1c2luZXNzSWQpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0J1c2luZXNzIG5vdCBmb3VuZCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwNCB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHN1cGFiYXNlID0gYXdhaXQgY3JlYXRlU2VydmVyQ2xpZW50KCk7XG4gICAgY29uc3QgeyBkYXRhOiBidXNpbmVzcywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYnVzaW5lc3NlcycpXG4gICAgICAuc2VsZWN0KCdzdHJpcGVfY29ubmVjdF9hY2NvdW50X2lkLCBzdHJpcGVfc3Vic2NyaXB0aW9uX2lkLCBzdWJzY3JpcHRpb25fc3RhdHVzLCB0cmlhbF9lbmRzX2F0LCBuZXh0X2JpbGxfYXQsIG5vdGlmaWNhdGlvbnNfZW5hYmxlZCcpXG4gICAgICAuZXEoJ2lkJywgYnVzaW5lc3NJZClcbiAgICAgIC5pcygnZGVsZXRlZF9hdCcsIG51bGwpXG4gICAgICAubWF5YmVTaW5nbGUoKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW3N0ZXAtMTEtcGF5bWVudC1zZXR1cF0gRXJyb3IgZmV0Y2hpbmcgYnVzaW5lc3M6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnRmFpbGVkIHRvIGZldGNoIHBheW1lbnQgc2V0dXAgZGF0YScgfSxcbiAgICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghYnVzaW5lc3MpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBwYXltZW50U2V0dXA6IG51bGwgfSxcbiAgICAgICAgeyBzdGF0dXM6IDIwMCB9XG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSBjb25uZWN0IHN0YXR1c1xuICAgIGxldCBjb25uZWN0U3RhdHVzOiBcIm5vdF9zdGFydGVkXCIgfCBcImluX3Byb2dyZXNzXCIgfCBcImNvbXBsZXRlZFwiID0gXCJub3Rfc3RhcnRlZFwiO1xuICAgIGlmIChidXNpbmVzcy5zdHJpcGVfY29ubmVjdF9hY2NvdW50X2lkKSB7XG4gICAgICAvLyBDaGVjayBpZiBhY2NvdW50IGlzIGZ1bGx5IG9uYm9hcmRlZCBieSB2ZXJpZnlpbmcgd2l0aCBTdHJpcGVcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgdmVyaWZ5Q29ubmVjdEFjY291bnQgfSA9IGF3YWl0IGltcG9ydCgnQC9saWIvc3RyaXBlJyk7XG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCB2ZXJpZnlDb25uZWN0QWNjb3VudChidXNpbmVzcy5zdHJpcGVfY29ubmVjdF9hY2NvdW50X2lkKTtcbiAgICAgICAgY29ubmVjdFN0YXR1cyA9IGlzVmFsaWQgPyBcImNvbXBsZXRlZFwiIDogXCJpbl9wcm9ncmVzc1wiO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIGNvbm5lY3RTdGF0dXMgPSBcImluX3Byb2dyZXNzXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0IGFjY2VwdGVkIHBheW1lbnQgbWV0aG9kcyBmcm9tIHBheW1lbnRfbWV0aG9kcyB0YWJsZSBpZiBpdCBleGlzdHNcbiAgICBsZXQgYWNjZXB0ZWRNZXRob2RzOiBzdHJpbmdbXSA9IFsnY2FyZCddOyAvLyBEZWZhdWx0XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YTogcGF5bWVudE1ldGhvZHMgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwYXltZW50X21ldGhvZHMnKVxuICAgICAgICAuc2VsZWN0KCdtZXRob2QnKVxuICAgICAgICAuZXEoJ2J1c2luZXNzX2lkJywgYnVzaW5lc3NJZClcbiAgICAgICAgLmVxKCdlbmFibGVkJywgdHJ1ZSk7XG4gICAgICBcbiAgICAgIGlmIChwYXltZW50TWV0aG9kcyAmJiBwYXltZW50TWV0aG9kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFjY2VwdGVkTWV0aG9kcyA9IHBheW1lbnRNZXRob2RzLm1hcChwbSA9PiBwbS5tZXRob2QpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBwYXltZW50X21ldGhvZHMgdGFibGUgbWlnaHQgbm90IGV4aXN0LCB1c2UgZGVmYXVsdFxuICAgICAgY29uc29sZS5sb2coJ1tzdGVwLTExLXBheW1lbnQtc2V0dXBdIENvdWxkIG5vdCBmZXRjaCBwYXltZW50IG1ldGhvZHMsIHVzaW5nIGRlZmF1bHQnKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgc3Vic2NyaXB0aW9uIHN0YXR1c1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvblN0YXR1cyA9IChidXNpbmVzcy5zdWJzY3JpcHRpb25fc3RhdHVzIGFzIFwidHJpYWxcIiB8IFwiYWN0aXZlXCIgfCBcInBhdXNlZFwiIHwgXCJjYW5jZWxlZFwiKSB8fCBcInRyaWFsXCI7XG5cbiAgICAvLyBHZXQgcGF5bWVudCBtZXRob2QgSUQgZnJvbSBTdHJpcGUgc3Vic2NyaXB0aW9uIGlmIGF2YWlsYWJsZVxuICAgIGxldCBwYXltZW50TWV0aG9kSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBpZiAoYnVzaW5lc3Muc3RyaXBlX3N1YnNjcmlwdGlvbl9pZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RyaXBlID0gYXdhaXQgaW1wb3J0KCdzdHJpcGUnKS50aGVuKG0gPT4gbmV3IG0uZGVmYXVsdChwcm9jZXNzLmVudi5TVFJJUEVfU0VDUkVUX0tFWSEpKTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYXdhaXQgc3RyaXBlLnN1YnNjcmlwdGlvbnMucmV0cmlldmUoYnVzaW5lc3Muc3RyaXBlX3N1YnNjcmlwdGlvbl9pZCk7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24uZGVmYXVsdF9wYXltZW50X21ldGhvZCkge1xuICAgICAgICAgIGNvbnN0IHBtID0gdHlwZW9mIHN1YnNjcmlwdGlvbi5kZWZhdWx0X3BheW1lbnRfbWV0aG9kID09PSAnc3RyaW5nJyBcbiAgICAgICAgICAgID8gc3Vic2NyaXB0aW9uLmRlZmF1bHRfcGF5bWVudF9tZXRob2QgXG4gICAgICAgICAgICA6IHN1YnNjcmlwdGlvbi5kZWZhdWx0X3BheW1lbnRfbWV0aG9kLmlkO1xuICAgICAgICAgIHBheW1lbnRNZXRob2RJZCA9IHBtO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbc3RlcC0xMS1wYXltZW50LXNldHVwXSBFcnJvciBmZXRjaGluZyBwYXltZW50IG1ldGhvZCBmcm9tIFN0cmlwZTonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGF5bWVudFNldHVwID0ge1xuICAgICAgY29ubmVjdFN0YXR1cyxcbiAgICAgIGFjY2VwdGVkTWV0aG9kcyxcbiAgICAgIHN1YnNjcmlwdGlvblN0YXR1cyxcbiAgICAgIHRyaWFsRW5kc0F0OiBidXNpbmVzcy50cmlhbF9lbmRzX2F0IHx8IHVuZGVmaW5lZCxcbiAgICAgIG5leHRCaWxsRGF0ZTogYnVzaW5lc3MubmV4dF9iaWxsX2F0IHx8IHVuZGVmaW5lZCxcbiAgICAgIHBheW1lbnRNZXRob2RJZCxcbiAgICB9O1xuXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgIHBheW1lbnRTZXR1cFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tzdGVwLTExLXBheW1lbnQtc2V0dXBdIEVycm9yOicsIGVycm9yKTtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7IGVycm9yOiAnSW50ZXJuYWwgc2VydmVyIGVycm9yJyB9LFxuICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIFBPU1QgL2FwaS9idXNpbmVzcy9vbmJvYXJkaW5nL3N0ZXAtMTEtcGF5bWVudC1zZXR1cFxuICogUFVUIC9hcGkvYnVzaW5lc3Mvb25ib2FyZGluZy9zdGVwLTExLXBheW1lbnQtc2V0dXBcbiAqIFxuICogU2V0cyB1cCBTdHJpcGUgQ29ubmVjdCBhY2NvdW50IGFuZCBzdWJzY3JpcHRpb25cbiAqIFxuICogQm9keToge1xuICogICBjb25uZWN0QWNjb3VudElkPzogc3RyaW5nLCAgLy8gSWYgcmV0dXJuaW5nIGZyb20gU3RyaXBlIG9uYm9hcmRpbmdcbiAqICAgZW1haWw6IHN0cmluZyxcbiAqICAgcmV0dXJuVXJsPzogc3RyaW5nLFxuICogICByZWZyZXNoVXJsPzogc3RyaW5nXG4gKiB9XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IFJlcXVlc3QpIHtcbiAgcmV0dXJuIGhhbmRsZVBheW1lbnRTZXR1cChyZXF1ZXN0KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFBVVChyZXF1ZXN0OiBSZXF1ZXN0KSB7XG4gIHJldHVybiBoYW5kbGVQYXltZW50U2V0dXAocmVxdWVzdCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVBheW1lbnRTZXR1cChyZXF1ZXN0OiBSZXF1ZXN0KSB7XG4gIGNvbnNvbGUubG9nKCdbc3RlcC0xMS1wYXltZW50LXNldHVwXSBBUEkgY2FsbGVkJyk7XG4gIHRyeSB7XG4gICAgLy8gVHJ5IHRvIGdldCB1c2VyIElEIC0gd2l0aCBiZXR0ZXIgZXJyb3IgaGFuZGxpbmdcbiAgICBsZXQgdXNlcklkID0gYXdhaXQgZ2V0Q3VycmVudFVzZXJJZCgpO1xuICAgIFxuICAgIC8vIElmIGdldEN1cnJlbnRVc2VySWQgZmFpbHMsIHRyeSB0byBnZXQgaXQgZnJvbSBTdXBhYmFzZSBjbGllbnQgZGlyZWN0bHlcbiAgICBpZiAoIXVzZXJJZCkge1xuICAgICAgY29uc29sZS5sb2coJ1tzdGVwLTExLXBheW1lbnQtc2V0dXBdIGdldEN1cnJlbnRVc2VySWQgcmV0dXJuZWQgbnVsbCwgdHJ5aW5nIGRpcmVjdCBTdXBhYmFzZSBjbGllbnQuLi4nKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN1cGFiYXNlID0gYXdhaXQgY3JlYXRlU2VydmVyQ2xpZW50KCk7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHVzZXIgJiYgIXVzZXJFcnJvcikge1xuICAgICAgICAgIHVzZXJJZCA9IHVzZXIuaWQ7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tzdGVwLTExLXBheW1lbnQtc2V0dXBdIEdvdCB1c2VyIElEIGZyb20gZGlyZWN0IFN1cGFiYXNlIGNsaWVudDonLCB1c2VySWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tzdGVwLTExLXBheW1lbnQtc2V0dXBdIERpcmVjdCBTdXBhYmFzZSBjbGllbnQgYWxzbyBmYWlsZWQ6JywgdXNlckVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW3N0ZXAtMTEtcGF5bWVudC1zZXR1cF0gRXJyb3IgZ2V0dGluZyB1c2VyIGZyb20gU3VwYWJhc2UgY2xpZW50OicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKCF1c2VySWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tzdGVwLTExLXBheW1lbnQtc2V0dXBdIE5vIHVzZXIgSUQgZm91bmQgLSB1bmF1dGhvcml6ZWQnKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ1VuYXV0aG9yaXplZCAtIFBsZWFzZSBzaWduIGluIGFnYWluJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAxIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKCdbc3RlcC0xMS1wYXltZW50LXNldHVwXSBVc2VyIGF1dGhlbnRpY2F0ZWQ6JywgdXNlcklkKTtcblxuICAgIC8vIFBhcnNlIHJlcXVlc3QgYm9keSBmaXJzdCAod2UgbmVlZCBpdCB0byBwb3RlbnRpYWxseSBjcmVhdGUgYnVzaW5lc3MpXG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlcXVlc3QuanNvbigpO1xuICAgIGNvbnNvbGUubG9nKCdbc3RlcC0xMS1wYXltZW50LXNldHVwXSBSZXF1ZXN0IGJvZHk6JywgSlNPTi5zdHJpbmdpZnkoYm9keSwgbnVsbCwgMikpO1xuICAgIFxuICAgIGxldCBidXNpbmVzc0lkID0gYXdhaXQgZ2V0Q3VycmVudEJ1c2luZXNzSWQoKTtcbiAgICBcbiAgICAvLyBJZiBubyBidXNpbmVzcyBleGlzdHMsIHRyeSB0byBjcmVhdGUgb25lIGZyb20gdGhlIHJlcXVlc3QgYm9keVxuICAgIC8vIFRoaXMgaGFuZGxlcyBjYXNlcyB3aGVyZSBzdGVwIDEgd2Fzbid0IGNvbXBsZXRlZCBvciB0aGUgYnVzaW5lc3Mgd2FzIGRlbGV0ZWRcbiAgICBpZiAoIWJ1c2luZXNzSWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbc3RlcC0xMS1wYXltZW50LXNldHVwXSBObyBidXNpbmVzcyBmb3VuZCwgY2hlY2tpbmcgaWYgd2UgY2FuIGNyZWF0ZSBvbmUgZnJvbSByZXF1ZXN0IGJvZHknKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBidXNpbmVzcyBkYXRhIGluIHRoZSByZXF1ZXN0XG4gICAgICBpZiAoYm9keS5idXNpbmVzc05hbWUgfHwgYm9keS5idXNpbmVzcz8uYnVzaW5lc3NOYW1lKSB7XG4gICAgICAgIGNvbnN0IGJ1c2luZXNzTmFtZSA9IGJvZHkuYnVzaW5lc3NOYW1lIHx8IGJvZHkuYnVzaW5lc3M/LmJ1c2luZXNzTmFtZSB8fCAnTXkgQnVzaW5lc3MnO1xuICAgICAgICBjb25zdCBpbmR1c3RyeSA9IGJvZHkuaW5kdXN0cnkgfHwgYm9keS5idXNpbmVzcz8uaW5kdXN0cnkgfHwgJ290aGVyJztcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdbc3RlcC0xMS1wYXltZW50LXNldHVwXSBDcmVhdGluZyBidXNpbmVzcyBmcm9tIHJlcXVlc3QgZGF0YTonLCB7IGJ1c2luZXNzTmFtZSwgaW5kdXN0cnkgfSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB7IGNyZWF0ZUFkbWluQ2xpZW50IH0gPSBhd2FpdCBpbXBvcnQoJ0AvbGliL2RiJyk7XG4gICAgICAgIGNvbnN0IGFkbWluU3VwYWJhc2UgPSBjcmVhdGVBZG1pbkNsaWVudCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gRmlyc3QsIGVuc3VyZSB1c2VyIGV4aXN0cyBpbiBwdWJsaWMudXNlcnMgdGFibGUgaWYgaXQgZXhpc3RzXG4gICAgICAgIC8vIFRoaXMgaGFuZGxlcyB0aGUgY2FzZSB3aGVyZSBmb3JlaWduIGtleSByZWZlcmVuY2VzIHB1YmxpYy51c2VycyBpbnN0ZWFkIG9mIGF1dGgudXNlcnNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nVXNlciwgZXJyb3I6IGNoZWNrVXNlckVycm9yIH0gPSBhd2FpdCBhZG1pblN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgICAgICAgLmVxKCdpZCcsIHVzZXJJZClcbiAgICAgICAgICAgIC5tYXliZVNpbmdsZSgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIElmIHVzZXJzIHRhYmxlIGV4aXN0cyBhbmQgdXNlciBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgaXRcbiAgICAgICAgICBpZiAoIWNoZWNrVXNlckVycm9yICYmICFleGlzdGluZ1VzZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbc3RlcC0xMS1wYXltZW50LXNldHVwXSB1c2VycyB0YWJsZSBleGlzdHMgYnV0IHVzZXIgbWlzc2luZyAtIGNyZWF0aW5nIHVzZXIgcmVjb3JkJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEdldCB1c2VyIGVtYWlsIGZyb20gYXV0aFxuICAgICAgICAgICAgbGV0IHVzZXJFbWFpbDogc3RyaW5nO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBjcmVhdGVTZXJ2ZXJDbGllbnQgfSA9IGF3YWl0IGltcG9ydCgnQC9saWIvZGInKTtcbiAgICAgICAgICAgICAgY29uc3Qgc3VwYWJhc2VDbGllbnQgPSBhd2FpdCBjcmVhdGVTZXJ2ZXJDbGllbnQoKTtcbiAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2VDbGllbnQuYXV0aC5nZXRVc2VyKCk7XG4gICAgICAgICAgICAgIHVzZXJFbWFpbCA9IHVzZXI/LmVtYWlsIHx8IGB1c2VyLSR7dXNlcklkfUB0aXRoaS5jb21gO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIHVzZXJFbWFpbCA9IGB1c2VyLSR7dXNlcklkfUB0aXRoaS5jb21gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCB7IGVycm9yOiBjcmVhdGVVc2VyRXJyb3IgfSA9IGF3YWl0IGFkbWluU3VwYWJhc2VcbiAgICAgICAgICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgICAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgICAgICAgaWQ6IHVzZXJJZCxcbiAgICAgICAgICAgICAgICBlbWFpbDogdXNlckVtYWlsLFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoY3JlYXRlVXNlckVycm9yKSB7XG4gICAgICAgICAgICAgIC8vIElmIGluc2VydCBmYWlscyBkdWUgdG8gbWlzc2luZyBjb2x1bW5zLCB0cnkgd2l0aCBqdXN0IGlkXG4gICAgICAgICAgICAgIGlmIChjcmVhdGVVc2VyRXJyb3IuY29kZSA9PT0gJzQyNzAzJyB8fCBjcmVhdGVVc2VyRXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ2NvbHVtbicpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvcjogbWluaW1hbEVycm9yIH0gPSBhd2FpdCBhZG1pblN1cGFiYXNlXG4gICAgICAgICAgICAgICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgICAgICAgICAgICAgLmluc2VydCh7IGlkOiB1c2VySWQgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG1pbmltYWxFcnJvcikge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbc3RlcC0xMS1wYXltZW50LXNldHVwXSBDb3VsZCBub3QgY3JlYXRlIHVzZXIgcmVjb3JkOicsIG1pbmltYWxFcnJvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbc3RlcC0xMS1wYXltZW50LXNldHVwXSBDcmVhdGVkIG1pbmltYWwgdXNlciByZWNvcmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbc3RlcC0xMS1wYXltZW50LXNldHVwXSBDb3VsZCBub3QgY3JlYXRlIHVzZXIgcmVjb3JkOicsIGNyZWF0ZVVzZXJFcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbc3RlcC0xMS1wYXltZW50LXNldHVwXSBVc2VyIHJlY29yZCBjcmVhdGVkIGluIHVzZXJzIHRhYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGVja1VzZXJFcnJvciAmJiBjaGVja1VzZXJFcnJvci5jb2RlICE9PSAnUEdSU1QxMTYnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tzdGVwLTExLXBheW1lbnQtc2V0dXBdIEVycm9yIGNoZWNraW5nIHVzZXJzIHRhYmxlOicsIGNoZWNrVXNlckVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gdXNlcnMgdGFibGUgbWlnaHQgbm90IGV4aXN0IC0gdGhhdCdzIG9rYXlcbiAgICAgICAgICBjb25zb2xlLmxvZygnW3N0ZXAtMTEtcGF5bWVudC1zZXR1cF0gdXNlcnMgdGFibGUgY2hlY2sgZmFpbGVkIChtaWdodCBub3QgZXhpc3QpOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IGRhdGE6IG5ld0J1c2luZXNzLCBlcnJvcjogY3JlYXRlRXJyb3IgfSA9IGF3YWl0IGFkbWluU3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCdidXNpbmVzc2VzJylcbiAgICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgICAgICAgIG5hbWU6IGJ1c2luZXNzTmFtZSxcbiAgICAgICAgICAgICAgaW5kdXN0cnk6IGluZHVzdHJ5LFxuICAgICAgICAgICAgICBzdWJkb21haW46IGB0ZW1wLSR7RGF0ZS5ub3coKX1gLFxuICAgICAgICAgICAgICB0aW1lem9uZTogJ0FtZXJpY2EvTmV3X1lvcmsnLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgICAgICAgIC5zaW5nbGUoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoY3JlYXRlRXJyb3IgfHwgIW5ld0J1c2luZXNzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbc3RlcC0xMS1wYXltZW50LXNldHVwXSBGYWlsZWQgdG8gY3JlYXRlIGJ1c2luZXNzOicsIGNyZWF0ZUVycm9yKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnQgZXJyb3JcbiAgICAgICAgICAgIGlmIChjcmVhdGVFcnJvcj8uY29kZSA9PT0gJzIzNTAzJyAmJiBjcmVhdGVFcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoJ3VzZXJzJykpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW3N0ZXAtMTEtcGF5bWVudC1zZXR1cF0gRk9SRUlHTiBLRVkgQ09OU1RSQUlOVCBFUlJPUjonKTtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW3N0ZXAtMTEtcGF5bWVudC1zZXR1cF0gVGhlIGJ1c2luZXNzZXMudXNlcl9pZCBmb3JlaWduIGtleSByZWZlcmVuY2VzIGEgbm9uLWV4aXN0ZW50IHVzZXJzIHRhYmxlLicpO1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbc3RlcC0xMS1wYXltZW50LXNldHVwXSBJdCBzaG91bGQgcmVmZXJlbmNlIGF1dGgudXNlcnMoaWQpIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tzdGVwLTExLXBheW1lbnQtc2V0dXBdIFJ1biBtaWdyYXRpb246IHN1cGFiYXNlL21pZ3JhdGlvbnMvMjAyNTAxMDQwMDAwMDBfZml4X2J1c2luZXNzZXNfdXNlcl9pZF9ma2V5LnNxbCcpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICAgICAgICAgIHsgXG4gICAgICAgICAgICAgICAgICBlcnJvcjogJ0RhdGFiYXNlIGNvbmZpZ3VyYXRpb24gaXNzdWU6IEZvcmVpZ24ga2V5IGNvbnN0cmFpbnQgbmVlZHMgdG8gYmUgZml4ZWQuJyxcbiAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdUaGUgYnVzaW5lc3NlcyB0YWJsZSBoYXMgYSBmb3JlaWduIGtleSB0aGF0IGluY29ycmVjdGx5IHJlZmVyZW5jZXMgYSB1c2VycyB0YWJsZSAod2hpY2ggZG9lc25cXCd0IGV4aXN0KS4gSXQgc2hvdWxkIHJlZmVyZW5jZSBhdXRoLnVzZXJzKGlkKSBpbnN0ZWFkLicsXG4gICAgICAgICAgICAgICAgICBjb2RlOiAnRk9SRUlHTl9LRVlfVklPTEFUSU9OJyxcbiAgICAgICAgICAgICAgICAgIHNvbHV0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGFudDogJ01ha2Ugc3VyZSB5b3UgYXJlIGluIHRoZSBUSVRISTIgU3VwYWJhc2UgcHJvamVjdCAobm90IFRJVEhJKScsXG4gICAgICAgICAgICAgICAgICAgIHF1aWNrRml4OiAnRklYX0NPTlNUUkFJTlRfVElUSEkyLnNxbCAoaW4gcHJvamVjdCByb290KScsXG4gICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAgICcxLiBHbyB0byBTdXBhYmFzZSBEYXNoYm9hcmQgYW5kIFNFTEVDVCBUSEUgVElUSEkyIFBST0pFQ1QnLFxuICAgICAgICAgICAgICAgICAgICAgICcyLiBOYXZpZ2F0ZSB0byBTUUwgRWRpdG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAnMy4gT3BlbiB0aGUgZmlsZTogRklYX0NPTlNUUkFJTlRfVElUSEkyLnNxbCAoaW4geW91ciBwcm9qZWN0IHJvb3QpJyxcbiAgICAgICAgICAgICAgICAgICAgICAnNC4gQ29weSBBTEwgdGhlIFNRTCBmcm9tIHRoYXQgZmlsZScsXG4gICAgICAgICAgICAgICAgICAgICAgJzUuIFBhc3RlIGludG8gU1FMIEVkaXRvciBhbmQgY2xpY2sgUnVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAnNi4gQ2hlY2sgdGhlIG91dHB1dCAtIGl0IHNob3VsZCBzaG93OiByZWZlcmVuY2VkX3NjaGVtYSA9IFwiYXV0aFwiIGFuZCByZWZlcmVuY2VkX3RhYmxlID0gXCJ1c2Vyc1wiJyxcbiAgICAgICAgICAgICAgICAgICAgICAnNy4gSWYgeW91IHNlZSBcIuKchSBTVUNDRVNTXCIsIHRoZSBmaXggd29ya2VkISdcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmU6ICdPciBydW46IHN1cGFiYXNlIGRiIHB1c2ggKGlmIHlvdSBoYXZlIFN1cGFiYXNlIENMSSBsaW5rZWQgdG8gVElUSEkyKSdcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgICAgIHsgZXJyb3I6ICdCdXNpbmVzcyBub3QgZm91bmQgYW5kIGNvdWxkIG5vdCBiZSBjcmVhdGVkLiBQbGVhc2UgY29tcGxldGUgc3RlcCAxIChCdXNpbmVzcykgZmlyc3QuJywgZGV0YWlsczogY3JlYXRlRXJyb3I/Lm1lc3NhZ2UgfSxcbiAgICAgICAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBidXNpbmVzc0lkID0gbmV3QnVzaW5lc3MuaWQ7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tzdGVwLTExLXBheW1lbnQtc2V0dXBdIENyZWF0ZWQgYnVzaW5lc3M6JywgYnVzaW5lc3NJZCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW3N0ZXAtMTEtcGF5bWVudC1zZXR1cF0gRXJyb3IgY3JlYXRpbmcgYnVzaW5lc3M6JywgZXJyb3IpO1xuICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgICAgIHsgZXJyb3I6ICdCdXNpbmVzcyBub3QgZm91bmQuIFBsZWFzZSBjb21wbGV0ZSBzdGVwIDEgKEJ1c2luZXNzKSBmaXJzdCB0byBjcmVhdGUgeW91ciBidXNpbmVzcyBwcm9maWxlLicsIGRldGFpbHM6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InIH0sXG4gICAgICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbc3RlcC0xMS1wYXltZW50LXNldHVwXSBCdXNpbmVzcyBub3QgZm91bmQgZm9yIHVzZXI6JywgdXNlcklkKTtcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICAgIHsgZXJyb3I6ICdCdXNpbmVzcyBub3QgZm91bmQuIFBsZWFzZSBjb21wbGV0ZSBzdGVwIDEgKEJ1c2luZXNzKSBmaXJzdCB0byBjcmVhdGUgeW91ciBidXNpbmVzcyBwcm9maWxlLicgfSxcbiAgICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1tzdGVwLTExLXBheW1lbnQtc2V0dXBdIEJ1c2luZXNzIElEOicsIGJ1c2luZXNzSWQpO1xuICAgIFxuICAgIC8vIEZyb250ZW5kIHNlbmRzIFBheW1lbnRTZXR1cENvbmZpZywgYnV0IHdlIGFsc28gYWNjZXB0IGRpcmVjdCBTdHJpcGUgQ29ubmVjdCBwYXJhbXNcbiAgICBjb25zdCB7IGNvbm5lY3RBY2NvdW50SWQsIGVtYWlsLCByZXR1cm5VcmwsIHJlZnJlc2hVcmwsIGFjY2VwdGVkTWV0aG9kczogcmVxdWVzdGVkTWV0aG9kcyB9ID0gYm9keTtcblxuICAgIGNvbnN0IHN1cGFiYXNlID0gYXdhaXQgY3JlYXRlU2VydmVyQ2xpZW50KCk7XG4gICAgXG4gICAgLy8gR2V0IHVzZXIncyBlbWFpbCBmcm9tIHNlc3Npb24gaWYgbm90IHByb3ZpZGVkIGluIGJvZHlcbiAgICBsZXQgdXNlckVtYWlsID0gZW1haWw7XG4gICAgaWYgKCF1c2VyRW1haWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRyeSB0byBnZXQgdXNlciBmcm9tIFN1cGFiYXNlIGF1dGhcbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSwgZXJyb3I6IHVzZXJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gICAgICAgIGlmICghdXNlckVycm9yICYmIHVzZXI/LmVtYWlsKSB7XG4gICAgICAgICAgdXNlckVtYWlsID0gdXNlci5lbWFpbDtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW3N0ZXAtMTEtcGF5bWVudC1zZXR1cF0gR290IGVtYWlsIGZyb20gdXNlciBzZXNzaW9uOicsIHVzZXJFbWFpbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdbc3RlcC0xMS1wYXltZW50LXNldHVwXSBDb3VsZCBub3QgZ2V0IGVtYWlsIGZyb20gYXV0aC5nZXRVc2VyKCksIGVycm9yOicsIHVzZXJFcnJvcik7XG4gICAgICAgICAgLy8gVXNlIGEgZGVmYXVsdCBlbWFpbCBmb3JtYXQgYXMgZmFsbGJhY2sgKHNob3VsZG4ndCBoYXBwZW4gaW4gcHJvZHVjdGlvbilcbiAgICAgICAgICB1c2VyRW1haWwgPSBgdXNlci0ke3VzZXJJZH1AdGl0aGkuY29tYDtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW3N0ZXAtMTEtcGF5bWVudC1zZXR1cF0gVXNpbmcgZmFsbGJhY2sgZW1haWw6JywgdXNlckVtYWlsKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW3N0ZXAtMTEtcGF5bWVudC1zZXR1cF0gRXJyb3IgZ2V0dGluZyBlbWFpbDonLCBlcnJvcik7XG4gICAgICAgIC8vIFVzZSBhIGRlZmF1bHQgZW1haWwgZm9ybWF0IGFzIGZhbGxiYWNrXG4gICAgICAgIHVzZXJFbWFpbCA9IGB1c2VyLSR7dXNlcklkfUB0aXRoaS5jb21gO1xuICAgICAgICBjb25zb2xlLmxvZygnW3N0ZXAtMTEtcGF5bWVudC1zZXR1cF0gVXNpbmcgZmFsbGJhY2sgZW1haWwgYWZ0ZXIgZXJyb3I6JywgdXNlckVtYWlsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXVzZXJFbWFpbCkge1xuICAgICAgY29uc29sZS5lcnJvcignW3N0ZXAtMTEtcGF5bWVudC1zZXR1cF0gTm8gZW1haWwgZm91bmQgLSBjYW5ub3QgcHJvY2VlZCcpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnRW1haWwgaXMgcmVxdWlyZWQuIFBsZWFzZSBlbnN1cmUgeW91IGFyZSBsb2dnZWQgaW4gd2l0aCBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gR2V0IGJ1c2luZXNzIGluZm8gaW5jbHVkaW5nIG5vdGlmaWNhdGlvbnNfZW5hYmxlZFxuICAgIGNvbnN0IHsgZGF0YTogYnVzaW5lc3MsIGVycm9yOiBidXNpbmVzc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2J1c2luZXNzZXMnKVxuICAgICAgLnNlbGVjdCgnaWQsIG5hbWUsIHN0cmlwZV9jb25uZWN0X2FjY291bnRfaWQsIHN0cmlwZV9jdXN0b21lcl9pZCwgc3RyaXBlX3N1YnNjcmlwdGlvbl9pZCwgbm90aWZpY2F0aW9uc19lbmFibGVkJylcbiAgICAgIC5lcSgnaWQnLCBidXNpbmVzc0lkKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKGJ1c2luZXNzRXJyb3IgfHwgIWJ1c2luZXNzKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdCdXNpbmVzcyBub3QgZm91bmQnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDQgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgYWNjb3VudElkID0gYnVzaW5lc3Muc3RyaXBlX2Nvbm5lY3RfYWNjb3VudF9pZCB8fCBjb25uZWN0QWNjb3VudElkO1xuXG4gICAgLy8gSWYgYWNjb3VudCBJRCBwcm92aWRlZCAocmV0dXJuaW5nIGZyb20gU3RyaXBlKSwgdmVyaWZ5IGl0XG4gICAgaWYgKGNvbm5lY3RBY2NvdW50SWQpIHtcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCB2ZXJpZnlDb25uZWN0QWNjb3VudChjb25uZWN0QWNjb3VudElkKTtcbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgeyBlcnJvcjogJ1N0cmlwZSBDb25uZWN0IGFjY291bnQgdmVyaWZpY2F0aW9uIGZhaWxlZC4gUGxlYXNlIGNvbXBsZXRlIG9uYm9hcmRpbmcuJyB9LFxuICAgICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgYWNjb3VudElkID0gY29ubmVjdEFjY291bnRJZDtcblxuICAgICAgLy8gU2F2ZSB0aGUgdmVyaWZpZWQgYWNjb3VudCBJRFxuICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2J1c2luZXNzZXMnKVxuICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICBzdHJpcGVfY29ubmVjdF9hY2NvdW50X2lkOiBhY2NvdW50SWQsXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KVxuICAgICAgICAuZXEoJ2lkJywgYnVzaW5lc3NJZCk7XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gYWNjb3VudCBJRCB5ZXQsIGNyZWF0ZSBvbmUgYW5kIGdldCBBY2NvdW50IExpbmtcbiAgICBpZiAoIWFjY291bnRJZCkge1xuICAgICAgYWNjb3VudElkID0gYXdhaXQgY3JlYXRlQ29ubmVjdEFjY291bnQodXNlcklkLCB1c2VyRW1haWwpO1xuXG4gICAgICAvLyBTYXZlIHRoZSBhY2NvdW50IElEICh3aWxsIGJlIHZlcmlmaWVkIGFmdGVyIG9uYm9hcmRpbmcgY29tcGxldGVzKVxuICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2J1c2luZXNzZXMnKVxuICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICBzdHJpcGVfY29ubmVjdF9hY2NvdW50X2lkOiBhY2NvdW50SWQsXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KVxuICAgICAgICAuZXEoJ2lkJywgYnVzaW5lc3NJZCk7XG5cbiAgICAgIC8vIENyZWF0ZSBBY2NvdW50IExpbmsgZm9yIG9uYm9hcmRpbmdcbiAgICAgIC8vIFJlZGlyZWN0IHRvIC9vbmJvYXJkaW5nICh0aGUgYWN0dWFsIG9uYm9hcmRpbmcgcGFnZSwgbm90IC9vbmJvYXJkaW5nL3BheW1lbnQtc2V0dXApXG4gICAgICBjb25zdCBkZWZhdWx0UmV0dXJuVXJsID0gcmV0dXJuVXJsIHx8IGAke3Byb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQUF9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCd9L29uYm9hcmRpbmdgO1xuICAgICAgY29uc3QgZGVmYXVsdFJlZnJlc2hVcmwgPSByZWZyZXNoVXJsIHx8IGAke3Byb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQUF9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCd9L29uYm9hcmRpbmdgO1xuXG4gICAgICBjb25zdCBhY2NvdW50TGlua1VybCA9IGF3YWl0IGNyZWF0ZUFjY291bnRMaW5rKGFjY291bnRJZCwgZGVmYXVsdFJldHVyblVybCwgZGVmYXVsdFJlZnJlc2hVcmwpO1xuXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBhY2NvdW50TGlua1VybCxcbiAgICAgICAgY29ubmVjdEFjY291bnRJZDogYWNjb3VudElkLFxuICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIGNvbXBsZXRlIFN0cmlwZSBDb25uZWN0IG9uYm9hcmRpbmcnLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZ5IGFjY291bnQgaXMgcmVhZHlcbiAgICBjb25zdCBpc1ZlcmlmaWVkID0gYXdhaXQgdmVyaWZ5Q29ubmVjdEFjY291bnQoYWNjb3VudElkKTtcbiAgICBpZiAoIWlzVmVyaWZpZWQpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRSZXR1cm5VcmwgPSByZXR1cm5VcmwgfHwgYCR7cHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBQX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAwJ30vb25ib2FyZGluZ2A7XG4gICAgICBjb25zdCBkZWZhdWx0UmVmcmVzaFVybCA9IHJlZnJlc2hVcmwgfHwgYCR7cHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBQX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAwJ30vb25ib2FyZGluZ2A7XG5cbiAgICAgIGNvbnN0IGFjY291bnRMaW5rVXJsID0gYXdhaXQgY3JlYXRlQWNjb3VudExpbmsoYWNjb3VudElkLCBkZWZhdWx0UmV0dXJuVXJsLCBkZWZhdWx0UmVmcmVzaFVybCk7XG5cbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBhY2NvdW50TGlua1VybCxcbiAgICAgICAgY29ubmVjdEFjY291bnRJZDogYWNjb3VudElkLFxuICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIGNvbXBsZXRlIFN0cmlwZSBDb25uZWN0IG9uYm9hcmRpbmcnLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG9yIGdldCBTdHJpcGUgQ3VzdG9tZXIgZm9yIHN1YnNjcmlwdGlvblxuICAgIGxldCBjdXN0b21lcklkOiBzdHJpbmc7XG4gICAgaWYgKGJ1c2luZXNzLnN0cmlwZV9jdXN0b21lcl9pZCkge1xuICAgICAgY3VzdG9tZXJJZCA9IGJ1c2luZXNzLnN0cmlwZV9jdXN0b21lcl9pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYnVzaW5lc3NOYW1lID0gYnVzaW5lc3MubmFtZSB8fCAnQnVzaW5lc3MgT3duZXInO1xuICAgICAgY29uc3QgbmV3Q3VzdG9tZXJJZCA9IGF3YWl0IGNyZWF0ZU9yR2V0Q3VzdG9tZXIodXNlckVtYWlsLCBidXNpbmVzc05hbWUsIHtcbiAgICAgICAgYnVzaW5lc3NfaWQ6IGJ1c2luZXNzSWQgYXMgc3RyaW5nLCAvLyBidXNpbmVzc0lkIGlzIGd1YXJhbnRlZWQgdG8gYmUgc3RyaW5nIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgfSk7XG4gICAgICBjdXN0b21lcklkID0gbmV3Q3VzdG9tZXJJZDtcblxuICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2J1c2luZXNzZXMnKVxuICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICBzdHJpcGVfY3VzdG9tZXJfaWQ6IGN1c3RvbWVySWQsXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KVxuICAgICAgICAuZXEoJ2lkJywgYnVzaW5lc3NJZCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHN1YnNjcmlwdGlvbiBpZiBub3QgZXhpc3RzXG4gICAgLy8gTm90ZTogU3Vic2NyaXB0aW9uIHdpbGwgYmUgaW4gJ2luY29tcGxldGUnIG9yICd0cmlhbGluZycgc3RhdGUgdW50aWwgb3duZXIgYWRkcyBwYXltZW50IG1ldGhvZFxuICAgIC8vIFRoZSBmcm9udGVuZCBzaG91bGQgaGFuZGxlIGNvbGxlY3RpbmcgcGF5bWVudCBtZXRob2QgZm9yIHRoZSBzdWJzY3JpcHRpb25cbiAgICBsZXQgc3Vic2NyaXB0aW9uSWQgPSBidXNpbmVzcy5zdHJpcGVfc3Vic2NyaXB0aW9uX2lkO1xuICAgIFxuICAgIC8vIFNlbGVjdCB0aGUgY29ycmVjdCBTdHJpcGUgcHJpY2UgSUQgYmFzZWQgb24gbm90aWZpY2F0aW9uc19lbmFibGVkXG4gICAgLy8gXG4gICAgLy8gUHJpY2luZzpcbiAgICAvLyAtIEJhc2ljIFBsYW4gKCQxMS45OS9tb250aCk6IG5vdGlmaWNhdGlvbnNfZW5hYmxlZCA9IGZhbHNlXG4gICAgLy8gICDihpIgVXNlcyBTVFJJUEVfUExBTl9QUklDRV9JRF9XSVRIT1VUX05PVElGSUNBVElPTlNcbiAgICAvLyAtIFBybyBQbGFuICgkMjEuOTkvbW9udGgpOiBub3RpZmljYXRpb25zX2VuYWJsZWQgPSB0cnVlXG4gICAgLy8gICDihpIgVXNlcyBTVFJJUEVfUExBTl9QUklDRV9JRF9XSVRIX05PVElGSUNBVElPTlNcbiAgICAvL1xuICAgIC8vIFRoZSB1c2VyIHNlbGVjdHMgdGhpcyBpbiBvbmJvYXJkaW5nIFN0ZXAgOCAoTm90aWZpY2F0aW9ucyBzdGVwKVxuICAgIC8vIHdoaWNoIHNhdmVzIG5vdGlmaWNhdGlvbnNfZW5hYmxlZCB0byB0aGUgYnVzaW5lc3NlcyB0YWJsZS5cbiAgICBjb25zdCBub3RpZmljYXRpb25zRW5hYmxlZCA9IGJ1c2luZXNzLm5vdGlmaWNhdGlvbnNfZW5hYmxlZCA9PT0gdHJ1ZTsgLy8gRXhwbGljaXRseSBjaGVjayBmb3IgdHJ1ZVxuICAgIGNvbnN0IHBsYW5UeXBlID0gbm90aWZpY2F0aW9uc0VuYWJsZWQgPyAnUHJvJyA6ICdCYXNpYyc7XG4gICAgY29uc3QgcGxhblByaWNlID0gbm90aWZpY2F0aW9uc0VuYWJsZWQgPyAyMS45OSA6IDExLjk5O1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGBDcmVhdGluZyBzdWJzY3JpcHRpb24gZm9yIGJ1c2luZXNzICR7YnVzaW5lc3NJZH06YCk7XG4gICAgY29uc29sZS5sb2coYCAgLSBub3RpZmljYXRpb25zX2VuYWJsZWQ6ICR7YnVzaW5lc3Mubm90aWZpY2F0aW9uc19lbmFibGVkfWApO1xuICAgIGNvbnNvbGUubG9nKGAgIC0gUGxhbjogJHtwbGFuVHlwZX0gKCQke3BsYW5QcmljZX0vbW9udGgpYCk7XG4gICAgXG4gICAgY29uc3QgcHJpY2VJZFdpdGhOb3RpZmljYXRpb25zID0gcHJvY2Vzcy5lbnYuU1RSSVBFX1BMQU5fUFJJQ0VfSURfV0lUSF9OT1RJRklDQVRJT05TIHx8IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NUUklQRV9QTEFOX1BSSUNFX0lEX1dJVEhfTk9USUZJQ0FUSU9OUztcbiAgICBjb25zdCBwcmljZUlkV2l0aG91dE5vdGlmaWNhdGlvbnMgPSBwcm9jZXNzLmVudi5TVFJJUEVfUExBTl9QUklDRV9JRF9XSVRIT1VUX05PVElGSUNBVElPTlMgfHwgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1RSSVBFX1BMQU5fUFJJQ0VfSURfV0lUSE9VVF9OT1RJRklDQVRJT05TO1xuICAgIFxuICAgIC8vIEZhbGxiYWNrIHRvIHNpbmdsZSBwcmljZSBJRCBpZiBzZXBhcmF0ZSBvbmVzIG5vdCBjb25maWd1cmVkXG4gICAgY29uc3QgZmFsbGJhY2tQcmljZUlkID0gcHJvY2Vzcy5lbnYuU1RSSVBFX1BMQU5fUFJJQ0VfSUQgfHwgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1RSSVBFX1BMQU5fUFJJQ0VfSUQ7XG4gICAgXG4gICAgY29uc3Qgc3RyaXBlUHJpY2VJZDogc3RyaW5nIHwgdW5kZWZpbmVkID0gbm90aWZpY2F0aW9uc0VuYWJsZWQgXG4gICAgICA/IChwcmljZUlkV2l0aE5vdGlmaWNhdGlvbnMgfHwgZmFsbGJhY2tQcmljZUlkKVxuICAgICAgOiAocHJpY2VJZFdpdGhvdXROb3RpZmljYXRpb25zIHx8IGZhbGxiYWNrUHJpY2VJZCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYCAgLSBTZWxlY3RlZCBTdHJpcGUgUHJpY2UgSUQ6ICR7c3RyaXBlUHJpY2VJZH1gKTtcbiAgICBjb25zb2xlLmxvZyhgICAtIFByaWNlIElEIHNvdXJjZTogJHtub3RpZmljYXRpb25zRW5hYmxlZCA/ICdXSVRIX05PVElGSUNBVElPTlMnIDogJ1dJVEhPVVRfTk9USUZJQ0FUSU9OUyd9YCk7XG5cbiAgICBpZiAoIXN1YnNjcmlwdGlvbklkKSB7XG4gICAgICBpZiAoIXN0cmlwZVByaWNlSWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTm8gU3RyaXBlIHByaWNlIElEIGNvbmZpZ3VyZWQuIFBsZWFzZSBzZXQgU1RSSVBFX1BMQU5fUFJJQ0VfSUQgb3IgU1RSSVBFX1BMQU5fUFJJQ0VfSURfV0lUSC9XSVRIT1VUX05PVElGSUNBVElPTlMnKTtcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICAgIHsgXG4gICAgICAgICAgICBlcnJvcjogJ1N1YnNjcmlwdGlvbiBwcmljZSBub3QgY29uZmlndXJlZC4gUGxlYXNlIGNvbnRhY3Qgc3VwcG9ydC4nLFxuICAgICAgICAgICAgZGV0YWlsczogJ01pc3NpbmcgU3RyaXBlIHByaWNlIElEIGluIGVudmlyb25tZW50IHZhcmlhYmxlcydcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQWRkIG1ldGFkYXRhIHRvIHN1YnNjcmlwdGlvbiBzbyB3ZWJob29rcyBjYW4gZmluZCB0aGUgYnVzaW5lc3NcbiAgICAgICAgLy8gTm90ZTogcGF5bWVudE1ldGhvZElkIGNhbiBiZSBwYXNzZWQgaWYgb3duZXIgYWxyZWFkeSBwcm92aWRlZCBpdCBpbiB0aGUgcmVxdWVzdFxuICAgICAgICBjb25zdCBib2R5UGF5bWVudE1ldGhvZElkID0gYm9keS5wYXltZW50TWV0aG9kSWQ7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IGNyZWF0ZVN1YnNjcmlwdGlvbihcbiAgICAgICAgICBjdXN0b21lcklkLFxuICAgICAgICAgIHN0cmlwZVByaWNlSWQgYXMgc3RyaW5nLCAvLyBBbHJlYWR5IGNoZWNrZWQgZm9yIG51bGwgYWJvdmVcbiAgICAgICAgICB7XG4gICAgICAgICAgICBidXNpbmVzc19pZDogYnVzaW5lc3NJZCBhcyBzdHJpbmcsIC8vIGJ1c2luZXNzSWQgaXMgZ3VhcmFudGVlZCB0byBiZSBzdHJpbmcgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keVBheW1lbnRNZXRob2RJZFxuICAgICAgICApO1xuXG4gICAgICAgIHN1YnNjcmlwdGlvbklkID0gc3Vic2NyaXB0aW9uLnN1YnNjcmlwdGlvbklkO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBuZXh0X2JpbGxfYXQgZnJvbSBjdXJyZW50X3BlcmlvZF9lbmQgKG9yIHRyaWFsX2VuZCBpZiBpbiB0cmlhbClcbiAgICAgICAgLy8gRm9yIHRyaWFsLCBuZXh0X2JpbGxfYXQgaXMgd2hlbiB0cmlhbCBlbmRzXG4gICAgICAgIGNvbnN0IG5leHRCaWxsQXQgPSBzdWJzY3JpcHRpb24udHJpYWxfZW5kXG4gICAgICAgICAgPyBuZXcgRGF0ZShzdWJzY3JpcHRpb24udHJpYWxfZW5kICogMTAwMCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgIDogc3Vic2NyaXB0aW9uLmN1cnJlbnRfcGVyaW9kX2VuZFxuICAgICAgICAgID8gbmV3IERhdGUoc3Vic2NyaXB0aW9uLmN1cnJlbnRfcGVyaW9kX2VuZCAqIDEwMDApLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICA6IG51bGw7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHN1YnNjcmlwdGlvbiBzdGF0dXNcbiAgICAgICAgLy8gJ3RyaWFsaW5nJyA9IHRyaWFsLCAnYWN0aXZlJyA9IGFjdGl2ZSwgJ2luY29tcGxldGUnID0gbmVlZHMgcGF5bWVudCBtZXRob2RcbiAgICAgICAgbGV0IHN1YnNjcmlwdGlvblN0YXR1cyA9ICd0cmlhbCc7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24uc3RhdHVzID09PSAnYWN0aXZlJykge1xuICAgICAgICAgIHN1YnNjcmlwdGlvblN0YXR1cyA9ICdhY3RpdmUnO1xuICAgICAgICB9IGVsc2UgaWYgKHN1YnNjcmlwdGlvbi5zdGF0dXMgPT09ICd0cmlhbGluZycpIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb25TdGF0dXMgPSAndHJpYWwnO1xuICAgICAgICB9IGVsc2UgaWYgKHN1YnNjcmlwdGlvbi5zdGF0dXMgPT09ICdpbmNvbXBsZXRlJyB8fCBzdWJzY3JpcHRpb24uc3RhdHVzID09PSAnaW5jb21wbGV0ZV9leHBpcmVkJykge1xuICAgICAgICAgIHN1YnNjcmlwdGlvblN0YXR1cyA9ICd0cmlhbCc7IC8vIFRyZWF0IGluY29tcGxldGUgYXMgdHJpYWwgdW50aWwgcGF5bWVudCBtZXRob2QgYWRkZWRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNhdmUgc3Vic2NyaXB0aW9uIGRldGFpbHMgaW5jbHVkaW5nIHRoZSBwcmljZSBJRCBhbmQgcGxhbiB0eXBlXG4gICAgICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdidXNpbmVzc2VzJylcbiAgICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICAgIHN0cmlwZV9zdWJzY3JpcHRpb25faWQ6IHN1YnNjcmlwdGlvbklkLFxuICAgICAgICAgICAgc3RyaXBlX3ByaWNlX2lkOiBzdHJpcGVQcmljZUlkLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uX3N0YXR1czogc3Vic2NyaXB0aW9uU3RhdHVzLFxuICAgICAgICAgICAgdHJpYWxfZW5kc19hdDogc3Vic2NyaXB0aW9uLnRyaWFsX2VuZFxuICAgICAgICAgICAgICA/IG5ldyBEYXRlKHN1YnNjcmlwdGlvbi50cmlhbF9lbmQgKiAxMDAwKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIG5leHRfYmlsbF9hdDogbmV4dEJpbGxBdCxcbiAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5lcSgnaWQnLCBidXNpbmVzc0lkKTtcbiAgICAgICAgXG4gICAgICAgIGlmICh1cGRhdGVFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBzdWJzY3JpcHRpb24gdG8gZGF0YWJhc2U6JywgdXBkYXRlRXJyb3IpO1xuICAgICAgICAgIHRocm93IHVwZGF0ZUVycm9yO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBWZXJpZnkgdGhlIHN1YnNjcmlwdGlvbiB3YXMgc2F2ZWQgY29ycmVjdGx5XG4gICAgICAgIGNvbnN0IHsgZGF0YTogdmVyaWZpZWRCdXNpbmVzcywgZXJyb3I6IHZlcmlmeUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdidXNpbmVzc2VzJylcbiAgICAgICAgICAuc2VsZWN0KCdzdHJpcGVfc3Vic2NyaXB0aW9uX2lkLCBzdHJpcGVfcHJpY2VfaWQsIG5vdGlmaWNhdGlvbnNfZW5hYmxlZCwgc3Vic2NyaXB0aW9uX3N0YXR1cycpXG4gICAgICAgICAgLmVxKCdpZCcsIGJ1c2luZXNzSWQpXG4gICAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHZlcmlmeUVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIHN1YnNjcmlwdGlvbiBzYXZlOicsIHZlcmlmeUVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnU3Vic2NyaXB0aW9uIHNhdmVkIHN1Y2Nlc3NmdWxseTonKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgICAtIFN1YnNjcmlwdGlvbiBJRDogJHt2ZXJpZmllZEJ1c2luZXNzLnN0cmlwZV9zdWJzY3JpcHRpb25faWR9YCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYCAgLSBQcmljZSBJRDogJHt2ZXJpZmllZEJ1c2luZXNzLnN0cmlwZV9wcmljZV9pZH1gKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgICAtIE5vdGlmaWNhdGlvbnMgZW5hYmxlZDogJHt2ZXJpZmllZEJ1c2luZXNzLm5vdGlmaWNhdGlvbnNfZW5hYmxlZH1gKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgICAtIFN0YXR1czogJHt2ZXJpZmllZEJ1c2luZXNzLnN1YnNjcmlwdGlvbl9zdGF0dXN9YCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYCAgLSBQbGFuOiAke3ZlcmlmaWVkQnVzaW5lc3Mubm90aWZpY2F0aW9uc19lbmFibGVkID8gJ1BybyAoJDIxLjk5L21vbnRoKScgOiAnQmFzaWMgKCQxMS45OS9tb250aCknfWApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzdWJzY3JpcHRpb25FcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBzdWJzY3JpcHRpb246Jywgc3Vic2NyaXB0aW9uRXJyb3IpO1xuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgeyBcbiAgICAgICAgICAgIGVycm9yOiAnRmFpbGVkIHRvIGNyZWF0ZSBzdWJzY3JpcHRpb24nLFxuICAgICAgICAgICAgZGV0YWlsczogc3Vic2NyaXB0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHN1YnNjcmlwdGlvbkVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcidcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNhdmUgYWNjZXB0ZWQgcGF5bWVudCBtZXRob2RzIGlmIHByb3ZpZGVkXG4gICAgaWYgKHJlcXVlc3RlZE1ldGhvZHMgJiYgQXJyYXkuaXNBcnJheShyZXF1ZXN0ZWRNZXRob2RzKSAmJiByZXF1ZXN0ZWRNZXRob2RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEZpcnN0LCBkaXNhYmxlIGFsbCBleGlzdGluZyBwYXltZW50IG1ldGhvZHMgZm9yIHRoaXMgYnVzaW5lc3NcbiAgICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgncGF5bWVudF9tZXRob2RzJylcbiAgICAgICAgICAudXBkYXRlKHsgZW5hYmxlZDogZmFsc2UgfSlcbiAgICAgICAgICAuZXEoJ2J1c2luZXNzX2lkJywgYnVzaW5lc3NJZCk7XG5cbiAgICAgICAgLy8gVGhlbiwgaW5zZXJ0IG9yIHVwZGF0ZSB0aGUgcmVxdWVzdGVkIG1ldGhvZHNcbiAgICAgICAgY29uc3QgbWV0aG9kc1RvU2F2ZSA9IHJlcXVlc3RlZE1ldGhvZHMubWFwKChtZXRob2Q6IHN0cmluZykgPT4gKHtcbiAgICAgICAgICBidXNpbmVzc19pZDogYnVzaW5lc3NJZCxcbiAgICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgICAgbWV0aG9kOiBtZXRob2QgPT09ICd3YWxsZXRzJyA/ICdhcHBsZV9wYXknIDogbWV0aG9kLCAvLyBNYXAgJ3dhbGxldHMnIHRvIHNwZWNpZmljIG1ldGhvZHNcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pKTtcblxuICAgICAgICAvLyBJZiAnd2FsbGV0cycgaXMgaW4gdGhlIGxpc3QsIGFsc28gYWRkIGdvb2dsZV9wYXlcbiAgICAgICAgaWYgKHJlcXVlc3RlZE1ldGhvZHMuaW5jbHVkZXMoJ3dhbGxldHMnKSkge1xuICAgICAgICAgIG1ldGhvZHNUb1NhdmUucHVzaCh7XG4gICAgICAgICAgICBidXNpbmVzc19pZDogYnVzaW5lc3NJZCxcbiAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICAgIG1ldGhvZDogJ2dvb2dsZV9wYXknLFxuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsd2F5cyBlbnN1cmUgJ2NhcmQnIGlzIGVuYWJsZWRcbiAgICAgICAgaWYgKCFyZXF1ZXN0ZWRNZXRob2RzLmluY2x1ZGVzKCdjYXJkJykpIHtcbiAgICAgICAgICBtZXRob2RzVG9TYXZlLnB1c2goe1xuICAgICAgICAgICAgYnVzaW5lc3NfaWQ6IGJ1c2luZXNzSWQsXG4gICAgICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgICAgICBtZXRob2Q6ICdjYXJkJyxcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcHNlcnQgcGF5bWVudCBtZXRob2RzXG4gICAgICAgIGNvbnN0IHsgZXJyb3I6IHBheW1lbnRNZXRob2RzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3BheW1lbnRfbWV0aG9kcycpXG4gICAgICAgICAgLnVwc2VydChtZXRob2RzVG9TYXZlLCB7XG4gICAgICAgICAgICBvbkNvbmZsaWN0OiAnYnVzaW5lc3NfaWQsbWV0aG9kJyxcbiAgICAgICAgICAgIGlnbm9yZUR1cGxpY2F0ZXM6IGZhbHNlLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwYXltZW50TWV0aG9kc0Vycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW3N0ZXAtMTEtcGF5bWVudC1zZXR1cF0gRXJyb3Igc2F2aW5nIHBheW1lbnQgbWV0aG9kczonLCBwYXltZW50TWV0aG9kc0Vycm9yKTtcbiAgICAgICAgICAvLyBEb24ndCBmYWlsIHRoZSByZXF1ZXN0IGlmIHBheW1lbnQgbWV0aG9kcyBzYXZlIGZhaWxzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tzdGVwLTExLXBheW1lbnQtc2V0dXBdIFNhdmVkIHBheW1lbnQgbWV0aG9kczonLCBtZXRob2RzVG9TYXZlLm1hcChtID0+IG0ubWV0aG9kKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIHBheW1lbnRfbWV0aG9kcyB0YWJsZSBtaWdodCBub3QgZXhpc3QsIGxvZyBhbmQgY29udGludWVcbiAgICAgICAgY29uc29sZS5sb2coJ1tzdGVwLTExLXBheW1lbnQtc2V0dXBdIENvdWxkIG5vdCBzYXZlIHBheW1lbnQgbWV0aG9kcyAodGFibGUgbWlnaHQgbm90IGV4aXN0KTonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBjb25uZWN0QWNjb3VudElkOiBhY2NvdW50SWQsXG4gICAgICBzdWJzY3JpcHRpb25JZDogc3Vic2NyaXB0aW9uSWQgfHwgbnVsbCxcbiAgICAgIG1lc3NhZ2U6ICdQYXltZW50IHNldHVwIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknLFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHN0ZXAtMTEtcGF5bWVudC1zZXR1cDonLCBlcnJvcik7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBlcnJvcjogJ0ludGVybmFsIHNlcnZlciBlcnJvcicsIGRldGFpbHM6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InIH0sXG4gICAgICB7IHN0YXR1czogNTAwIH1cbiAgICApO1xuICB9XG59XG5cblxuIl0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsImNyZWF0ZVNlcnZlckNsaWVudCIsImdldEN1cnJlbnRVc2VySWQiLCJnZXRDdXJyZW50QnVzaW5lc3NJZCIsImNyZWF0ZUNvbm5lY3RBY2NvdW50IiwiY3JlYXRlQWNjb3VudExpbmsiLCJ2ZXJpZnlDb25uZWN0QWNjb3VudCIsImNyZWF0ZU9yR2V0Q3VzdG9tZXIiLCJjcmVhdGVTdWJzY3JpcHRpb24iLCJHRVQiLCJyZXF1ZXN0IiwiY29uc29sZSIsImxvZyIsInVzZXJJZCIsImpzb24iLCJlcnJvciIsInN0YXR1cyIsImJ1c2luZXNzSWQiLCJzdXBhYmFzZSIsImRhdGEiLCJidXNpbmVzcyIsImZyb20iLCJzZWxlY3QiLCJlcSIsImlzIiwibWF5YmVTaW5nbGUiLCJwYXltZW50U2V0dXAiLCJjb25uZWN0U3RhdHVzIiwic3RyaXBlX2Nvbm5lY3RfYWNjb3VudF9pZCIsImlzVmFsaWQiLCJhY2NlcHRlZE1ldGhvZHMiLCJwYXltZW50TWV0aG9kcyIsImxlbmd0aCIsIm1hcCIsInBtIiwibWV0aG9kIiwic3Vic2NyaXB0aW9uU3RhdHVzIiwic3Vic2NyaXB0aW9uX3N0YXR1cyIsInBheW1lbnRNZXRob2RJZCIsInN0cmlwZV9zdWJzY3JpcHRpb25faWQiLCJzdHJpcGUiLCJ0aGVuIiwibSIsImRlZmF1bHQiLCJwcm9jZXNzIiwiZW52IiwiU1RSSVBFX1NFQ1JFVF9LRVkiLCJzdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb25zIiwicmV0cmlldmUiLCJkZWZhdWx0X3BheW1lbnRfbWV0aG9kIiwiaWQiLCJ0cmlhbEVuZHNBdCIsInRyaWFsX2VuZHNfYXQiLCJ1bmRlZmluZWQiLCJuZXh0QmlsbERhdGUiLCJuZXh0X2JpbGxfYXQiLCJQT1NUIiwiaGFuZGxlUGF5bWVudFNldHVwIiwiUFVUIiwidXNlciIsInVzZXJFcnJvciIsImF1dGgiLCJnZXRVc2VyIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJidXNpbmVzc05hbWUiLCJpbmR1c3RyeSIsImNyZWF0ZUFkbWluQ2xpZW50IiwiYWRtaW5TdXBhYmFzZSIsImV4aXN0aW5nVXNlciIsImNoZWNrVXNlckVycm9yIiwidXNlckVtYWlsIiwic3VwYWJhc2VDbGllbnQiLCJlbWFpbCIsImNyZWF0ZVVzZXJFcnJvciIsImluc2VydCIsImNyZWF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkX2F0IiwiY29kZSIsIm1lc3NhZ2UiLCJpbmNsdWRlcyIsIm1pbmltYWxFcnJvciIsIndhcm4iLCJuZXdCdXNpbmVzcyIsImNyZWF0ZUVycm9yIiwidXNlcl9pZCIsIm5hbWUiLCJzdWJkb21haW4iLCJub3ciLCJ0aW1lem9uZSIsInNpbmdsZSIsImRldGFpbHMiLCJzb2x1dGlvbiIsImltcG9ydGFudCIsInF1aWNrRml4IiwiaW5zdHJ1Y3Rpb25zIiwiYWx0ZXJuYXRpdmUiLCJFcnJvciIsImNvbm5lY3RBY2NvdW50SWQiLCJyZXR1cm5VcmwiLCJyZWZyZXNoVXJsIiwicmVxdWVzdGVkTWV0aG9kcyIsImJ1c2luZXNzRXJyb3IiLCJhY2NvdW50SWQiLCJ1cGRhdGUiLCJkZWZhdWx0UmV0dXJuVXJsIiwiTkVYVF9QVUJMSUNfQVBQX1VSTCIsImRlZmF1bHRSZWZyZXNoVXJsIiwiYWNjb3VudExpbmtVcmwiLCJzdWNjZXNzIiwiaXNWZXJpZmllZCIsImN1c3RvbWVySWQiLCJzdHJpcGVfY3VzdG9tZXJfaWQiLCJuZXdDdXN0b21lcklkIiwiYnVzaW5lc3NfaWQiLCJzdWJzY3JpcHRpb25JZCIsIm5vdGlmaWNhdGlvbnNFbmFibGVkIiwibm90aWZpY2F0aW9uc19lbmFibGVkIiwicGxhblR5cGUiLCJwbGFuUHJpY2UiLCJwcmljZUlkV2l0aE5vdGlmaWNhdGlvbnMiLCJTVFJJUEVfUExBTl9QUklDRV9JRF9XSVRIX05PVElGSUNBVElPTlMiLCJORVhUX1BVQkxJQ19TVFJJUEVfUExBTl9QUklDRV9JRF9XSVRIX05PVElGSUNBVElPTlMiLCJwcmljZUlkV2l0aG91dE5vdGlmaWNhdGlvbnMiLCJTVFJJUEVfUExBTl9QUklDRV9JRF9XSVRIT1VUX05PVElGSUNBVElPTlMiLCJORVhUX1BVQkxJQ19TVFJJUEVfUExBTl9QUklDRV9JRF9XSVRIT1VUX05PVElGSUNBVElPTlMiLCJmYWxsYmFja1ByaWNlSWQiLCJTVFJJUEVfUExBTl9QUklDRV9JRCIsIk5FWFRfUFVCTElDX1NUUklQRV9QTEFOX1BSSUNFX0lEIiwic3RyaXBlUHJpY2VJZCIsImJvZHlQYXltZW50TWV0aG9kSWQiLCJuZXh0QmlsbEF0IiwidHJpYWxfZW5kIiwiY3VycmVudF9wZXJpb2RfZW5kIiwidXBkYXRlRXJyb3IiLCJzdHJpcGVfcHJpY2VfaWQiLCJ2ZXJpZmllZEJ1c2luZXNzIiwidmVyaWZ5RXJyb3IiLCJzdWJzY3JpcHRpb25FcnJvciIsIkFycmF5IiwiaXNBcnJheSIsImVuYWJsZWQiLCJtZXRob2RzVG9TYXZlIiwicHVzaCIsInBheW1lbnRNZXRob2RzRXJyb3IiLCJ1cHNlcnQiLCJvbkNvbmZsaWN0IiwiaWdub3JlRHVwbGljYXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/business/onboarding/step-11-payment-setup/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/auth.ts":
/*!*************************!*\
  !*** ./src/lib/auth.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurrentBusinessId: () => (/* binding */ getCurrentBusinessId),\n/* harmony export */   getCurrentUserId: () => (/* binding */ getCurrentUserId)\n/* harmony export */ });\n/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./db */ \"(rsc)/./src/lib/db.ts\");\n/* harmony import */ var next_headers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/headers */ \"(rsc)/./node_modules/next/dist/api/headers.js\");\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/../../node_modules/@supabase/supabase-js/dist/module/index.js\");\n\n\n\n/**\n * Decode JWT payload without validation\n */ function decodeJWTPayload(token) {\n    try {\n        const parts = token.split(\".\");\n        if (parts.length !== 3) return null;\n        // Decode base64 payload (second part)\n        const payload = parts[1];\n        // Add padding if needed\n        const paddedPayload = payload + \"=\".repeat((4 - payload.length % 4) % 4);\n        const decoded = Buffer.from(paddedPayload, \"base64\").toString(\"utf-8\");\n        return JSON.parse(decoded);\n    } catch (error) {\n        console.error(\"Error decoding JWT:\", error);\n        return null;\n    }\n}\n/**\n * Extract raw JWT token from Supabase session cookies (without decoding)\n */ async function getRawTokenFromCookies() {\n    try {\n        const cookieStore = await (0,next_headers__WEBPACK_IMPORTED_MODULE_1__.cookies)();\n        const supabaseUrl = \"https://rgwooqakdvrchfwrdnyx.supabase.co\";\n        if (!supabaseUrl) {\n            return null;\n        }\n        // Get all cookies for debugging\n        const allCookies = cookieStore.getAll();\n        const authCookies = allCookies.filter((c)=>c.name.includes(\"auth\") || c.name.includes(\"sb-\") || c.name.includes(\"supabase\"));\n        // Supabase stores session in cookies with pattern: sb-{project-ref}-auth-token\n        // Extract project ref from URL\n        const url = new URL(supabaseUrl);\n        const projectRef = url.hostname.split(\".\")[0];\n        // Try different cookie name patterns\n        const cookieNames = [\n            `sb-api-auth-token`,\n            `sb-${projectRef}-auth-token`,\n            `sb-${projectRef.replace(/-/g, \"\")}-auth-token`,\n            `sb-${projectRef}-auth-token-code-verifier`\n        ];\n        for (const cookieName of cookieNames){\n            const cookie = cookieStore.get(cookieName);\n            if (cookie?.value) {\n                try {\n                    // Try URL decoding first\n                    let decodedValue = cookie.value;\n                    try {\n                        decodedValue = decodeURIComponent(cookie.value);\n                    } catch  {\n                    // Not URL encoded, use as-is\n                    }\n                    // Try parsing as JSON\n                    try {\n                        const sessionData = JSON.parse(decodedValue);\n                        // Check if it's an array (Supabase sometimes stores tokens as array)\n                        if (Array.isArray(sessionData) && sessionData.length > 0) {\n                            // Get first element which should be the JWT token\n                            const firstElement = sessionData[0];\n                            if (typeof firstElement === \"string\") {\n                                let cleanToken = firstElement.trim();\n                                // Remove surrounding quotes if present\n                                if (cleanToken.startsWith('\"') && cleanToken.endsWith('\"') || cleanToken.startsWith(\"'\") && cleanToken.endsWith(\"'\")) {\n                                    cleanToken = cleanToken.slice(1, -1);\n                                }\n                                // Check if it looks like a JWT (has 3 parts separated by dots)\n                                const parts = cleanToken.split(\".\");\n                                if (parts.length === 3 && cleanToken.length > 100) {\n                                    return cleanToken; // Return raw token, don't decode\n                                }\n                            }\n                        }\n                        // If it's an object with access_token\n                        if (sessionData?.access_token) {\n                            return sessionData.access_token;\n                        }\n                        if (sessionData?.session?.access_token) {\n                            return sessionData.session.access_token;\n                        }\n                    } catch (parseError) {\n                        // Not JSON, might be direct JWT token\n                        if (decodedValue.length > 100 && decodedValue.includes(\".\")) {\n                            return decodedValue;\n                        }\n                    }\n                } catch (error) {\n                    console.error(`Error processing cookie ${cookieName}:`, error);\n                }\n            }\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error extracting token from cookies:\", error);\n        return null;\n    }\n}\n/**\n * Extract access token from Supabase session cookies\n * Returns user ID if JWT is decoded, or token if not\n */ async function getAccessTokenFromCookies() {\n    try {\n        const cookieStore = await (0,next_headers__WEBPACK_IMPORTED_MODULE_1__.cookies)();\n        const supabaseUrl = \"https://rgwooqakdvrchfwrdnyx.supabase.co\";\n        if (!supabaseUrl) {\n            return null;\n        }\n        // Get all cookies for debugging\n        const allCookies = cookieStore.getAll();\n        const authCookies = allCookies.filter((c)=>c.name.includes(\"auth\") || c.name.includes(\"sb-\") || c.name.includes(\"supabase\"));\n        console.log(\"Found auth-related cookies:\", authCookies.map((c)=>c.name));\n        // Supabase stores session in cookies with pattern: sb-{project-ref}-auth-token\n        // Extract project ref from URL\n        const url = new URL(supabaseUrl);\n        const projectRef = url.hostname.split(\".\")[0];\n        // Try different cookie name patterns\n        const cookieNames = [\n            `sb-api-auth-token`,\n            `sb-${projectRef}-auth-token`,\n            `sb-${projectRef.replace(/-/g, \"\")}-auth-token`,\n            `sb-${projectRef}-auth-token-code-verifier`\n        ];\n        for (const cookieName of cookieNames){\n            const cookie = cookieStore.get(cookieName);\n            if (cookie?.value) {\n                // Log first 100 chars to see format (without exposing full token)\n                const preview = cookie.value.substring(0, 100);\n                console.log(`Checking cookie: ${cookieName}, length: ${cookie.value.length}, preview: ${preview}...`);\n                try {\n                    // Try to parse as JSON (Supabase stores session as JSON string)\n                    let sessionData;\n                    let decodedValue = cookie.value;\n                    // Try URL decoding first\n                    try {\n                        decodedValue = decodeURIComponent(cookie.value);\n                    } catch  {\n                    // Not URL encoded, use as-is\n                    }\n                    // Try parsing as JSON\n                    try {\n                        sessionData = JSON.parse(decodedValue);\n                        console.log(`Parsed ${cookieName} as JSON, type:`, Array.isArray(sessionData) ? \"array\" : typeof sessionData, \"keys:\", Object.keys(sessionData || {}));\n                        // Check if it's an array (Supabase sometimes stores tokens as array)\n                        if (Array.isArray(sessionData) && sessionData.length > 0) {\n                            console.log(`Array has ${sessionData.length} elements, checking each...`);\n                            // Try each element to find a valid JWT\n                            for(let i = 0; i < sessionData.length; i++){\n                                const element = sessionData[i];\n                                console.log(`Element ${i} type: ${typeof element}, length: ${typeof element === \"string\" ? element.length : \"N/A\"}`);\n                                if (typeof element === \"string\") {\n                                    // Remove any quotes or extra characters\n                                    let cleanToken = element.trim();\n                                    // Remove surrounding quotes if present\n                                    if (cleanToken.startsWith('\"') && cleanToken.endsWith('\"') || cleanToken.startsWith(\"'\") && cleanToken.endsWith(\"'\")) {\n                                        cleanToken = cleanToken.slice(1, -1);\n                                    }\n                                    // Check if it looks like a JWT (has 3 parts separated by dots)\n                                    const parts = cleanToken.split(\".\");\n                                    if (parts.length === 3 && cleanToken.length > 100) {\n                                        console.log(`Found valid JWT structure in element ${i}, length: ${cleanToken.length}`);\n                                        // Try to decode the JWT to get user ID directly (without validation)\n                                        const payload = decodeJWTPayload(cleanToken);\n                                        if (payload && (payload.sub || payload.user_id)) {\n                                            const userId = payload.sub || payload.user_id;\n                                            console.log(`Extracted user ID from JWT: ${userId}`);\n                                            return userId; // Return user ID directly instead of token\n                                        }\n                                        // If decoding fails, try using the token\n                                        console.log(`Token preview: ${cleanToken.substring(0, 50)}...`);\n                                        return cleanToken;\n                                    }\n                                }\n                                // If element is an object, check for access_token\n                                if (element && typeof element === \"object\" && element.access_token) {\n                                    console.log(`Found access_token in element ${i}:`, cookieName);\n                                    return element.access_token;\n                                }\n                            }\n                            // If no single element works, try joining all string elements\n                            const allStrings = sessionData.filter((e)=>typeof e === \"string\");\n                            if (allStrings.length > 0) {\n                                const joined = allStrings.join(\"\");\n                                const parts = joined.split(\".\");\n                                if (parts.length === 3 && joined.length > 100) {\n                                    console.log(\"Found JWT by joining array elements\");\n                                    return joined;\n                                }\n                            }\n                        }\n                        if (sessionData?.access_token) {\n                            console.log(\"Found access token in cookie:\", cookieName);\n                            return sessionData.access_token;\n                        }\n                        // Check for nested session object\n                        if (sessionData?.session?.access_token) {\n                            console.log(\"Found access token in nested session:\", cookieName);\n                            return sessionData.session.access_token;\n                        }\n                    } catch (parseError) {\n                        // Not JSON, might be direct token or different format\n                        console.log(`Cookie ${cookieName} is not JSON, checking if it's a JWT`);\n                        // Check if it looks like a JWT (has dots and is long enough)\n                        if (decodedValue.length > 100 && decodedValue.includes(\".\")) {\n                            // Likely a JWT token\n                            console.log(\"Found JWT token in cookie:\", cookieName);\n                            return decodedValue;\n                        }\n                    }\n                } catch (error) {\n                    console.error(`Error processing cookie ${cookieName}:`, error);\n                }\n            }\n        }\n        // Try to find any cookie that looks like an auth token\n        for (const cookie of authCookies){\n            if (cookie.name.includes(\"auth-token\") || cookie.name.includes(\"auth_token\")) {\n                try {\n                    let sessionData;\n                    try {\n                        sessionData = JSON.parse(decodeURIComponent(cookie.value));\n                    } catch  {\n                        sessionData = JSON.parse(cookie.value);\n                    }\n                    if (sessionData?.access_token) {\n                        console.log(\"Found access token in auth cookie:\", cookie.name);\n                        return sessionData.access_token;\n                    }\n                } catch  {\n                    // Not JSON, might be direct token\n                    if (cookie.value.length > 100 && cookie.value.includes(\".\")) {\n                        // Looks like a JWT\n                        console.log(\"Found JWT in auth cookie:\", cookie.name);\n                        return cookie.value;\n                    }\n                }\n            }\n        }\n        console.log(\"No access token found in cookies\");\n        return null;\n    } catch (error) {\n        console.error(\"Error extracting token from cookies:\", error);\n        return null;\n    }\n}\n/**\n * Get the current authenticated user from the request\n * \n * Returns the user ID from Supabase Auth JWT, or null if not authenticated.\n * Use this in API routes to get the current user.\n * \n * Usage:\n * ```ts\n * const userId = await getCurrentUserId();\n * if (!userId) {\n *   return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n * }\n * ```\n */ async function getCurrentUserId() {\n    try {\n        const supabaseUrl = \"https://rgwooqakdvrchfwrdnyx.supabase.co\";\n        const supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJnd29vcWFrZHZyY2hmd3Jkbnl4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMzOTQyNDEsImV4cCI6MjA3ODk3MDI0MX0.YpX0dYf_iueJVR1oK5SvREnO765JAKxriy2csdAEZlI\";\n        if (!supabaseUrl || !supabaseAnonKey) {\n            console.error(\"Missing Supabase environment variables\");\n            return null;\n        }\n        // First try to get token from Authorization header\n        try {\n            const headersList = await (0,next_headers__WEBPACK_IMPORTED_MODULE_1__.headers)();\n            const authHeader = headersList.get(\"authorization\");\n            if (authHeader?.startsWith(\"Bearer \")) {\n                const token = authHeader.substring(7);\n                const client = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_2__.createClient)(supabaseUrl, supabaseAnonKey, {\n                    global: {\n                        headers: {\n                            Authorization: `Bearer ${token}`\n                        }\n                    }\n                });\n                const { data: { user }, error } = await client.auth.getUser();\n                if (!error && user) {\n                    return user.id;\n                }\n            }\n        } catch (error) {\n            console.error(\"Error with Authorization header:\", error);\n        // Continue to cookie-based auth\n        }\n        // Try to extract access token or user ID from cookies\n        const tokenOrUserId = await getAccessTokenFromCookies();\n        if (tokenOrUserId) {\n            // If it's already a user ID (from JWT decode), return it\n            if (tokenOrUserId.length < 50 && tokenOrUserId.includes(\"-\")) {\n                // Looks like a UUID (user ID)\n                console.log(\"Using extracted user ID directly:\", tokenOrUserId);\n                return tokenOrUserId;\n            }\n            // Otherwise, try using it as a token\n            try {\n                const client = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_2__.createClient)(supabaseUrl, supabaseAnonKey, {\n                    global: {\n                        headers: {\n                            Authorization: `Bearer ${tokenOrUserId}`\n                        }\n                    }\n                });\n                const { data: { user }, error } = await client.auth.getUser();\n                if (!error && user) {\n                    return user.id;\n                } else {\n                    console.error(\"Error with cookie token:\", error);\n                    // If token validation fails, try decoding JWT directly\n                    const payload = decodeJWTPayload(tokenOrUserId);\n                    if (payload && (payload.sub || payload.user_id)) {\n                        console.log(\"Extracted user ID from JWT after validation failed:\", payload.sub || payload.user_id);\n                        return payload.sub || payload.user_id;\n                    }\n                }\n            } catch (error) {\n                console.error(\"Error with cookie token:\", error);\n                // Try decoding JWT as fallback\n                const payload = decodeJWTPayload(tokenOrUserId);\n                if (payload && (payload.sub || payload.user_id)) {\n                    console.log(\"Extracted user ID from JWT as fallback:\", payload.sub || payload.user_id);\n                    return payload.sub || payload.user_id;\n                }\n            }\n        }\n        // Fallback: Try cookie-based auth with createServerClient\n        // This might work if cookies are set up correctly\n        try {\n            const supabase = await (0,_db__WEBPACK_IMPORTED_MODULE_0__.createServerClient)();\n            const { data: { user }, error } = await supabase.auth.getUser();\n            if (!error && user) {\n                return user.id;\n            }\n            if (error) {\n                console.error(\"Auth error from createServerClient:\", error);\n            }\n        } catch (error) {\n            console.error(\"Error with createServerClient:\", error);\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error getting current user:\", error);\n        return null;\n    }\n}\n/**\n * Create an authenticated Supabase client with a specific access token\n */ async function createAuthenticatedClient(accessToken) {\n    const supabaseUrl = \"https://rgwooqakdvrchfwrdnyx.supabase.co\";\n    const supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJnd29vcWFrZHZyY2hmd3Jkbnl4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMzOTQyNDEsImV4cCI6MjA3ODk3MDI0MX0.YpX0dYf_iueJVR1oK5SvREnO765JAKxriy2csdAEZlI\";\n    if (!supabaseUrl || !supabaseAnonKey) {\n        throw new Error(\"Missing Supabase environment variables\");\n    }\n    const { createClient } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @supabase/supabase-js */ \"(rsc)/../../node_modules/@supabase/supabase-js/dist/module/index.js\"));\n    return createClient(supabaseUrl, supabaseAnonKey, {\n        global: {\n            headers: {\n                Authorization: `Bearer ${accessToken}`\n            }\n        },\n        auth: {\n            persistSession: false,\n            autoRefreshToken: false\n        }\n    });\n}\n/**\n * Get the current user's business ID\n * \n * Returns the business ID for the authenticated user, or null if not found.\n * \n * Usage:\n * ```ts\n * const businessId = await getCurrentBusinessId();\n * if (!businessId) {\n *   return NextResponse.json({ error: 'Business not found' }, { status: 404 });\n * }\n * ```\n */ async function getCurrentBusinessId() {\n    try {\n        const userId = await getCurrentUserId();\n        if (!userId) {\n            console.error(\"[getCurrentBusinessId] No user ID found\");\n            return null;\n        }\n        console.log(\"[getCurrentBusinessId] Looking for business for user:\", userId);\n        // Log Supabase project info for debugging\n        const supabaseUrl = \"https://rgwooqakdvrchfwrdnyx.supabase.co\";\n        if (supabaseUrl) {\n            try {\n                const url = new URL(supabaseUrl);\n                const projectRef = url.hostname.split(\".\")[0];\n                console.log(\"[getCurrentBusinessId] Using Supabase project:\", projectRef);\n            } catch  {\n                console.log(\"[getCurrentBusinessId] Supabase URL:\", supabaseUrl);\n            }\n        }\n        // Use createServerClient which should handle cookies properly\n        // If that fails due to RLS, we'll use service role as fallback\n        const supabase = await (0,_db__WEBPACK_IMPORTED_MODULE_0__.createServerClient)();\n        // Query for business\n        const { data, error } = await supabase.from(\"businesses\").select(\"id, name\").eq(\"user_id\", userId).is(\"deleted_at\", null).maybeSingle(); // Use maybeSingle() instead of single() to avoid error if not found\n        if (error) {\n            console.error(\"[getCurrentBusinessId] Error querying business:\", error);\n            // If RLS error, try with service role (we already verified user is authenticated)\n            if (error.code === \"PGRST301\" || error.message?.includes(\"No suitable key\")) {\n                console.log(\"[getCurrentBusinessId] RLS error, trying with service role for user:\", userId);\n                const { createAdminClient } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/db */ \"(rsc)/./src/lib/db.ts\"));\n                const adminSupabase = createAdminClient();\n                // First check if ANY businesses exist for this user (including deleted)\n                const { data: allBusinesses, error: allError } = await adminSupabase.from(\"businesses\").select(\"id, name, deleted_at, user_id\").eq(\"user_id\", userId);\n                console.log(\"[getCurrentBusinessId] All businesses for user (admin):\", allBusinesses?.length || 0);\n                if (allBusinesses && allBusinesses.length > 0) {\n                    console.log(\"[getCurrentBusinessId] Businesses found:\", allBusinesses.map((b)=>({\n                            id: b.id,\n                            name: b.name,\n                            deleted: !!b.deleted_at,\n                            user_id: b.user_id\n                        })));\n                }\n                if (allError) {\n                    console.error(\"[getCurrentBusinessId] Error checking all businesses:\", allError);\n                }\n                // Diagnostic: Check if there are ANY businesses at all (to detect user ID mismatch)\n                const { data: anyBusinesses, error: anyError } = await adminSupabase.from(\"businesses\").select(\"id, name, user_id, deleted_at\").limit(10);\n                if (!anyError && anyBusinesses && anyBusinesses.length > 0) {\n                    console.log(\"[getCurrentBusinessId] DIAGNOSTIC: Found businesses in database:\", anyBusinesses.map((b)=>({\n                            id: b.id,\n                            name: b.name,\n                            user_id: b.user_id,\n                            matches_current_user: b.user_id === userId,\n                            deleted: !!b.deleted_at\n                        })));\n                } else if (!anyError) {\n                    console.log(\"[getCurrentBusinessId] DIAGNOSTIC: No businesses exist in database at all\");\n                } else {\n                    console.error(\"[getCurrentBusinessId] DIAGNOSTIC: Error checking all businesses:\", anyError);\n                }\n                // Now get the non-deleted one\n                const { data: adminData, error: adminError } = await adminSupabase.from(\"businesses\").select(\"id, name\").eq(\"user_id\", userId).is(\"deleted_at\", null).maybeSingle();\n                if (adminError) {\n                    console.error(\"[getCurrentBusinessId] Error with admin client:\", adminError);\n                    return null;\n                }\n                if (adminData) {\n                    console.log(\"[getCurrentBusinessId] Found business with admin client:\", adminData.id, adminData.name);\n                    return adminData.id;\n                } else {\n                    console.error(\"[getCurrentBusinessId] No business found with admin client for user:\", userId);\n                    return null;\n                }\n            }\n            return null;\n        }\n        if (!data) {\n            console.error(\"[getCurrentBusinessId] No business found for user:\", userId);\n            return null;\n        }\n        console.log(\"[getCurrentBusinessId] Found business:\", data.id, data.name);\n        return data.id;\n    } catch (error) {\n        console.error(\"[getCurrentBusinessId] Error getting current business:\", error);\n        return null;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VTt3QkFDekI7Z0JBQ0YsT0FBTyxJQUFJLENBQUNFLFVBQVU7b0JBQ3BCekYsUUFBUXVDLEdBQUcsQ0FBQztnQkFDZCxPQUFPO29CQUNMdkMsUUFBUUQsS0FBSyxDQUFDLHFFQUFxRTBGO2dCQUNyRjtnQkFFQSw4QkFBOEI7Z0JBQzlCLE1BQU0sRUFBRTNCLE1BQU04QixTQUFTLEVBQUU3RixPQUFPOEYsVUFBVSxFQUFFLEdBQUcsTUFBTVgsY0FDbER2RixJQUFJLENBQUMsY0FDTGdGLE1BQU0sQ0FBQyxZQUNQQyxFQUFFLENBQUMsV0FBVzNCLFFBQ2Q0QixFQUFFLENBQUMsY0FBYyxNQUNqQkMsV0FBVztnQkFFZCxJQUFJZSxZQUFZO29CQUNkN0YsUUFBUUQsS0FBSyxDQUFDLG1EQUFtRDhGO29CQUNqRSxPQUFPO2dCQUNUO2dCQUVBLElBQUlELFdBQVc7b0JBQ2I1RixRQUFRdUMsR0FBRyxDQUFDLDREQUE0RHFELFVBQVUxQixFQUFFLEVBQUUwQixVQUFVaEYsSUFBSTtvQkFDcEcsT0FBT2dGLFVBQVUxQixFQUFFO2dCQUNyQixPQUFPO29CQUNMbEUsUUFBUUQsS0FBSyxDQUFDLHdFQUF3RWtEO29CQUN0RixPQUFPO2dCQUNUO1lBQ0Y7WUFFQSxPQUFPO1FBQ1Q7UUFFQSxJQUFJLENBQUNhLE1BQU07WUFDVDlELFFBQVFELEtBQUssQ0FBQyxzREFBc0RrRDtZQUNwRSxPQUFPO1FBQ1Q7UUFFQWpELFFBQVF1QyxHQUFHLENBQUMsMENBQTBDdUIsS0FBS0ksRUFBRSxFQUFFSixLQUFLbEQsSUFBSTtRQUN4RSxPQUFPa0QsS0FBS0ksRUFBRTtJQUNoQixFQUFFLE9BQU9uRSxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQywwREFBMERBO1FBQ3hFLE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vc3JjL2xpYi9hdXRoLnRzPzY2OTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlU2VydmVyQ2xpZW50IH0gZnJvbSAnLi9kYic7XG5pbXBvcnQgeyBoZWFkZXJzLCBjb29raWVzIH0gZnJvbSAnbmV4dC9oZWFkZXJzJztcbmltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5cbi8qKlxuICogRGVjb2RlIEpXVCBwYXlsb2FkIHdpdGhvdXQgdmFsaWRhdGlvblxuICovXG5mdW5jdGlvbiBkZWNvZGVKV1RQYXlsb2FkKHRva2VuOiBzdHJpbmcpOiBhbnkgfCBudWxsIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJ0cyA9IHRva2VuLnNwbGl0KCcuJyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykgcmV0dXJuIG51bGw7XG4gICAgXG4gICAgLy8gRGVjb2RlIGJhc2U2NCBwYXlsb2FkIChzZWNvbmQgcGFydClcbiAgICBjb25zdCBwYXlsb2FkID0gcGFydHNbMV07XG4gICAgLy8gQWRkIHBhZGRpbmcgaWYgbmVlZGVkXG4gICAgY29uc3QgcGFkZGVkUGF5bG9hZCA9IHBheWxvYWQgKyAnPScucmVwZWF0KCg0IC0gcGF5bG9hZC5sZW5ndGggJSA0KSAlIDQpO1xuICAgIGNvbnN0IGRlY29kZWQgPSBCdWZmZXIuZnJvbShwYWRkZWRQYXlsb2FkLCAnYmFzZTY0JykudG9TdHJpbmcoJ3V0Zi04Jyk7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlZCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVjb2RpbmcgSldUOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgcmF3IEpXVCB0b2tlbiBmcm9tIFN1cGFiYXNlIHNlc3Npb24gY29va2llcyAod2l0aG91dCBkZWNvZGluZylcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UmF3VG9rZW5Gcm9tQ29va2llcygpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjb29raWVTdG9yZSA9IGF3YWl0IGNvb2tpZXMoKTtcbiAgICBjb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTDtcbiAgICBcbiAgICBpZiAoIXN1cGFiYXNlVXJsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBHZXQgYWxsIGNvb2tpZXMgZm9yIGRlYnVnZ2luZ1xuICAgIGNvbnN0IGFsbENvb2tpZXMgPSBjb29raWVTdG9yZS5nZXRBbGwoKTtcbiAgICBjb25zdCBhdXRoQ29va2llcyA9IGFsbENvb2tpZXMuZmlsdGVyKGMgPT4gXG4gICAgICBjLm5hbWUuaW5jbHVkZXMoJ2F1dGgnKSB8fCBcbiAgICAgIGMubmFtZS5pbmNsdWRlcygnc2ItJykgfHxcbiAgICAgIGMubmFtZS5pbmNsdWRlcygnc3VwYWJhc2UnKVxuICAgICk7XG4gICAgXG4gICAgLy8gU3VwYWJhc2Ugc3RvcmVzIHNlc3Npb24gaW4gY29va2llcyB3aXRoIHBhdHRlcm46IHNiLXtwcm9qZWN0LXJlZn0tYXV0aC10b2tlblxuICAgIC8vIEV4dHJhY3QgcHJvamVjdCByZWYgZnJvbSBVUkxcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHN1cGFiYXNlVXJsKTtcbiAgICBjb25zdCBwcm9qZWN0UmVmID0gdXJsLmhvc3RuYW1lLnNwbGl0KCcuJylbMF07XG4gICAgXG4gICAgLy8gVHJ5IGRpZmZlcmVudCBjb29raWUgbmFtZSBwYXR0ZXJuc1xuICAgIGNvbnN0IGNvb2tpZU5hbWVzID0gW1xuICAgICAgYHNiLWFwaS1hdXRoLXRva2VuYCwgLy8gVHJ5IHRoaXMgZmlyc3QgYXMgaXQncyBtb3N0IGNvbW1vblxuICAgICAgYHNiLSR7cHJvamVjdFJlZn0tYXV0aC10b2tlbmAsXG4gICAgICBgc2ItJHtwcm9qZWN0UmVmLnJlcGxhY2UoLy0vZywgJycpfS1hdXRoLXRva2VuYCxcbiAgICAgIGBzYi0ke3Byb2plY3RSZWZ9LWF1dGgtdG9rZW4tY29kZS12ZXJpZmllcmAsIC8vIFNvbWV0aW1lcyBzdG9yZWQgc2VwYXJhdGVseVxuICAgIF07XG5cbiAgICBmb3IgKGNvbnN0IGNvb2tpZU5hbWUgb2YgY29va2llTmFtZXMpIHtcbiAgICAgIGNvbnN0IGNvb2tpZSA9IGNvb2tpZVN0b3JlLmdldChjb29raWVOYW1lKTtcbiAgICAgIGlmIChjb29raWU/LnZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVHJ5IFVSTCBkZWNvZGluZyBmaXJzdFxuICAgICAgICAgIGxldCBkZWNvZGVkVmFsdWUgPSBjb29raWUudmFsdWU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlY29kZWRWYWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChjb29raWUudmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgLy8gTm90IFVSTCBlbmNvZGVkLCB1c2UgYXMtaXNcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHBhcnNpbmcgYXMgSlNPTlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uRGF0YSA9IEpTT04ucGFyc2UoZGVjb2RlZFZhbHVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhbiBhcnJheSAoU3VwYWJhc2Ugc29tZXRpbWVzIHN0b3JlcyB0b2tlbnMgYXMgYXJyYXkpXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXNzaW9uRGF0YSkgJiYgc2Vzc2lvbkRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyBHZXQgZmlyc3QgZWxlbWVudCB3aGljaCBzaG91bGQgYmUgdGhlIEpXVCB0b2tlblxuICAgICAgICAgICAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSBzZXNzaW9uRGF0YVswXTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaXJzdEVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNsZWFuVG9rZW4gPSBmaXJzdEVsZW1lbnQudHJpbSgpO1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBzdXJyb3VuZGluZyBxdW90ZXMgaWYgcHJlc2VudFxuICAgICAgICAgICAgICAgIGlmICgoY2xlYW5Ub2tlbi5zdGFydHNXaXRoKCdcIicpICYmIGNsZWFuVG9rZW4uZW5kc1dpdGgoJ1wiJykpIHx8IFxuICAgICAgICAgICAgICAgICAgICAoY2xlYW5Ub2tlbi5zdGFydHNXaXRoKFwiJ1wiKSAmJiBjbGVhblRva2VuLmVuZHNXaXRoKFwiJ1wiKSkpIHtcbiAgICAgICAgICAgICAgICAgIGNsZWFuVG9rZW4gPSBjbGVhblRva2VuLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgbG9va3MgbGlrZSBhIEpXVCAoaGFzIDMgcGFydHMgc2VwYXJhdGVkIGJ5IGRvdHMpXG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBjbGVhblRva2VuLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMyAmJiBjbGVhblRva2VuLmxlbmd0aCA+IDEwMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFuVG9rZW47IC8vIFJldHVybiByYXcgdG9rZW4sIGRvbid0IGRlY29kZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiBpdCdzIGFuIG9iamVjdCB3aXRoIGFjY2Vzc190b2tlblxuICAgICAgICAgICAgaWYgKHNlc3Npb25EYXRhPy5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25EYXRhLmFjY2Vzc190b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHNlc3Npb25EYXRhPy5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25EYXRhLnNlc3Npb24uYWNjZXNzX3Rva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIE5vdCBKU09OLCBtaWdodCBiZSBkaXJlY3QgSldUIHRva2VuXG4gICAgICAgICAgICBpZiAoZGVjb2RlZFZhbHVlLmxlbmd0aCA+IDEwMCAmJiBkZWNvZGVkVmFsdWUuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGNvb2tpZSAke2Nvb2tpZU5hbWV9OmAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGV4dHJhY3RpbmcgdG9rZW4gZnJvbSBjb29raWVzOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYWNjZXNzIHRva2VuIGZyb20gU3VwYWJhc2Ugc2Vzc2lvbiBjb29raWVzXG4gKiBSZXR1cm5zIHVzZXIgSUQgaWYgSldUIGlzIGRlY29kZWQsIG9yIHRva2VuIGlmIG5vdFxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRBY2Nlc3NUb2tlbkZyb21Db29raWVzKCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IGNvb2tpZVN0b3JlID0gYXdhaXQgY29va2llcygpO1xuICAgIGNvbnN0IHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMO1xuICAgIFxuICAgIGlmICghc3VwYWJhc2VVcmwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIEdldCBhbGwgY29va2llcyBmb3IgZGVidWdnaW5nXG4gICAgY29uc3QgYWxsQ29va2llcyA9IGNvb2tpZVN0b3JlLmdldEFsbCgpO1xuICAgIGNvbnN0IGF1dGhDb29raWVzID0gYWxsQ29va2llcy5maWx0ZXIoYyA9PiBcbiAgICAgIGMubmFtZS5pbmNsdWRlcygnYXV0aCcpIHx8IFxuICAgICAgYy5uYW1lLmluY2x1ZGVzKCdzYi0nKSB8fFxuICAgICAgYy5uYW1lLmluY2x1ZGVzKCdzdXBhYmFzZScpXG4gICAgKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnRm91bmQgYXV0aC1yZWxhdGVkIGNvb2tpZXM6JywgYXV0aENvb2tpZXMubWFwKGMgPT4gYy5uYW1lKSk7XG5cbiAgICAvLyBTdXBhYmFzZSBzdG9yZXMgc2Vzc2lvbiBpbiBjb29raWVzIHdpdGggcGF0dGVybjogc2Ite3Byb2plY3QtcmVmfS1hdXRoLXRva2VuXG4gICAgLy8gRXh0cmFjdCBwcm9qZWN0IHJlZiBmcm9tIFVSTFxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoc3VwYWJhc2VVcmwpO1xuICAgIGNvbnN0IHByb2plY3RSZWYgPSB1cmwuaG9zdG5hbWUuc3BsaXQoJy4nKVswXTtcbiAgICBcbiAgICAvLyBUcnkgZGlmZmVyZW50IGNvb2tpZSBuYW1lIHBhdHRlcm5zXG4gICAgY29uc3QgY29va2llTmFtZXMgPSBbXG4gICAgICBgc2ItYXBpLWF1dGgtdG9rZW5gLCAvLyBUcnkgdGhpcyBmaXJzdCBhcyBpdCdzIG1vc3QgY29tbW9uXG4gICAgICBgc2ItJHtwcm9qZWN0UmVmfS1hdXRoLXRva2VuYCxcbiAgICAgIGBzYi0ke3Byb2plY3RSZWYucmVwbGFjZSgvLS9nLCAnJyl9LWF1dGgtdG9rZW5gLFxuICAgICAgYHNiLSR7cHJvamVjdFJlZn0tYXV0aC10b2tlbi1jb2RlLXZlcmlmaWVyYCwgLy8gU29tZXRpbWVzIHN0b3JlZCBzZXBhcmF0ZWx5XG4gICAgXTtcblxuICAgIGZvciAoY29uc3QgY29va2llTmFtZSBvZiBjb29raWVOYW1lcykge1xuICAgICAgY29uc3QgY29va2llID0gY29va2llU3RvcmUuZ2V0KGNvb2tpZU5hbWUpO1xuICAgICAgaWYgKGNvb2tpZT8udmFsdWUpIHtcbiAgICAgICAgLy8gTG9nIGZpcnN0IDEwMCBjaGFycyB0byBzZWUgZm9ybWF0ICh3aXRob3V0IGV4cG9zaW5nIGZ1bGwgdG9rZW4pXG4gICAgICAgIGNvbnN0IHByZXZpZXcgPSBjb29raWUudmFsdWUuc3Vic3RyaW5nKDAsIDEwMCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBDaGVja2luZyBjb29raWU6ICR7Y29va2llTmFtZX0sIGxlbmd0aDogJHtjb29raWUudmFsdWUubGVuZ3RofSwgcHJldmlldzogJHtwcmV2aWV3fS4uLmApO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUcnkgdG8gcGFyc2UgYXMgSlNPTiAoU3VwYWJhc2Ugc3RvcmVzIHNlc3Npb24gYXMgSlNPTiBzdHJpbmcpXG4gICAgICAgICAgbGV0IHNlc3Npb25EYXRhOiBhbnk7XG4gICAgICAgICAgbGV0IGRlY29kZWRWYWx1ZSA9IGNvb2tpZS52YWx1ZTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgVVJMIGRlY29kaW5nIGZpcnN0XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlY29kZWRWYWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChjb29raWUudmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgLy8gTm90IFVSTCBlbmNvZGVkLCB1c2UgYXMtaXNcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHBhcnNpbmcgYXMgSlNPTlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXNzaW9uRGF0YSA9IEpTT04ucGFyc2UoZGVjb2RlZFZhbHVlKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQYXJzZWQgJHtjb29raWVOYW1lfSBhcyBKU09OLCB0eXBlOmAsIEFycmF5LmlzQXJyYXkoc2Vzc2lvbkRhdGEpID8gJ2FycmF5JyA6IHR5cGVvZiBzZXNzaW9uRGF0YSwgJ2tleXM6JywgT2JqZWN0LmtleXMoc2Vzc2lvbkRhdGEgfHwge30pKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhbiBhcnJheSAoU3VwYWJhc2Ugc29tZXRpbWVzIHN0b3JlcyB0b2tlbnMgYXMgYXJyYXkpXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXNzaW9uRGF0YSkgJiYgc2Vzc2lvbkRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQXJyYXkgaGFzICR7c2Vzc2lvbkRhdGEubGVuZ3RofSBlbGVtZW50cywgY2hlY2tpbmcgZWFjaC4uLmApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gVHJ5IGVhY2ggZWxlbWVudCB0byBmaW5kIGEgdmFsaWQgSldUXG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2Vzc2lvbkRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gc2Vzc2lvbkRhdGFbaV07XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVsZW1lbnQgJHtpfSB0eXBlOiAke3R5cGVvZiBlbGVtZW50fSwgbGVuZ3RoOiAke3R5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyA/IGVsZW1lbnQubGVuZ3RoIDogJ04vQSd9YCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBxdW90ZXMgb3IgZXh0cmEgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgICAgbGV0IGNsZWFuVG9rZW4gPSBlbGVtZW50LnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBzdXJyb3VuZGluZyBxdW90ZXMgaWYgcHJlc2VudFxuICAgICAgICAgICAgICAgICAgaWYgKChjbGVhblRva2VuLnN0YXJ0c1dpdGgoJ1wiJykgJiYgY2xlYW5Ub2tlbi5lbmRzV2l0aCgnXCInKSkgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgKGNsZWFuVG9rZW4uc3RhcnRzV2l0aChcIidcIikgJiYgY2xlYW5Ub2tlbi5lbmRzV2l0aChcIidcIikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuVG9rZW4gPSBjbGVhblRva2VuLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgbG9va3MgbGlrZSBhIEpXVCAoaGFzIDMgcGFydHMgc2VwYXJhdGVkIGJ5IGRvdHMpXG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGNsZWFuVG9rZW4uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDMgJiYgY2xlYW5Ub2tlbi5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIHZhbGlkIEpXVCBzdHJ1Y3R1cmUgaW4gZWxlbWVudCAke2l9LCBsZW5ndGg6ICR7Y2xlYW5Ub2tlbi5sZW5ndGh9YCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoZSBKV1QgdG8gZ2V0IHVzZXIgSUQgZGlyZWN0bHkgKHdpdGhvdXQgdmFsaWRhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRlY29kZUpXVFBheWxvYWQoY2xlYW5Ub2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkICYmIChwYXlsb2FkLnN1YiB8fCBwYXlsb2FkLnVzZXJfaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlcklkID0gcGF5bG9hZC5zdWIgfHwgcGF5bG9hZC51c2VyX2lkO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFeHRyYWN0ZWQgdXNlciBJRCBmcm9tIEpXVDogJHt1c2VySWR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJJZDsgLy8gUmV0dXJuIHVzZXIgSUQgZGlyZWN0bHkgaW5zdGVhZCBvZiB0b2tlblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBkZWNvZGluZyBmYWlscywgdHJ5IHVzaW5nIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVG9rZW4gcHJldmlldzogJHtjbGVhblRva2VuLnN1YnN0cmluZygwLCA1MCl9Li4uYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGVhblRva2VuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBJZiBlbGVtZW50IGlzIGFuIG9iamVjdCwgY2hlY2sgZm9yIGFjY2Vzc190b2tlblxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0JyAmJiBlbGVtZW50LmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIGFjY2Vzc190b2tlbiBpbiBlbGVtZW50ICR7aX06YCwgY29va2llTmFtZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBJZiBubyBzaW5nbGUgZWxlbWVudCB3b3JrcywgdHJ5IGpvaW5pbmcgYWxsIHN0cmluZyBlbGVtZW50c1xuICAgICAgICAgICAgICBjb25zdCBhbGxTdHJpbmdzID0gc2Vzc2lvbkRhdGEuZmlsdGVyKGUgPT4gdHlwZW9mIGUgPT09ICdzdHJpbmcnKTtcbiAgICAgICAgICAgICAgaWYgKGFsbFN0cmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGpvaW5lZCA9IGFsbFN0cmluZ3Muam9pbignJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBqb2luZWQuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAzICYmIGpvaW5lZC5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBKV1QgYnkgam9pbmluZyBhcnJheSBlbGVtZW50cycpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGpvaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHNlc3Npb25EYXRhPy5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIGFjY2VzcyB0b2tlbiBpbiBjb29raWU6JywgY29va2llTmFtZSk7XG4gICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uRGF0YS5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBuZXN0ZWQgc2Vzc2lvbiBvYmplY3RcbiAgICAgICAgICAgIGlmIChzZXNzaW9uRGF0YT8uc2Vzc2lvbj8uYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBhY2Nlc3MgdG9rZW4gaW4gbmVzdGVkIHNlc3Npb246JywgY29va2llTmFtZSk7XG4gICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uRGF0YS5zZXNzaW9uLmFjY2Vzc190b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICAvLyBOb3QgSlNPTiwgbWlnaHQgYmUgZGlyZWN0IHRva2VuIG9yIGRpZmZlcmVudCBmb3JtYXRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDb29raWUgJHtjb29raWVOYW1lfSBpcyBub3QgSlNPTiwgY2hlY2tpbmcgaWYgaXQncyBhIEpXVGApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpdCBsb29rcyBsaWtlIGEgSldUIChoYXMgZG90cyBhbmQgaXMgbG9uZyBlbm91Z2gpXG4gICAgICAgICAgICBpZiAoZGVjb2RlZFZhbHVlLmxlbmd0aCA+IDEwMCAmJiBkZWNvZGVkVmFsdWUuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgICAvLyBMaWtlbHkgYSBKV1QgdG9rZW5cbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIEpXVCB0b2tlbiBpbiBjb29raWU6JywgY29va2llTmFtZSk7XG4gICAgICAgICAgICAgIHJldHVybiBkZWNvZGVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgY29va2llICR7Y29va2llTmFtZX06YCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJ5IHRvIGZpbmQgYW55IGNvb2tpZSB0aGF0IGxvb2tzIGxpa2UgYW4gYXV0aCB0b2tlblxuICAgIGZvciAoY29uc3QgY29va2llIG9mIGF1dGhDb29raWVzKSB7XG4gICAgICBpZiAoY29va2llLm5hbWUuaW5jbHVkZXMoJ2F1dGgtdG9rZW4nKSB8fCBjb29raWUubmFtZS5pbmNsdWRlcygnYXV0aF90b2tlbicpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHNlc3Npb25EYXRhOiBhbnk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlc3Npb25EYXRhID0gSlNPTi5wYXJzZShkZWNvZGVVUklDb21wb25lbnQoY29va2llLnZhbHVlKSk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBzZXNzaW9uRGF0YSA9IEpTT04ucGFyc2UoY29va2llLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHNlc3Npb25EYXRhPy5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBhY2Nlc3MgdG9rZW4gaW4gYXV0aCBjb29raWU6JywgY29va2llLm5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25EYXRhLmFjY2Vzc190b2tlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIE5vdCBKU09OLCBtaWdodCBiZSBkaXJlY3QgdG9rZW5cbiAgICAgICAgICBpZiAoY29va2llLnZhbHVlLmxlbmd0aCA+IDEwMCAmJiBjb29raWUudmFsdWUuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgLy8gTG9va3MgbGlrZSBhIEpXVFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIEpXVCBpbiBhdXRoIGNvb2tpZTonLCBjb29raWUubmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gY29va2llLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdObyBhY2Nlc3MgdG9rZW4gZm91bmQgaW4gY29va2llcycpO1xuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGV4dHJhY3RpbmcgdG9rZW4gZnJvbSBjb29raWVzOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBhdXRoZW50aWNhdGVkIHVzZXIgZnJvbSB0aGUgcmVxdWVzdFxuICogXG4gKiBSZXR1cm5zIHRoZSB1c2VyIElEIGZyb20gU3VwYWJhc2UgQXV0aCBKV1QsIG9yIG51bGwgaWYgbm90IGF1dGhlbnRpY2F0ZWQuXG4gKiBVc2UgdGhpcyBpbiBBUEkgcm91dGVzIHRvIGdldCB0aGUgY3VycmVudCB1c2VyLlxuICogXG4gKiBVc2FnZTpcbiAqIGBgYHRzXG4gKiBjb25zdCB1c2VySWQgPSBhd2FpdCBnZXRDdXJyZW50VXNlcklkKCk7XG4gKiBpZiAoIXVzZXJJZCkge1xuICogICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogJ1VuYXV0aG9yaXplZCcgfSwgeyBzdGF0dXM6IDQwMSB9KTtcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VycmVudFVzZXJJZCgpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTDtcbiAgICBjb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWTtcblxuICAgIGlmICghc3VwYWJhc2VVcmwgfHwgIXN1cGFiYXNlQW5vbktleSkge1xuICAgICAgY29uc29sZS5lcnJvcignTWlzc2luZyBTdXBhYmFzZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMnKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIEZpcnN0IHRyeSB0byBnZXQgdG9rZW4gZnJvbSBBdXRob3JpemF0aW9uIGhlYWRlclxuICAgIHRyeSB7XG4gICAgICBjb25zdCBoZWFkZXJzTGlzdCA9IGF3YWl0IGhlYWRlcnMoKTtcbiAgICAgIGNvbnN0IGF1dGhIZWFkZXIgPSBoZWFkZXJzTGlzdC5nZXQoJ2F1dGhvcml6YXRpb24nKTtcbiAgICAgIGlmIChhdXRoSGVhZGVyPy5zdGFydHNXaXRoKCdCZWFyZXIgJykpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBhdXRoSGVhZGVyLnN1YnN0cmluZyg3KTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXksIHtcbiAgICAgICAgICBnbG9iYWw6IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9LCBlcnJvciB9ID0gYXdhaXQgY2xpZW50LmF1dGguZ2V0VXNlcigpO1xuICAgICAgICBpZiAoIWVycm9yICYmIHVzZXIpIHtcbiAgICAgICAgICByZXR1cm4gdXNlci5pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB3aXRoIEF1dGhvcml6YXRpb24gaGVhZGVyOicsIGVycm9yKTtcbiAgICAgIC8vIENvbnRpbnVlIHRvIGNvb2tpZS1iYXNlZCBhdXRoXG4gICAgfVxuICAgIFxuICAgIC8vIFRyeSB0byBleHRyYWN0IGFjY2VzcyB0b2tlbiBvciB1c2VyIElEIGZyb20gY29va2llc1xuICAgIGNvbnN0IHRva2VuT3JVc2VySWQgPSBhd2FpdCBnZXRBY2Nlc3NUb2tlbkZyb21Db29raWVzKCk7XG4gICAgaWYgKHRva2VuT3JVc2VySWQpIHtcbiAgICAgIC8vIElmIGl0J3MgYWxyZWFkeSBhIHVzZXIgSUQgKGZyb20gSldUIGRlY29kZSksIHJldHVybiBpdFxuICAgICAgaWYgKHRva2VuT3JVc2VySWQubGVuZ3RoIDwgNTAgJiYgdG9rZW5PclVzZXJJZC5pbmNsdWRlcygnLScpKSB7XG4gICAgICAgIC8vIExvb2tzIGxpa2UgYSBVVUlEICh1c2VyIElEKVxuICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgZXh0cmFjdGVkIHVzZXIgSUQgZGlyZWN0bHk6JywgdG9rZW5PclVzZXJJZCk7XG4gICAgICAgIHJldHVybiB0b2tlbk9yVXNlcklkO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBPdGhlcndpc2UsIHRyeSB1c2luZyBpdCBhcyBhIHRva2VuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgICAgIGdsb2JhbDoge1xuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW5PclVzZXJJZH1gLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSwgZXJyb3IgfSA9IGF3YWl0IGNsaWVudC5hdXRoLmdldFVzZXIoKTtcbiAgICAgICAgaWYgKCFlcnJvciAmJiB1c2VyKSB7XG4gICAgICAgICAgcmV0dXJuIHVzZXIuaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igd2l0aCBjb29raWUgdG9rZW46JywgZXJyb3IpO1xuICAgICAgICAgIC8vIElmIHRva2VuIHZhbGlkYXRpb24gZmFpbHMsIHRyeSBkZWNvZGluZyBKV1QgZGlyZWN0bHlcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGVjb2RlSldUUGF5bG9hZCh0b2tlbk9yVXNlcklkKTtcbiAgICAgICAgICBpZiAocGF5bG9hZCAmJiAocGF5bG9hZC5zdWIgfHwgcGF5bG9hZC51c2VyX2lkKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0V4dHJhY3RlZCB1c2VyIElEIGZyb20gSldUIGFmdGVyIHZhbGlkYXRpb24gZmFpbGVkOicsIHBheWxvYWQuc3ViIHx8IHBheWxvYWQudXNlcl9pZCk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZC5zdWIgfHwgcGF5bG9hZC51c2VyX2lkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igd2l0aCBjb29raWUgdG9rZW46JywgZXJyb3IpO1xuICAgICAgICAvLyBUcnkgZGVjb2RpbmcgSldUIGFzIGZhbGxiYWNrXG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBkZWNvZGVKV1RQYXlsb2FkKHRva2VuT3JVc2VySWQpO1xuICAgICAgICBpZiAocGF5bG9hZCAmJiAocGF5bG9hZC5zdWIgfHwgcGF5bG9hZC51c2VyX2lkKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdFeHRyYWN0ZWQgdXNlciBJRCBmcm9tIEpXVCBhcyBmYWxsYmFjazonLCBwYXlsb2FkLnN1YiB8fCBwYXlsb2FkLnVzZXJfaWQpO1xuICAgICAgICAgIHJldHVybiBwYXlsb2FkLnN1YiB8fCBwYXlsb2FkLnVzZXJfaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbGJhY2s6IFRyeSBjb29raWUtYmFzZWQgYXV0aCB3aXRoIGNyZWF0ZVNlcnZlckNsaWVudFxuICAgIC8vIFRoaXMgbWlnaHQgd29yayBpZiBjb29raWVzIGFyZSBzZXQgdXAgY29ycmVjdGx5XG4gICAgdHJ5IHtcbiAgICBjb25zdCBzdXBhYmFzZSA9IGF3YWl0IGNyZWF0ZVNlcnZlckNsaWVudCgpO1xuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0sIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICBcbiAgICAgIGlmICghZXJyb3IgJiYgdXNlcikge1xuICAgICAgICByZXR1cm4gdXNlci5pZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dGggZXJyb3IgZnJvbSBjcmVhdGVTZXJ2ZXJDbGllbnQ6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB3aXRoIGNyZWF0ZVNlcnZlckNsaWVudDonLCBlcnJvcik7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgY3VycmVudCB1c2VyOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBhdXRoZW50aWNhdGVkIFN1cGFiYXNlIGNsaWVudCB3aXRoIGEgc3BlY2lmaWMgYWNjZXNzIHRva2VuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUF1dGhlbnRpY2F0ZWRDbGllbnQoYWNjZXNzVG9rZW46IHN0cmluZykge1xuICBjb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTDtcbiAgY29uc3Qgc3VwYWJhc2VBbm9uS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVk7XG5cbiAgaWYgKCFzdXBhYmFzZVVybCB8fCAhc3VwYWJhc2VBbm9uS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFN1cGFiYXNlIGVudmlyb25tZW50IHZhcmlhYmxlcycpO1xuICB9XG5cbiAgY29uc3QgeyBjcmVhdGVDbGllbnQgfSA9IGF3YWl0IGltcG9ydCgnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJyk7XG4gIHJldHVybiBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgIGdsb2JhbDoge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBhdXRoOiB7XG4gICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsXG4gICAgICBhdXRvUmVmcmVzaFRva2VuOiBmYWxzZSxcbiAgICB9LFxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgdXNlcidzIGJ1c2luZXNzIElEXG4gKiBcbiAqIFJldHVybnMgdGhlIGJ1c2luZXNzIElEIGZvciB0aGUgYXV0aGVudGljYXRlZCB1c2VyLCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAqIFxuICogVXNhZ2U6XG4gKiBgYGB0c1xuICogY29uc3QgYnVzaW5lc3NJZCA9IGF3YWl0IGdldEN1cnJlbnRCdXNpbmVzc0lkKCk7XG4gKiBpZiAoIWJ1c2luZXNzSWQpIHtcbiAqICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6ICdCdXNpbmVzcyBub3QgZm91bmQnIH0sIHsgc3RhdHVzOiA0MDQgfSk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEN1cnJlbnRCdXNpbmVzc0lkKCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHVzZXJJZCA9IGF3YWl0IGdldEN1cnJlbnRVc2VySWQoKTtcbiAgICBpZiAoIXVzZXJJZCkge1xuICAgICAgY29uc29sZS5lcnJvcignW2dldEN1cnJlbnRCdXNpbmVzc0lkXSBObyB1c2VyIElEIGZvdW5kJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1tnZXRDdXJyZW50QnVzaW5lc3NJZF0gTG9va2luZyBmb3IgYnVzaW5lc3MgZm9yIHVzZXI6JywgdXNlcklkKTtcbiAgICBcbiAgICAvLyBMb2cgU3VwYWJhc2UgcHJvamVjdCBpbmZvIGZvciBkZWJ1Z2dpbmdcbiAgICBjb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTDtcbiAgICBpZiAoc3VwYWJhc2VVcmwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoc3VwYWJhc2VVcmwpO1xuICAgICAgICBjb25zdCBwcm9qZWN0UmVmID0gdXJsLmhvc3RuYW1lLnNwbGl0KCcuJylbMF07XG4gICAgICAgIGNvbnNvbGUubG9nKCdbZ2V0Q3VycmVudEJ1c2luZXNzSWRdIFVzaW5nIFN1cGFiYXNlIHByb2plY3Q6JywgcHJvamVjdFJlZik7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tnZXRDdXJyZW50QnVzaW5lc3NJZF0gU3VwYWJhc2UgVVJMOicsIHN1cGFiYXNlVXJsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gVXNlIGNyZWF0ZVNlcnZlckNsaWVudCB3aGljaCBzaG91bGQgaGFuZGxlIGNvb2tpZXMgcHJvcGVybHlcbiAgICAvLyBJZiB0aGF0IGZhaWxzIGR1ZSB0byBSTFMsIHdlJ2xsIHVzZSBzZXJ2aWNlIHJvbGUgYXMgZmFsbGJhY2tcbiAgICBjb25zdCBzdXBhYmFzZSA9IGF3YWl0IGNyZWF0ZVNlcnZlckNsaWVudCgpO1xuICAgIFxuICAgIC8vIFF1ZXJ5IGZvciBidXNpbmVzc1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYnVzaW5lc3NlcycpXG4gICAgICAuc2VsZWN0KCdpZCwgbmFtZScpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAuaXMoJ2RlbGV0ZWRfYXQnLCBudWxsKVxuICAgICAgLm1heWJlU2luZ2xlKCk7IC8vIFVzZSBtYXliZVNpbmdsZSgpIGluc3RlYWQgb2Ygc2luZ2xlKCkgdG8gYXZvaWQgZXJyb3IgaWYgbm90IGZvdW5kXG4gICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbZ2V0Q3VycmVudEJ1c2luZXNzSWRdIEVycm9yIHF1ZXJ5aW5nIGJ1c2luZXNzOicsIGVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gSWYgUkxTIGVycm9yLCB0cnkgd2l0aCBzZXJ2aWNlIHJvbGUgKHdlIGFscmVhZHkgdmVyaWZpZWQgdXNlciBpcyBhdXRoZW50aWNhdGVkKVxuICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdQR1JTVDMwMScgfHwgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ05vIHN1aXRhYmxlIGtleScpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbZ2V0Q3VycmVudEJ1c2luZXNzSWRdIFJMUyBlcnJvciwgdHJ5aW5nIHdpdGggc2VydmljZSByb2xlIGZvciB1c2VyOicsIHVzZXJJZCk7XG4gICAgICAgIGNvbnN0IHsgY3JlYXRlQWRtaW5DbGllbnQgfSA9IGF3YWl0IGltcG9ydCgnQC9saWIvZGInKTtcbiAgICAgICAgY29uc3QgYWRtaW5TdXBhYmFzZSA9IGNyZWF0ZUFkbWluQ2xpZW50KCk7XG4gICAgICAgIFxuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiBBTlkgYnVzaW5lc3NlcyBleGlzdCBmb3IgdGhpcyB1c2VyIChpbmNsdWRpbmcgZGVsZXRlZClcbiAgICAgICAgY29uc3QgeyBkYXRhOiBhbGxCdXNpbmVzc2VzLCBlcnJvcjogYWxsRXJyb3IgfSA9IGF3YWl0IGFkbWluU3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnYnVzaW5lc3NlcycpXG4gICAgICAgICAgLnNlbGVjdCgnaWQsIG5hbWUsIGRlbGV0ZWRfYXQsIHVzZXJfaWQnKVxuICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZCk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnW2dldEN1cnJlbnRCdXNpbmVzc0lkXSBBbGwgYnVzaW5lc3NlcyBmb3IgdXNlciAoYWRtaW4pOicsIGFsbEJ1c2luZXNzZXM/Lmxlbmd0aCB8fCAwKTtcbiAgICAgICAgaWYgKGFsbEJ1c2luZXNzZXMgJiYgYWxsQnVzaW5lc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tnZXRDdXJyZW50QnVzaW5lc3NJZF0gQnVzaW5lc3NlcyBmb3VuZDonLCBhbGxCdXNpbmVzc2VzLm1hcChiID0+ICh7IFxuICAgICAgICAgICAgaWQ6IGIuaWQsIFxuICAgICAgICAgICAgbmFtZTogYi5uYW1lLCBcbiAgICAgICAgICAgIGRlbGV0ZWQ6ICEhYi5kZWxldGVkX2F0LFxuICAgICAgICAgICAgdXNlcl9pZDogYi51c2VyX2lkXG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbZ2V0Q3VycmVudEJ1c2luZXNzSWRdIEVycm9yIGNoZWNraW5nIGFsbCBidXNpbmVzc2VzOicsIGFsbEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRGlhZ25vc3RpYzogQ2hlY2sgaWYgdGhlcmUgYXJlIEFOWSBidXNpbmVzc2VzIGF0IGFsbCAodG8gZGV0ZWN0IHVzZXIgSUQgbWlzbWF0Y2gpXG4gICAgICAgIGNvbnN0IHsgZGF0YTogYW55QnVzaW5lc3NlcywgZXJyb3I6IGFueUVycm9yIH0gPSBhd2FpdCBhZG1pblN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2J1c2luZXNzZXMnKVxuICAgICAgICAgIC5zZWxlY3QoJ2lkLCBuYW1lLCB1c2VyX2lkLCBkZWxldGVkX2F0JylcbiAgICAgICAgICAubGltaXQoMTApO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFhbnlFcnJvciAmJiBhbnlCdXNpbmVzc2VzICYmIGFueUJ1c2luZXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbZ2V0Q3VycmVudEJ1c2luZXNzSWRdIERJQUdOT1NUSUM6IEZvdW5kIGJ1c2luZXNzZXMgaW4gZGF0YWJhc2U6JywgYW55QnVzaW5lc3Nlcy5tYXAoYiA9PiAoe1xuICAgICAgICAgICAgaWQ6IGIuaWQsXG4gICAgICAgICAgICBuYW1lOiBiLm5hbWUsXG4gICAgICAgICAgICB1c2VyX2lkOiBiLnVzZXJfaWQsXG4gICAgICAgICAgICBtYXRjaGVzX2N1cnJlbnRfdXNlcjogYi51c2VyX2lkID09PSB1c2VySWQsXG4gICAgICAgICAgICBkZWxldGVkOiAhIWIuZGVsZXRlZF9hdFxuICAgICAgICAgIH0pKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWFueUVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tnZXRDdXJyZW50QnVzaW5lc3NJZF0gRElBR05PU1RJQzogTm8gYnVzaW5lc3NlcyBleGlzdCBpbiBkYXRhYmFzZSBhdCBhbGwnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbZ2V0Q3VycmVudEJ1c2luZXNzSWRdIERJQUdOT1NUSUM6IEVycm9yIGNoZWNraW5nIGFsbCBidXNpbmVzc2VzOicsIGFueUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTm93IGdldCB0aGUgbm9uLWRlbGV0ZWQgb25lXG4gICAgICAgIGNvbnN0IHsgZGF0YTogYWRtaW5EYXRhLCBlcnJvcjogYWRtaW5FcnJvciB9ID0gYXdhaXQgYWRtaW5TdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdidXNpbmVzc2VzJylcbiAgICAgICAgICAuc2VsZWN0KCdpZCwgbmFtZScpXG4gICAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgICAgIC5pcygnZGVsZXRlZF9hdCcsIG51bGwpXG4gICAgICAgICAgLm1heWJlU2luZ2xlKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoYWRtaW5FcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tnZXRDdXJyZW50QnVzaW5lc3NJZF0gRXJyb3Igd2l0aCBhZG1pbiBjbGllbnQ6JywgYWRtaW5FcnJvcik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChhZG1pbkRhdGEpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW2dldEN1cnJlbnRCdXNpbmVzc0lkXSBGb3VuZCBidXNpbmVzcyB3aXRoIGFkbWluIGNsaWVudDonLCBhZG1pbkRhdGEuaWQsIGFkbWluRGF0YS5uYW1lKTtcbiAgICAgICAgICByZXR1cm4gYWRtaW5EYXRhLmlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tnZXRDdXJyZW50QnVzaW5lc3NJZF0gTm8gYnVzaW5lc3MgZm91bmQgd2l0aCBhZG1pbiBjbGllbnQgZm9yIHVzZXI6JywgdXNlcklkKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbZ2V0Q3VycmVudEJ1c2luZXNzSWRdIE5vIGJ1c2luZXNzIGZvdW5kIGZvciB1c2VyOicsIHVzZXJJZCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1tnZXRDdXJyZW50QnVzaW5lc3NJZF0gRm91bmQgYnVzaW5lc3M6JywgZGF0YS5pZCwgZGF0YS5uYW1lKTtcbiAgICByZXR1cm4gZGF0YS5pZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbZ2V0Q3VycmVudEJ1c2luZXNzSWRdIEVycm9yIGdldHRpbmcgY3VycmVudCBidXNpbmVzczonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuXG5cblxuIl0sIm5hbWVzIjpbImNyZWF0ZVNlcnZlckNsaWVudCIsImhlYWRlcnMiLCJjb29raWVzIiwiY3JlYXRlQ2xpZW50IiwiZGVjb2RlSldUUGF5bG9hZCIsInRva2VuIiwicGFydHMiLCJzcGxpdCIsImxlbmd0aCIsInBheWxvYWQiLCJwYWRkZWRQYXlsb2FkIiwicmVwZWF0IiwiZGVjb2RlZCIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiY29uc29sZSIsImdldFJhd1Rva2VuRnJvbUNvb2tpZXMiLCJjb29raWVTdG9yZSIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsImFsbENvb2tpZXMiLCJnZXRBbGwiLCJhdXRoQ29va2llcyIsImZpbHRlciIsImMiLCJuYW1lIiwiaW5jbHVkZXMiLCJ1cmwiLCJVUkwiLCJwcm9qZWN0UmVmIiwiaG9zdG5hbWUiLCJjb29raWVOYW1lcyIsInJlcGxhY2UiLCJjb29raWVOYW1lIiwiY29va2llIiwiZ2V0IiwidmFsdWUiLCJkZWNvZGVkVmFsdWUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzZXNzaW9uRGF0YSIsIkFycmF5IiwiaXNBcnJheSIsImZpcnN0RWxlbWVudCIsImNsZWFuVG9rZW4iLCJ0cmltIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwic2xpY2UiLCJhY2Nlc3NfdG9rZW4iLCJzZXNzaW9uIiwicGFyc2VFcnJvciIsImdldEFjY2Vzc1Rva2VuRnJvbUNvb2tpZXMiLCJsb2ciLCJtYXAiLCJwcmV2aWV3Iiwic3Vic3RyaW5nIiwiT2JqZWN0Iiwia2V5cyIsImkiLCJlbGVtZW50Iiwic3ViIiwidXNlcl9pZCIsInVzZXJJZCIsImFsbFN0cmluZ3MiLCJlIiwiam9pbmVkIiwiam9pbiIsImdldEN1cnJlbnRVc2VySWQiLCJzdXBhYmFzZUFub25LZXkiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsImhlYWRlcnNMaXN0IiwiYXV0aEhlYWRlciIsImNsaWVudCIsImdsb2JhbCIsIkF1dGhvcml6YXRpb24iLCJkYXRhIiwidXNlciIsImF1dGgiLCJnZXRVc2VyIiwiaWQiLCJ0b2tlbk9yVXNlcklkIiwic3VwYWJhc2UiLCJjcmVhdGVBdXRoZW50aWNhdGVkQ2xpZW50IiwiYWNjZXNzVG9rZW4iLCJFcnJvciIsInBlcnNpc3RTZXNzaW9uIiwiYXV0b1JlZnJlc2hUb2tlbiIsImdldEN1cnJlbnRCdXNpbmVzc0lkIiwic2VsZWN0IiwiZXEiLCJpcyIsIm1heWJlU2luZ2xlIiwiY29kZSIsIm1lc3NhZ2UiLCJjcmVhdGVBZG1pbkNsaWVudCIsImFkbWluU3VwYWJhc2UiLCJhbGxCdXNpbmVzc2VzIiwiYWxsRXJyb3IiLCJiIiwiZGVsZXRlZCIsImRlbGV0ZWRfYXQiLCJhbnlCdXNpbmVzc2VzIiwiYW55RXJyb3IiLCJsaW1pdCIsIm1hdGNoZXNfY3VycmVudF91c2VyIiwiYWRtaW5EYXRhIiwiYWRtaW5FcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/auth.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/db.ts":
/*!***********************!*\
  !*** ./src/lib/db.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAdminClient: () => (/* binding */ createAdminClient),\n/* harmony export */   createClientClient: () => (/* binding */ createClientClient),\n/* harmony export */   createServerClient: () => (/* binding */ createServerClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/../../node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var next_headers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/headers */ \"(rsc)/./node_modules/next/dist/api/headers.js\");\n\n\n/**\n * Get Supabase client for server-side operations\n * \n * This function returns different clients based on context:\n * - If called from an authenticated API route, uses the user's JWT from Authorization header (respects RLS)\n * - If called from a public route or background job, uses service role (bypasses RLS)\n * \n * Usage in API routes:\n * ```ts\n * const supabase = await createServerClient();\n * const { data } = await supabase.from('businesses').select('*');\n * ```\n */ async function createServerClient() {\n    const supabaseUrl = \"https://rgwooqakdvrchfwrdnyx.supabase.co\";\n    const supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJnd29vcWFrZHZyY2hmd3Jkbnl4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMzOTQyNDEsImV4cCI6MjA3ODk3MDI0MX0.YpX0dYf_iueJVR1oK5SvREnO765JAKxriy2csdAEZlI\";\n    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n    if (!supabaseUrl) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_URL environment variable\");\n    }\n    if (!supabaseAnonKey && !supabaseServiceKey) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_ANON_KEY or SUPABASE_SERVICE_ROLE_KEY environment variable\");\n    }\n    // Try to get the user's JWT from Authorization header (for API routes)\n    let accessToken;\n    try {\n        const headersList = await (0,next_headers__WEBPACK_IMPORTED_MODULE_0__.headers)();\n        const authHeader = headersList.get(\"authorization\");\n        if (authHeader?.startsWith(\"Bearer \")) {\n            accessToken = authHeader.substring(7);\n        }\n    } catch  {\n    // Not in a headers context\n    }\n    // If we have a user token from header, use anon key with that token (respects RLS)\n    if (accessToken && supabaseAnonKey) {\n        return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${accessToken}`\n                }\n            }\n        });\n    }\n    // Try to get session from cookies (Supabase stores session in cookies)\n    try {\n        const cookieStore = await (0,next_headers__WEBPACK_IMPORTED_MODULE_0__.cookies)();\n        const allCookies = cookieStore.getAll();\n        // Try to extract access token from cookies first\n        const supabaseUrlObj = new URL(supabaseUrl);\n        const projectRef = supabaseUrlObj.hostname.split(\".\")[0];\n        // Look for Supabase auth token cookie\n        // Try sb-api-auth-token first as it's the most common\n        const authCookieNames = [\n            `sb-api-auth-token`,\n            `sb-${projectRef}-auth-token`\n        ];\n        let accessToken;\n        for (const cookieName of authCookieNames){\n            const cookie = cookieStore.get(cookieName);\n            if (cookie?.value) {\n                // Log first 100 chars to see format (without exposing full token)\n                const preview = cookie.value.substring(0, 100);\n                console.log(`[createServerClient] Checking cookie: ${cookieName}, length: ${cookie.value.length}, preview: ${preview}...`);\n                try {\n                    // Try URL decoding first\n                    let decodedValue = cookie.value;\n                    try {\n                        decodedValue = decodeURIComponent(cookie.value);\n                    } catch  {\n                    // Not URL encoded\n                    }\n                    // Try parsing as JSON\n                    try {\n                        const session = JSON.parse(decodedValue);\n                        console.log(`[createServerClient] Parsed ${cookieName} as JSON, type:`, Array.isArray(session) ? \"array\" : typeof session, \"keys:\", Object.keys(session || {}));\n                        // Check if it's an array (Supabase sometimes stores tokens as array)\n                        if (Array.isArray(session) && session.length > 0) {\n                            console.log(`[createServerClient] Array has ${session.length} elements, checking each...`);\n                            // Try each element to find a valid JWT\n                            for(let i = 0; i < session.length; i++){\n                                const element = session[i];\n                                if (typeof element === \"string\") {\n                                    // Remove any quotes or extra characters\n                                    let cleanToken = element.trim();\n                                    if (cleanToken.startsWith('\"') && cleanToken.endsWith('\"') || cleanToken.startsWith(\"'\") && cleanToken.endsWith(\"'\")) {\n                                        cleanToken = cleanToken.slice(1, -1);\n                                    }\n                                    // Check if it looks like a JWT (has 3 parts separated by dots)\n                                    const parts = cleanToken.split(\".\");\n                                    if (parts.length === 3 && cleanToken.length > 100) {\n                                        console.log(`[createServerClient] Found valid JWT structure in element ${i}, using it as access token`);\n                                        // Use this token - even if signature validation fails later, \n                                        // Supabase might still accept it for RLS if the payload is valid\n                                        accessToken = cleanToken;\n                                        break;\n                                    }\n                                }\n                                // If element is an object, check for access_token\n                                if (element && typeof element === \"object\" && element.access_token) {\n                                    console.log(`[createServerClient] Found access_token in element ${i}: ${cookieName}`);\n                                    accessToken = element.access_token;\n                                    break;\n                                }\n                            }\n                            if (accessToken) {\n                                break;\n                            }\n                            // If no single element works, try joining all string elements\n                            const allStrings = session.filter((e)=>typeof e === \"string\");\n                            if (allStrings.length > 0) {\n                                const joined = allStrings.join(\"\");\n                                const parts = joined.split(\".\");\n                                if (parts.length === 3 && joined.length > 100) {\n                                    console.log(\"[createServerClient] Found JWT by joining array elements\");\n                                    accessToken = joined;\n                                    break;\n                                }\n                            }\n                        }\n                        if (session?.access_token) {\n                            console.log(`[createServerClient] Found access_token in ${cookieName}`);\n                            accessToken = session.access_token;\n                            break;\n                        }\n                        // Check for nested session object\n                        if (session?.session?.access_token) {\n                            console.log(`[createServerClient] Found access_token in nested session: ${cookieName}`);\n                            accessToken = session.session.access_token;\n                            break;\n                        }\n                    } catch (parseError) {\n                        // Not JSON, might be direct JWT token\n                        console.log(`[createServerClient] ${cookieName} is not JSON, checking if JWT`);\n                        if (decodedValue.length > 100 && decodedValue.includes(\".\")) {\n                            console.log(`[createServerClient] Using ${cookieName} as direct JWT token`);\n                            accessToken = decodedValue;\n                            break;\n                        }\n                    }\n                } catch (error) {\n                    console.error(`[createServerClient] Error processing ${cookieName}:`, error);\n                }\n            }\n        }\n        // If we found an access token, use it directly\n        if (accessToken && supabaseAnonKey) {\n            return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey, {\n                global: {\n                    headers: {\n                        Authorization: `Bearer ${accessToken}`\n                    }\n                },\n                auth: {\n                    persistSession: false,\n                    autoRefreshToken: false\n                }\n            });\n        }\n        // Fallback: Build cookie header for Supabase to read\n        const cookieHeader = allCookies.map((c)=>`${c.name}=${c.value}`).join(\"; \");\n        if (cookieHeader && supabaseAnonKey) {\n            // Create client with cookies - Supabase will extract session from cookies\n            return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey, {\n                global: {\n                    headers: {\n                        Cookie: cookieHeader\n                    }\n                },\n                auth: {\n                    persistSession: false,\n                    autoRefreshToken: false\n                }\n            });\n        }\n    } catch (error) {\n        console.error(\"Error reading cookies in createServerClient:\", error);\n    // Not in a cookies context, continue\n    }\n    // For public routes or background jobs, use service role key\n    // WARNING: This bypasses RLS - only use when necessary\n    if (supabaseServiceKey) {\n        return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseServiceKey, {\n            auth: {\n                autoRefreshToken: false,\n                persistSession: false\n            }\n        });\n    }\n    // Fallback to anon key (for public read operations)\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey);\n}\n/**\n * Get Supabase client with service role (bypasses RLS)\n * \n * Use this ONLY for:\n * - Background jobs\n * - Webhook handlers\n * - Admin operations that need to bypass RLS\n * \n * Usage:\n * ```ts\n * const supabase = createAdminClient();\n * const { data } = await supabase.from('businesses').select('*');\n * ```\n */ function createAdminClient() {\n    const supabaseUrl = \"https://rgwooqakdvrchfwrdnyx.supabase.co\";\n    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n    if (!supabaseUrl) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_URL environment variable\");\n    }\n    if (!supabaseServiceKey) {\n        throw new Error(\"Missing SUPABASE_SERVICE_ROLE_KEY environment variable\");\n    }\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseServiceKey, {\n        auth: {\n            autoRefreshToken: false,\n            persistSession: false\n        }\n    });\n}\n/**\n * Get Supabase client for client-side operations\n * \n * This should be used in React components or client-side code.\n * It uses the anon key and relies on Supabase Auth for authentication.\n * \n * Usage in client components:\n * ```ts\n * 'use client';\n * const supabase = createClientClient();\n * ```\n */ function createClientClient() {\n    const supabaseUrl = \"https://rgwooqakdvrchfwrdnyx.supabase.co\";\n    const supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJnd29vcWFrZHZyY2hmd3Jkbnl4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMzOTQyNDEsImV4cCI6MjA3ODk3MDI0MX0.YpX0dYf_iueJVR1oK5SvREnO765JAKxriy2csdAEZlI\";\n    if (!supabaseUrl) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_URL environment variable\");\n    }\n    if (!supabaseAnonKey) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable\");\n    }\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDRjtBQUVBOzs7Ozs7Ozs7OztDQVdDLEdBQ00sU0FBU1E7SUFDZCxNQUFNbkUsY0FBY0MsMENBQW9DO0lBQ3hELE1BQU1HLGtCQUFrQkgsa05BQXlDO0lBRWpFLElBQUksQ0FBQ0QsYUFBYTtRQUNoQixNQUFNLElBQUlRLE1BQU07SUFDbEI7SUFFQSxJQUFJLENBQUNKLGlCQUFpQjtRQUNwQixNQUFNLElBQUlJLE1BQU07SUFDbEI7SUFFQSxPQUFPWixtRUFBWUEsQ0FBQ0ksYUFBYUk7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9zcmMvbGliL2RiLnRzPzllNGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50LCBTdXBhYmFzZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5pbXBvcnQgeyBjb29raWVzLCBoZWFkZXJzIH0gZnJvbSAnbmV4dC9oZWFkZXJzJztcblxuLyoqXG4gKiBHZXQgU3VwYWJhc2UgY2xpZW50IGZvciBzZXJ2ZXItc2lkZSBvcGVyYXRpb25zXG4gKiBcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBkaWZmZXJlbnQgY2xpZW50cyBiYXNlZCBvbiBjb250ZXh0OlxuICogLSBJZiBjYWxsZWQgZnJvbSBhbiBhdXRoZW50aWNhdGVkIEFQSSByb3V0ZSwgdXNlcyB0aGUgdXNlcidzIEpXVCBmcm9tIEF1dGhvcml6YXRpb24gaGVhZGVyIChyZXNwZWN0cyBSTFMpXG4gKiAtIElmIGNhbGxlZCBmcm9tIGEgcHVibGljIHJvdXRlIG9yIGJhY2tncm91bmQgam9iLCB1c2VzIHNlcnZpY2Ugcm9sZSAoYnlwYXNzZXMgUkxTKVxuICogXG4gKiBVc2FnZSBpbiBBUEkgcm91dGVzOlxuICogYGBgdHNcbiAqIGNvbnN0IHN1cGFiYXNlID0gYXdhaXQgY3JlYXRlU2VydmVyQ2xpZW50KCk7XG4gKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2J1c2luZXNzZXMnKS5zZWxlY3QoJyonKTtcbiAqIGBgYFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlU2VydmVyQ2xpZW50KCk6IFByb21pc2U8U3VwYWJhc2VDbGllbnQ+IHtcbiAgY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkw7XG4gIGNvbnN0IHN1cGFiYXNlQW5vbktleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZO1xuICBjb25zdCBzdXBhYmFzZVNlcnZpY2VLZXkgPSBwcm9jZXNzLmVudi5TVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZO1xuXG4gIGlmICghc3VwYWJhc2VVcmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIGVudmlyb25tZW50IHZhcmlhYmxlJyk7XG4gIH1cblxuICBpZiAoIXN1cGFiYXNlQW5vbktleSAmJiAhc3VwYWJhc2VTZXJ2aWNlS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ01pc3NpbmcgTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgb3IgU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSdcbiAgICApO1xuICB9XG5cbiAgLy8gVHJ5IHRvIGdldCB0aGUgdXNlcidzIEpXVCBmcm9tIEF1dGhvcml6YXRpb24gaGVhZGVyIChmb3IgQVBJIHJvdXRlcylcbiAgbGV0IGFjY2Vzc1Rva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IGhlYWRlcnNMaXN0ID0gYXdhaXQgaGVhZGVycygpO1xuICAgIGNvbnN0IGF1dGhIZWFkZXIgPSBoZWFkZXJzTGlzdC5nZXQoJ2F1dGhvcml6YXRpb24nKTtcbiAgICBpZiAoYXV0aEhlYWRlcj8uc3RhcnRzV2l0aCgnQmVhcmVyICcpKSB7XG4gICAgICBhY2Nlc3NUb2tlbiA9IGF1dGhIZWFkZXIuc3Vic3RyaW5nKDcpO1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgLy8gTm90IGluIGEgaGVhZGVycyBjb250ZXh0XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlIGEgdXNlciB0b2tlbiBmcm9tIGhlYWRlciwgdXNlIGFub24ga2V5IHdpdGggdGhhdCB0b2tlbiAocmVzcGVjdHMgUkxTKVxuICBpZiAoYWNjZXNzVG9rZW4gJiYgc3VwYWJhc2VBbm9uS2V5KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5LCB7XG4gICAgICBnbG9iYWw6IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRyeSB0byBnZXQgc2Vzc2lvbiBmcm9tIGNvb2tpZXMgKFN1cGFiYXNlIHN0b3JlcyBzZXNzaW9uIGluIGNvb2tpZXMpXG4gIHRyeSB7XG4gICAgY29uc3QgY29va2llU3RvcmUgPSBhd2FpdCBjb29raWVzKCk7XG4gICAgY29uc3QgYWxsQ29va2llcyA9IGNvb2tpZVN0b3JlLmdldEFsbCgpO1xuICAgIFxuICAgIC8vIFRyeSB0byBleHRyYWN0IGFjY2VzcyB0b2tlbiBmcm9tIGNvb2tpZXMgZmlyc3RcbiAgICBjb25zdCBzdXBhYmFzZVVybE9iaiA9IG5ldyBVUkwoc3VwYWJhc2VVcmwpO1xuICAgIGNvbnN0IHByb2plY3RSZWYgPSBzdXBhYmFzZVVybE9iai5ob3N0bmFtZS5zcGxpdCgnLicpWzBdO1xuICAgIFxuICAgIC8vIExvb2sgZm9yIFN1cGFiYXNlIGF1dGggdG9rZW4gY29va2llXG4gICAgLy8gVHJ5IHNiLWFwaS1hdXRoLXRva2VuIGZpcnN0IGFzIGl0J3MgdGhlIG1vc3QgY29tbW9uXG4gICAgY29uc3QgYXV0aENvb2tpZU5hbWVzID0gW1xuICAgICAgYHNiLWFwaS1hdXRoLXRva2VuYCxcbiAgICAgIGBzYi0ke3Byb2plY3RSZWZ9LWF1dGgtdG9rZW5gLFxuICAgIF07XG4gICAgXG4gICAgbGV0IGFjY2Vzc1Rva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCBjb29raWVOYW1lIG9mIGF1dGhDb29raWVOYW1lcykge1xuICAgICAgY29uc3QgY29va2llID0gY29va2llU3RvcmUuZ2V0KGNvb2tpZU5hbWUpO1xuICAgICAgaWYgKGNvb2tpZT8udmFsdWUpIHtcbiAgICAgICAgLy8gTG9nIGZpcnN0IDEwMCBjaGFycyB0byBzZWUgZm9ybWF0ICh3aXRob3V0IGV4cG9zaW5nIGZ1bGwgdG9rZW4pXG4gICAgICAgIGNvbnN0IHByZXZpZXcgPSBjb29raWUudmFsdWUuc3Vic3RyaW5nKDAsIDEwMCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbY3JlYXRlU2VydmVyQ2xpZW50XSBDaGVja2luZyBjb29raWU6ICR7Y29va2llTmFtZX0sIGxlbmd0aDogJHtjb29raWUudmFsdWUubGVuZ3RofSwgcHJldmlldzogJHtwcmV2aWV3fS4uLmApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRyeSBVUkwgZGVjb2RpbmcgZmlyc3RcbiAgICAgICAgICBsZXQgZGVjb2RlZFZhbHVlID0gY29va2llLnZhbHVlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWNvZGVkVmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoY29va2llLnZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIC8vIE5vdCBVUkwgZW5jb2RlZFxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgcGFyc2luZyBhcyBKU09OXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBKU09OLnBhcnNlKGRlY29kZWRWYWx1ZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NyZWF0ZVNlcnZlckNsaWVudF0gUGFyc2VkICR7Y29va2llTmFtZX0gYXMgSlNPTiwgdHlwZTpgLCBBcnJheS5pc0FycmF5KHNlc3Npb24pID8gJ2FycmF5JyA6IHR5cGVvZiBzZXNzaW9uLCAna2V5czonLCBPYmplY3Qua2V5cyhzZXNzaW9uIHx8IHt9KSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gYXJyYXkgKFN1cGFiYXNlIHNvbWV0aW1lcyBzdG9yZXMgdG9rZW5zIGFzIGFycmF5KVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2Vzc2lvbikgJiYgc2Vzc2lvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbY3JlYXRlU2VydmVyQ2xpZW50XSBBcnJheSBoYXMgJHtzZXNzaW9uLmxlbmd0aH0gZWxlbWVudHMsIGNoZWNraW5nIGVhY2guLi5gKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFRyeSBlYWNoIGVsZW1lbnQgdG8gZmluZCBhIHZhbGlkIEpXVFxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gc2Vzc2lvbltpXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW55IHF1b3RlcyBvciBleHRyYSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICBsZXQgY2xlYW5Ub2tlbiA9IGVsZW1lbnQudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgaWYgKChjbGVhblRva2VuLnN0YXJ0c1dpdGgoJ1wiJykgJiYgY2xlYW5Ub2tlbi5lbmRzV2l0aCgnXCInKSkgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgKGNsZWFuVG9rZW4uc3RhcnRzV2l0aChcIidcIikgJiYgY2xlYW5Ub2tlbi5lbmRzV2l0aChcIidcIikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuVG9rZW4gPSBjbGVhblRva2VuLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgbG9va3MgbGlrZSBhIEpXVCAoaGFzIDMgcGFydHMgc2VwYXJhdGVkIGJ5IGRvdHMpXG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGNsZWFuVG9rZW4uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDMgJiYgY2xlYW5Ub2tlbi5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtjcmVhdGVTZXJ2ZXJDbGllbnRdIEZvdW5kIHZhbGlkIEpXVCBzdHJ1Y3R1cmUgaW4gZWxlbWVudCAke2l9LCB1c2luZyBpdCBhcyBhY2Nlc3MgdG9rZW5gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoaXMgdG9rZW4gLSBldmVuIGlmIHNpZ25hdHVyZSB2YWxpZGF0aW9uIGZhaWxzIGxhdGVyLCBcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwYWJhc2UgbWlnaHQgc3RpbGwgYWNjZXB0IGl0IGZvciBSTFMgaWYgdGhlIHBheWxvYWQgaXMgdmFsaWRcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBjbGVhblRva2VuO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gSWYgZWxlbWVudCBpcyBhbiBvYmplY3QsIGNoZWNrIGZvciBhY2Nlc3NfdG9rZW5cbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudC5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbY3JlYXRlU2VydmVyQ2xpZW50XSBGb3VuZCBhY2Nlc3NfdG9rZW4gaW4gZWxlbWVudCAke2l9OiAke2Nvb2tpZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbiA9IGVsZW1lbnQuYWNjZXNzX3Rva2VuO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gSWYgbm8gc2luZ2xlIGVsZW1lbnQgd29ya3MsIHRyeSBqb2luaW5nIGFsbCBzdHJpbmcgZWxlbWVudHNcbiAgICAgICAgICAgICAgY29uc3QgYWxsU3RyaW5ncyA9IHNlc3Npb24uZmlsdGVyKGUgPT4gdHlwZW9mIGUgPT09ICdzdHJpbmcnKTtcbiAgICAgICAgICAgICAgaWYgKGFsbFN0cmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGpvaW5lZCA9IGFsbFN0cmluZ3Muam9pbignJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBqb2luZWQuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAzICYmIGpvaW5lZC5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbY3JlYXRlU2VydmVyQ2xpZW50XSBGb3VuZCBKV1QgYnkgam9pbmluZyBhcnJheSBlbGVtZW50cycpO1xuICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBqb2luZWQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHNlc3Npb24/LmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NyZWF0ZVNlcnZlckNsaWVudF0gRm91bmQgYWNjZXNzX3Rva2VuIGluICR7Y29va2llTmFtZX1gKTtcbiAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBzZXNzaW9uLmFjY2Vzc190b2tlbjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBuZXN0ZWQgc2Vzc2lvbiBvYmplY3RcbiAgICAgICAgICAgIGlmIChzZXNzaW9uPy5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtjcmVhdGVTZXJ2ZXJDbGllbnRdIEZvdW5kIGFjY2Vzc190b2tlbiBpbiBuZXN0ZWQgc2Vzc2lvbjogJHtjb29raWVOYW1lfWApO1xuICAgICAgICAgICAgICBhY2Nlc3NUb2tlbiA9IHNlc3Npb24uc2Vzc2lvbi5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIE5vdCBKU09OLCBtaWdodCBiZSBkaXJlY3QgSldUIHRva2VuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NyZWF0ZVNlcnZlckNsaWVudF0gJHtjb29raWVOYW1lfSBpcyBub3QgSlNPTiwgY2hlY2tpbmcgaWYgSldUYCk7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZFZhbHVlLmxlbmd0aCA+IDEwMCAmJiBkZWNvZGVkVmFsdWUuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NyZWF0ZVNlcnZlckNsaWVudF0gVXNpbmcgJHtjb29raWVOYW1lfSBhcyBkaXJlY3QgSldUIHRva2VuYCk7XG4gICAgICAgICAgICAgIGFjY2Vzc1Rva2VuID0gZGVjb2RlZFZhbHVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgW2NyZWF0ZVNlcnZlckNsaWVudF0gRXJyb3IgcHJvY2Vzc2luZyAke2Nvb2tpZU5hbWV9OmAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSBmb3VuZCBhbiBhY2Nlc3MgdG9rZW4sIHVzZSBpdCBkaXJlY3RseVxuICAgIGlmIChhY2Nlc3NUb2tlbiAmJiBzdXBhYmFzZUFub25LZXkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgICBnbG9iYWw6IHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgcGVyc2lzdFNlc3Npb246IGZhbHNlLFxuICAgICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrOiBCdWlsZCBjb29raWUgaGVhZGVyIGZvciBTdXBhYmFzZSB0byByZWFkXG4gICAgY29uc3QgY29va2llSGVhZGVyID0gYWxsQ29va2llcy5tYXAoYyA9PiBgJHtjLm5hbWV9PSR7Yy52YWx1ZX1gKS5qb2luKCc7ICcpO1xuICAgIFxuICAgIGlmIChjb29raWVIZWFkZXIgJiYgc3VwYWJhc2VBbm9uS2V5KSB7XG4gICAgICAvLyBDcmVhdGUgY2xpZW50IHdpdGggY29va2llcyAtIFN1cGFiYXNlIHdpbGwgZXh0cmFjdCBzZXNzaW9uIGZyb20gY29va2llc1xuICAgICAgcmV0dXJuIGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5LCB7XG4gICAgICAgIGdsb2JhbDoge1xuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIENvb2tpZTogY29va2llSGVhZGVyLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsIC8vIFdlJ3JlIGhhbmRsaW5nIGNvb2tpZXMgbWFudWFsbHlcbiAgICAgICAgICBhdXRvUmVmcmVzaFRva2VuOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWFkaW5nIGNvb2tpZXMgaW4gY3JlYXRlU2VydmVyQ2xpZW50OicsIGVycm9yKTtcbiAgICAvLyBOb3QgaW4gYSBjb29raWVzIGNvbnRleHQsIGNvbnRpbnVlXG4gIH1cblxuICAvLyBGb3IgcHVibGljIHJvdXRlcyBvciBiYWNrZ3JvdW5kIGpvYnMsIHVzZSBzZXJ2aWNlIHJvbGUga2V5XG4gIC8vIFdBUk5JTkc6IFRoaXMgYnlwYXNzZXMgUkxTIC0gb25seSB1c2Ugd2hlbiBuZWNlc3NhcnlcbiAgaWYgKHN1cGFiYXNlU2VydmljZUtleSkge1xuICAgIHJldHVybiBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlU2VydmljZUtleSwge1xuICAgICAgYXV0aDoge1xuICAgICAgICBhdXRvUmVmcmVzaFRva2VuOiBmYWxzZSxcbiAgICAgICAgcGVyc2lzdFNlc3Npb246IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEZhbGxiYWNrIHRvIGFub24ga2V5IChmb3IgcHVibGljIHJlYWQgb3BlcmF0aW9ucylcbiAgcmV0dXJuIGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5ISk7XG59XG5cbi8qKlxuICogR2V0IFN1cGFiYXNlIGNsaWVudCB3aXRoIHNlcnZpY2Ugcm9sZSAoYnlwYXNzZXMgUkxTKVxuICogXG4gKiBVc2UgdGhpcyBPTkxZIGZvcjpcbiAqIC0gQmFja2dyb3VuZCBqb2JzXG4gKiAtIFdlYmhvb2sgaGFuZGxlcnNcbiAqIC0gQWRtaW4gb3BlcmF0aW9ucyB0aGF0IG5lZWQgdG8gYnlwYXNzIFJMU1xuICogXG4gKiBVc2FnZTpcbiAqIGBgYHRzXG4gKiBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUFkbWluQ2xpZW50KCk7XG4gKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2J1c2luZXNzZXMnKS5zZWxlY3QoJyonKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWRtaW5DbGllbnQoKTogU3VwYWJhc2VDbGllbnQge1xuICBjb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTDtcbiAgY29uc3Qgc3VwYWJhc2VTZXJ2aWNlS2V5ID0gcHJvY2Vzcy5lbnYuU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWTtcblxuICBpZiAoIXN1cGFiYXNlVXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIE5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCBlbnZpcm9ubWVudCB2YXJpYWJsZScpO1xuICB9XG5cbiAgaWYgKCFzdXBhYmFzZVNlcnZpY2VLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZScpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VTZXJ2aWNlS2V5LCB7XG4gICAgYXV0aDoge1xuICAgICAgYXV0b1JlZnJlc2hUb2tlbjogZmFsc2UsXG4gICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsXG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IFN1cGFiYXNlIGNsaWVudCBmb3IgY2xpZW50LXNpZGUgb3BlcmF0aW9uc1xuICogXG4gKiBUaGlzIHNob3VsZCBiZSB1c2VkIGluIFJlYWN0IGNvbXBvbmVudHMgb3IgY2xpZW50LXNpZGUgY29kZS5cbiAqIEl0IHVzZXMgdGhlIGFub24ga2V5IGFuZCByZWxpZXMgb24gU3VwYWJhc2UgQXV0aCBmb3IgYXV0aGVudGljYXRpb24uXG4gKiBcbiAqIFVzYWdlIGluIGNsaWVudCBjb21wb25lbnRzOlxuICogYGBgdHNcbiAqICd1c2UgY2xpZW50JztcbiAqIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50Q2xpZW50KCk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNsaWVudENsaWVudCgpOiBTdXBhYmFzZUNsaWVudCB7XG4gIGNvbnN0IHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMO1xuICBjb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWTtcblxuICBpZiAoIXN1cGFiYXNlVXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIE5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCBlbnZpcm9ubWVudCB2YXJpYWJsZScpO1xuICB9XG5cbiAgaWYgKCFzdXBhYmFzZUFub25LZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGUnKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSk7XG59XG5cbiJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJjb29raWVzIiwiaGVhZGVycyIsImNyZWF0ZVNlcnZlckNsaWVudCIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlQW5vbktleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwic3VwYWJhc2VTZXJ2aWNlS2V5IiwiU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSIsIkVycm9yIiwiYWNjZXNzVG9rZW4iLCJoZWFkZXJzTGlzdCIsImF1dGhIZWFkZXIiLCJnZXQiLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwiZ2xvYmFsIiwiQXV0aG9yaXphdGlvbiIsImNvb2tpZVN0b3JlIiwiYWxsQ29va2llcyIsImdldEFsbCIsInN1cGFiYXNlVXJsT2JqIiwiVVJMIiwicHJvamVjdFJlZiIsImhvc3RuYW1lIiwic3BsaXQiLCJhdXRoQ29va2llTmFtZXMiLCJjb29raWVOYW1lIiwiY29va2llIiwidmFsdWUiLCJwcmV2aWV3IiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsImRlY29kZWRWYWx1ZSIsImRlY29kZVVSSUNvbXBvbmVudCIsInNlc3Npb24iLCJKU09OIiwicGFyc2UiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJrZXlzIiwiaSIsImVsZW1lbnQiLCJjbGVhblRva2VuIiwidHJpbSIsImVuZHNXaXRoIiwic2xpY2UiLCJwYXJ0cyIsImFjY2Vzc190b2tlbiIsImFsbFN0cmluZ3MiLCJmaWx0ZXIiLCJlIiwiam9pbmVkIiwiam9pbiIsInBhcnNlRXJyb3IiLCJpbmNsdWRlcyIsImVycm9yIiwiYXV0aCIsInBlcnNpc3RTZXNzaW9uIiwiYXV0b1JlZnJlc2hUb2tlbiIsImNvb2tpZUhlYWRlciIsIm1hcCIsImMiLCJuYW1lIiwiQ29va2llIiwiY3JlYXRlQWRtaW5DbGllbnQiLCJjcmVhdGVDbGllbnRDbGllbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/db.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/stripe.ts":
/*!***************************!*\
  !*** ./src/lib/stripe.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAccountLink: () => (/* binding */ createAccountLink),\n/* harmony export */   createConnectAccount: () => (/* binding */ createConnectAccount),\n/* harmony export */   createOrGetCustomer: () => (/* binding */ createOrGetCustomer),\n/* harmony export */   createPaymentIntent: () => (/* binding */ createPaymentIntent),\n/* harmony export */   createRefund: () => (/* binding */ createRefund),\n/* harmony export */   createSetupIntent: () => (/* binding */ createSetupIntent),\n/* harmony export */   createSubscription: () => (/* binding */ createSubscription),\n/* harmony export */   getPaymentMethodFromSetupIntent: () => (/* binding */ getPaymentMethodFromSetupIntent),\n/* harmony export */   getStripeClient: () => (/* binding */ getStripeClient),\n/* harmony export */   verifyConnectAccount: () => (/* binding */ verifyConnectAccount)\n/* harmony export */ });\n/* harmony import */ var stripe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stripe */ \"(rsc)/../../node_modules/stripe/esm/stripe.esm.node.js\");\n\nconst stripeSecretKey = process.env.STRIPE_SECRET_KEY;\nif (!stripeSecretKey) {\n    console.warn(\"STRIPE_SECRET_KEY not set - Stripe features will not work\");\n}\n/**\n * Get Stripe client instance\n */ function getStripeClient() {\n    if (!stripeSecretKey) {\n        throw new Error(\"STRIPE_SECRET_KEY environment variable is not set\");\n    }\n    return new stripe__WEBPACK_IMPORTED_MODULE_0__[\"default\"](stripeSecretKey, {\n        apiVersion: \"2024-11-20.acacia\"\n    });\n}\n/**\n * Create a Stripe Connect Express account\n * Returns the account ID\n */ async function createConnectAccount(userId, email) {\n    const stripe = getStripeClient();\n    const account = await stripe.accounts.create({\n        type: \"express\",\n        email,\n        capabilities: {\n            card_payments: {\n                requested: true\n            },\n            transfers: {\n                requested: true\n            }\n        },\n        metadata: {\n            user_id: userId\n        }\n    });\n    return account.id;\n}\n/**\n * Create an Account Link for Stripe Connect onboarding\n * Returns the URL to redirect the user to\n */ async function createAccountLink(accountId, returnUrl, refreshUrl) {\n    const stripe = getStripeClient();\n    const accountLink = await stripe.accountLinks.create({\n        account: accountId,\n        type: \"account_onboarding\",\n        return_url: returnUrl,\n        refresh_url: refreshUrl\n    });\n    return accountLink.url;\n}\n/**\n * Create or retrieve a Stripe Customer\n */ async function createOrGetCustomer(email, name, metadata) {\n    const stripe = getStripeClient();\n    // Search for existing customer by email\n    const existingCustomers = await stripe.customers.list({\n        email,\n        limit: 1\n    });\n    if (existingCustomers.data.length > 0) {\n        return existingCustomers.data[0].id;\n    }\n    // Create new customer\n    const customer = await stripe.customers.create({\n        email,\n        name,\n        metadata: metadata || {}\n    });\n    return customer.id;\n}\n/**\n * Create a SetupIntent to save a card without charging\n */ async function createSetupIntent(customerId, metadata) {\n    const stripe = getStripeClient();\n    const setupIntent = await stripe.setupIntents.create({\n        customer: customerId,\n        payment_method_types: [\n            \"card\"\n        ],\n        metadata: metadata || {}\n    });\n    return {\n        setupIntentId: setupIntent.id,\n        clientSecret: setupIntent.client_secret\n    };\n}\n/**\n * Create a subscription for the business owner ($11.99/mo)\n * Includes 7-day trial period as per app design\n */ async function createSubscription(customerId, priceId, metadata, paymentMethodId // Optional: if owner already has payment method ready\n) {\n    const stripe = getStripeClient();\n    const subscriptionParams = {\n        customer: customerId,\n        items: [\n            {\n                price: priceId\n            }\n        ],\n        payment_settings: {\n            save_default_payment_method: \"on_subscription\"\n        },\n        expand: [\n            \"latest_invoice.payment_intent\"\n        ],\n        metadata: metadata || {},\n        // 7-day trial period as per app design\n        trial_period_days: 7\n    };\n    // If payment method is provided, attach it; otherwise subscription will be incomplete\n    if (paymentMethodId) {\n        subscriptionParams.default_payment_method = paymentMethodId;\n        subscriptionParams.payment_behavior = \"default_incomplete\";\n    } else {\n        // Subscription will be incomplete until payment method is added\n        subscriptionParams.payment_behavior = \"default_incomplete\";\n    }\n    const subscription = await stripe.subscriptions.create(subscriptionParams);\n    return {\n        subscriptionId: subscription.id,\n        status: subscription.status,\n        current_period_end: subscription.current_period_end,\n        trial_end: subscription.trial_end\n    };\n}\n/**\n * Create a PaymentIntent with Connect destination charge\n * This charges the customer and sends funds to the connected account\n * Supports off-session charges for saved payment methods\n * \n * Returns the PaymentIntent with status information\n */ async function createPaymentIntent(params) {\n    const stripe = getStripeClient();\n    const { amount, customerId, paymentMethodId, connectAccountId, applicationFee, metadata, offSession = false } = params;\n    // Create PaymentIntent on platform account with Connect destination\n    const paymentIntentParams = {\n        amount,\n        currency: \"usd\",\n        customer: customerId,\n        payment_method: paymentMethodId,\n        on_behalf_of: connectAccountId,\n        transfer_data: {\n            destination: connectAccountId\n        },\n        application_fee_amount: applicationFee,\n        metadata: metadata || {}\n    };\n    // For off-session charges, set confirmation method and off_session flag\n    if (offSession) {\n        paymentIntentParams.confirmation_method = \"automatic\";\n        paymentIntentParams.confirm = true;\n        paymentIntentParams.off_session = true;\n        paymentIntentParams.payment_method_options = {\n            card: {\n                request_three_d_secure: \"automatic\"\n            }\n        };\n    } else {\n        paymentIntentParams.confirmation_method = \"manual\";\n        paymentIntentParams.confirm = true;\n    }\n    const paymentIntent = await stripe.paymentIntents.create(paymentIntentParams);\n    return {\n        paymentIntentId: paymentIntent.id,\n        clientSecret: paymentIntent.client_secret || \"\",\n        status: paymentIntent.status,\n        requiresAction: paymentIntent.status === \"requires_action\" || paymentIntent.status === \"requires_payment_method\"\n    };\n}\n/**\n * Create a refund for a PaymentIntent\n */ async function createRefund(paymentIntentId, amount // optional amount to refund (partial refund), if not provided, full refund\n) {\n    const stripe = getStripeClient();\n    const refundParams = {\n        payment_intent: paymentIntentId\n    };\n    if (amount !== undefined) {\n        refundParams.amount = amount;\n    }\n    const refund = await stripe.refunds.create(refundParams);\n    return {\n        refundId: refund.id,\n        amount: refund.amount\n    };\n}\n/**\n * Get payment method from a SetupIntent\n */ async function getPaymentMethodFromSetupIntent(setupIntentId) {\n    const stripe = getStripeClient();\n    const setupIntent = await stripe.setupIntents.retrieve(setupIntentId);\n    if (typeof setupIntent.payment_method === \"string\") {\n        return setupIntent.payment_method;\n    }\n    if (setupIntent.payment_method) {\n        return setupIntent.payment_method.id;\n    }\n    return null;\n}\n/**\n * Verify a Connect account is active\n */ async function verifyConnectAccount(accountId) {\n    try {\n        const stripe = getStripeClient();\n        const account = await stripe.accounts.retrieve(accountId);\n        return account.details_submitted && account.charges_enabled;\n    } catch (error) {\n        console.error(\"Error verifying Connect account:\", error);\n        return false;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RCxFQUFFLE9BQU9DLE9BQU87UUFDZG5HLFFBQVFtRyxLQUFLLENBQUMsb0NBQW9DQTtRQUNsRCxPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL3NyYy9saWIvc3RyaXBlLnRzPzc5OGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFN0cmlwZSBmcm9tICdzdHJpcGUnO1xuXG5jb25zdCBzdHJpcGVTZWNyZXRLZXkgPSBwcm9jZXNzLmVudi5TVFJJUEVfU0VDUkVUX0tFWTtcblxuaWYgKCFzdHJpcGVTZWNyZXRLZXkpIHtcbiAgY29uc29sZS53YXJuKCdTVFJJUEVfU0VDUkVUX0tFWSBub3Qgc2V0IC0gU3RyaXBlIGZlYXR1cmVzIHdpbGwgbm90IHdvcmsnKTtcbn1cblxuLyoqXG4gKiBHZXQgU3RyaXBlIGNsaWVudCBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RyaXBlQ2xpZW50KCk6IFN0cmlwZSB7XG4gIGlmICghc3RyaXBlU2VjcmV0S2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTVFJJUEVfU0VDUkVUX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3Qgc2V0Jyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBTdHJpcGUoc3RyaXBlU2VjcmV0S2V5LCB7XG4gICAgYXBpVmVyc2lvbjogJzIwMjQtMTEtMjAuYWNhY2lhJyxcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgU3RyaXBlIENvbm5lY3QgRXhwcmVzcyBhY2NvdW50XG4gKiBSZXR1cm5zIHRoZSBhY2NvdW50IElEXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb25uZWN0QWNjb3VudCh1c2VySWQ6IHN0cmluZywgZW1haWw6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IHN0cmlwZSA9IGdldFN0cmlwZUNsaWVudCgpO1xuXG4gIGNvbnN0IGFjY291bnQgPSBhd2FpdCBzdHJpcGUuYWNjb3VudHMuY3JlYXRlKHtcbiAgICB0eXBlOiAnZXhwcmVzcycsXG4gICAgZW1haWwsXG4gICAgY2FwYWJpbGl0aWVzOiB7XG4gICAgICBjYXJkX3BheW1lbnRzOiB7IHJlcXVlc3RlZDogdHJ1ZSB9LFxuICAgICAgdHJhbnNmZXJzOiB7IHJlcXVlc3RlZDogdHJ1ZSB9LFxuICAgIH0sXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICB9LFxuICB9KTtcblxuICByZXR1cm4gYWNjb3VudC5pZDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gQWNjb3VudCBMaW5rIGZvciBTdHJpcGUgQ29ubmVjdCBvbmJvYXJkaW5nXG4gKiBSZXR1cm5zIHRoZSBVUkwgdG8gcmVkaXJlY3QgdGhlIHVzZXIgdG9cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUFjY291bnRMaW5rKFxuICBhY2NvdW50SWQ6IHN0cmluZyxcbiAgcmV0dXJuVXJsOiBzdHJpbmcsXG4gIHJlZnJlc2hVcmw6IHN0cmluZ1xuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3Qgc3RyaXBlID0gZ2V0U3RyaXBlQ2xpZW50KCk7XG5cbiAgY29uc3QgYWNjb3VudExpbmsgPSBhd2FpdCBzdHJpcGUuYWNjb3VudExpbmtzLmNyZWF0ZSh7XG4gICAgYWNjb3VudDogYWNjb3VudElkLFxuICAgIHR5cGU6ICdhY2NvdW50X29uYm9hcmRpbmcnLFxuICAgIHJldHVybl91cmw6IHJldHVyblVybCxcbiAgICByZWZyZXNoX3VybDogcmVmcmVzaFVybCxcbiAgfSk7XG5cbiAgcmV0dXJuIGFjY291bnRMaW5rLnVybDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgb3IgcmV0cmlldmUgYSBTdHJpcGUgQ3VzdG9tZXJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU9yR2V0Q3VzdG9tZXIoXG4gIGVtYWlsOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBzdHJpcGUgPSBnZXRTdHJpcGVDbGllbnQoKTtcblxuICAvLyBTZWFyY2ggZm9yIGV4aXN0aW5nIGN1c3RvbWVyIGJ5IGVtYWlsXG4gIGNvbnN0IGV4aXN0aW5nQ3VzdG9tZXJzID0gYXdhaXQgc3RyaXBlLmN1c3RvbWVycy5saXN0KHtcbiAgICBlbWFpbCxcbiAgICBsaW1pdDogMSxcbiAgfSk7XG5cbiAgaWYgKGV4aXN0aW5nQ3VzdG9tZXJzLmRhdGEubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBleGlzdGluZ0N1c3RvbWVycy5kYXRhWzBdLmlkO1xuICB9XG5cbiAgLy8gQ3JlYXRlIG5ldyBjdXN0b21lclxuICBjb25zdCBjdXN0b21lciA9IGF3YWl0IHN0cmlwZS5jdXN0b21lcnMuY3JlYXRlKHtcbiAgICBlbWFpbCxcbiAgICBuYW1lLFxuICAgIG1ldGFkYXRhOiBtZXRhZGF0YSB8fCB7fSxcbiAgfSk7XG5cbiAgcmV0dXJuIGN1c3RvbWVyLmlkO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIFNldHVwSW50ZW50IHRvIHNhdmUgYSBjYXJkIHdpdGhvdXQgY2hhcmdpbmdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNldHVwSW50ZW50KFxuICBjdXN0b21lcklkOiBzdHJpbmcsXG4gIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuKTogUHJvbWlzZTx7IHNldHVwSW50ZW50SWQ6IHN0cmluZzsgY2xpZW50U2VjcmV0OiBzdHJpbmcgfT4ge1xuICBjb25zdCBzdHJpcGUgPSBnZXRTdHJpcGVDbGllbnQoKTtcblxuICBjb25zdCBzZXR1cEludGVudCA9IGF3YWl0IHN0cmlwZS5zZXR1cEludGVudHMuY3JlYXRlKHtcbiAgICBjdXN0b21lcjogY3VzdG9tZXJJZCxcbiAgICBwYXltZW50X21ldGhvZF90eXBlczogWydjYXJkJ10sXG4gICAgbWV0YWRhdGE6IG1ldGFkYXRhIHx8IHt9LFxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHNldHVwSW50ZW50SWQ6IHNldHVwSW50ZW50LmlkLFxuICAgIGNsaWVudFNlY3JldDogc2V0dXBJbnRlbnQuY2xpZW50X3NlY3JldCEsXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc3Vic2NyaXB0aW9uIGZvciB0aGUgYnVzaW5lc3Mgb3duZXIgKCQxMS45OS9tbylcbiAqIEluY2x1ZGVzIDctZGF5IHRyaWFsIHBlcmlvZCBhcyBwZXIgYXBwIGRlc2lnblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlU3Vic2NyaXB0aW9uKFxuICBjdXN0b21lcklkOiBzdHJpbmcsXG4gIHByaWNlSWQ6IHN0cmluZyxcbiAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICBwYXltZW50TWV0aG9kSWQ/OiBzdHJpbmcgLy8gT3B0aW9uYWw6IGlmIG93bmVyIGFscmVhZHkgaGFzIHBheW1lbnQgbWV0aG9kIHJlYWR5XG4pOiBQcm9taXNlPHsgc3Vic2NyaXB0aW9uSWQ6IHN0cmluZzsgc3RhdHVzOiBzdHJpbmc7IGN1cnJlbnRfcGVyaW9kX2VuZD86IG51bWJlcjsgdHJpYWxfZW5kPzogbnVtYmVyIH0+IHtcbiAgY29uc3Qgc3RyaXBlID0gZ2V0U3RyaXBlQ2xpZW50KCk7XG5cbiAgY29uc3Qgc3Vic2NyaXB0aW9uUGFyYW1zOiBTdHJpcGUuU3Vic2NyaXB0aW9uQ3JlYXRlUGFyYW1zID0ge1xuICAgIGN1c3RvbWVyOiBjdXN0b21lcklkLFxuICAgIGl0ZW1zOiBbeyBwcmljZTogcHJpY2VJZCB9XSxcbiAgICBwYXltZW50X3NldHRpbmdzOiB7IHNhdmVfZGVmYXVsdF9wYXltZW50X21ldGhvZDogJ29uX3N1YnNjcmlwdGlvbicgfSxcbiAgICBleHBhbmQ6IFsnbGF0ZXN0X2ludm9pY2UucGF5bWVudF9pbnRlbnQnXSxcbiAgICBtZXRhZGF0YTogbWV0YWRhdGEgfHwge30sXG4gICAgLy8gNy1kYXkgdHJpYWwgcGVyaW9kIGFzIHBlciBhcHAgZGVzaWduXG4gICAgdHJpYWxfcGVyaW9kX2RheXM6IDcsXG4gIH07XG5cbiAgLy8gSWYgcGF5bWVudCBtZXRob2QgaXMgcHJvdmlkZWQsIGF0dGFjaCBpdDsgb3RoZXJ3aXNlIHN1YnNjcmlwdGlvbiB3aWxsIGJlIGluY29tcGxldGVcbiAgaWYgKHBheW1lbnRNZXRob2RJZCkge1xuICAgIHN1YnNjcmlwdGlvblBhcmFtcy5kZWZhdWx0X3BheW1lbnRfbWV0aG9kID0gcGF5bWVudE1ldGhvZElkO1xuICAgIHN1YnNjcmlwdGlvblBhcmFtcy5wYXltZW50X2JlaGF2aW9yID0gJ2RlZmF1bHRfaW5jb21wbGV0ZSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3Vic2NyaXB0aW9uIHdpbGwgYmUgaW5jb21wbGV0ZSB1bnRpbCBwYXltZW50IG1ldGhvZCBpcyBhZGRlZFxuICAgIHN1YnNjcmlwdGlvblBhcmFtcy5wYXltZW50X2JlaGF2aW9yID0gJ2RlZmF1bHRfaW5jb21wbGV0ZSc7XG4gIH1cblxuICBjb25zdCBzdWJzY3JpcHRpb24gPSBhd2FpdCBzdHJpcGUuc3Vic2NyaXB0aW9ucy5jcmVhdGUoc3Vic2NyaXB0aW9uUGFyYW1zKTtcblxuICByZXR1cm4ge1xuICAgIHN1YnNjcmlwdGlvbklkOiBzdWJzY3JpcHRpb24uaWQsXG4gICAgc3RhdHVzOiBzdWJzY3JpcHRpb24uc3RhdHVzLFxuICAgIGN1cnJlbnRfcGVyaW9kX2VuZDogc3Vic2NyaXB0aW9uLmN1cnJlbnRfcGVyaW9kX2VuZCxcbiAgICB0cmlhbF9lbmQ6IHN1YnNjcmlwdGlvbi50cmlhbF9lbmQsXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgUGF5bWVudEludGVudCB3aXRoIENvbm5lY3QgZGVzdGluYXRpb24gY2hhcmdlXG4gKiBUaGlzIGNoYXJnZXMgdGhlIGN1c3RvbWVyIGFuZCBzZW5kcyBmdW5kcyB0byB0aGUgY29ubmVjdGVkIGFjY291bnRcbiAqIFN1cHBvcnRzIG9mZi1zZXNzaW9uIGNoYXJnZXMgZm9yIHNhdmVkIHBheW1lbnQgbWV0aG9kc1xuICogXG4gKiBSZXR1cm5zIHRoZSBQYXltZW50SW50ZW50IHdpdGggc3RhdHVzIGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVQYXltZW50SW50ZW50KHBhcmFtczoge1xuICBhbW91bnQ6IG51bWJlcjsgLy8gaW4gY2VudHNcbiAgY3VzdG9tZXJJZDogc3RyaW5nO1xuICBwYXltZW50TWV0aG9kSWQ6IHN0cmluZztcbiAgY29ubmVjdEFjY291bnRJZDogc3RyaW5nO1xuICBhcHBsaWNhdGlvbkZlZTogbnVtYmVyOyAvLyBwbGF0Zm9ybSBmZWUgaW4gY2VudHMgKDElIG9mIGFtb3VudClcbiAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICBvZmZTZXNzaW9uPzogYm9vbGVhbjsgLy8gSWYgdHJ1ZSwgYXR0ZW1wdHMgb2ZmLXNlc3Npb24gY2hhcmdlIChmb3Igc2F2ZWQgY2FyZHMpXG59KTogUHJvbWlzZTx7IFxuICBwYXltZW50SW50ZW50SWQ6IHN0cmluZzsgXG4gIGNsaWVudFNlY3JldDogc3RyaW5nO1xuICBzdGF0dXM6IHN0cmluZztcbiAgcmVxdWlyZXNBY3Rpb24/OiBib29sZWFuO1xufT4ge1xuICBjb25zdCBzdHJpcGUgPSBnZXRTdHJpcGVDbGllbnQoKTtcbiAgY29uc3QgeyBhbW91bnQsIGN1c3RvbWVySWQsIHBheW1lbnRNZXRob2RJZCwgY29ubmVjdEFjY291bnRJZCwgYXBwbGljYXRpb25GZWUsIG1ldGFkYXRhLCBvZmZTZXNzaW9uID0gZmFsc2UgfSA9IHBhcmFtcztcblxuICAvLyBDcmVhdGUgUGF5bWVudEludGVudCBvbiBwbGF0Zm9ybSBhY2NvdW50IHdpdGggQ29ubmVjdCBkZXN0aW5hdGlvblxuICBjb25zdCBwYXltZW50SW50ZW50UGFyYW1zOiBTdHJpcGUuUGF5bWVudEludGVudENyZWF0ZVBhcmFtcyA9IHtcbiAgICBhbW91bnQsXG4gICAgY3VycmVuY3k6ICd1c2QnLFxuICAgIGN1c3RvbWVyOiBjdXN0b21lcklkLFxuICAgIHBheW1lbnRfbWV0aG9kOiBwYXltZW50TWV0aG9kSWQsXG4gICAgb25fYmVoYWxmX29mOiBjb25uZWN0QWNjb3VudElkLFxuICAgIHRyYW5zZmVyX2RhdGE6IHtcbiAgICAgIGRlc3RpbmF0aW9uOiBjb25uZWN0QWNjb3VudElkLFxuICAgIH0sXG4gICAgYXBwbGljYXRpb25fZmVlX2Ftb3VudDogYXBwbGljYXRpb25GZWUsXG4gICAgbWV0YWRhdGE6IG1ldGFkYXRhIHx8IHt9LFxuICB9O1xuXG4gIC8vIEZvciBvZmYtc2Vzc2lvbiBjaGFyZ2VzLCBzZXQgY29uZmlybWF0aW9uIG1ldGhvZCBhbmQgb2ZmX3Nlc3Npb24gZmxhZ1xuICBpZiAob2ZmU2Vzc2lvbikge1xuICAgIHBheW1lbnRJbnRlbnRQYXJhbXMuY29uZmlybWF0aW9uX21ldGhvZCA9ICdhdXRvbWF0aWMnO1xuICAgIHBheW1lbnRJbnRlbnRQYXJhbXMuY29uZmlybSA9IHRydWU7XG4gICAgcGF5bWVudEludGVudFBhcmFtcy5vZmZfc2Vzc2lvbiA9IHRydWU7XG4gICAgcGF5bWVudEludGVudFBhcmFtcy5wYXltZW50X21ldGhvZF9vcHRpb25zID0ge1xuICAgICAgY2FyZDoge1xuICAgICAgICByZXF1ZXN0X3RocmVlX2Rfc2VjdXJlOiAnYXV0b21hdGljJyxcbiAgICAgIH0sXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBwYXltZW50SW50ZW50UGFyYW1zLmNvbmZpcm1hdGlvbl9tZXRob2QgPSAnbWFudWFsJztcbiAgICBwYXltZW50SW50ZW50UGFyYW1zLmNvbmZpcm0gPSB0cnVlO1xuICB9XG5cbiAgY29uc3QgcGF5bWVudEludGVudCA9IGF3YWl0IHN0cmlwZS5wYXltZW50SW50ZW50cy5jcmVhdGUocGF5bWVudEludGVudFBhcmFtcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXltZW50SW50ZW50SWQ6IHBheW1lbnRJbnRlbnQuaWQsXG4gICAgY2xpZW50U2VjcmV0OiBwYXltZW50SW50ZW50LmNsaWVudF9zZWNyZXQgfHwgJycsXG4gICAgc3RhdHVzOiBwYXltZW50SW50ZW50LnN0YXR1cyxcbiAgICByZXF1aXJlc0FjdGlvbjogcGF5bWVudEludGVudC5zdGF0dXMgPT09ICdyZXF1aXJlc19hY3Rpb24nIHx8IHBheW1lbnRJbnRlbnQuc3RhdHVzID09PSAncmVxdWlyZXNfcGF5bWVudF9tZXRob2QnLFxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJlZnVuZCBmb3IgYSBQYXltZW50SW50ZW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVSZWZ1bmQoXG4gIHBheW1lbnRJbnRlbnRJZDogc3RyaW5nLFxuICBhbW91bnQ/OiBudW1iZXIgLy8gb3B0aW9uYWwgYW1vdW50IHRvIHJlZnVuZCAocGFydGlhbCByZWZ1bmQpLCBpZiBub3QgcHJvdmlkZWQsIGZ1bGwgcmVmdW5kXG4pOiBQcm9taXNlPHsgcmVmdW5kSWQ6IHN0cmluZzsgYW1vdW50OiBudW1iZXIgfT4ge1xuICBjb25zdCBzdHJpcGUgPSBnZXRTdHJpcGVDbGllbnQoKTtcblxuICBjb25zdCByZWZ1bmRQYXJhbXM6IFN0cmlwZS5SZWZ1bmRDcmVhdGVQYXJhbXMgPSB7XG4gICAgcGF5bWVudF9pbnRlbnQ6IHBheW1lbnRJbnRlbnRJZCxcbiAgfTtcblxuICBpZiAoYW1vdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZWZ1bmRQYXJhbXMuYW1vdW50ID0gYW1vdW50O1xuICB9XG5cbiAgY29uc3QgcmVmdW5kID0gYXdhaXQgc3RyaXBlLnJlZnVuZHMuY3JlYXRlKHJlZnVuZFBhcmFtcyk7XG5cbiAgcmV0dXJuIHtcbiAgICByZWZ1bmRJZDogcmVmdW5kLmlkLFxuICAgIGFtb3VudDogcmVmdW5kLmFtb3VudCxcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgcGF5bWVudCBtZXRob2QgZnJvbSBhIFNldHVwSW50ZW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQYXltZW50TWV0aG9kRnJvbVNldHVwSW50ZW50KFxuICBzZXR1cEludGVudElkOiBzdHJpbmdcbik6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICBjb25zdCBzdHJpcGUgPSBnZXRTdHJpcGVDbGllbnQoKTtcblxuICBjb25zdCBzZXR1cEludGVudCA9IGF3YWl0IHN0cmlwZS5zZXR1cEludGVudHMucmV0cmlldmUoc2V0dXBJbnRlbnRJZCk7XG5cbiAgaWYgKHR5cGVvZiBzZXR1cEludGVudC5wYXltZW50X21ldGhvZCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc2V0dXBJbnRlbnQucGF5bWVudF9tZXRob2Q7XG4gIH1cblxuICBpZiAoc2V0dXBJbnRlbnQucGF5bWVudF9tZXRob2QpIHtcbiAgICByZXR1cm4gc2V0dXBJbnRlbnQucGF5bWVudF9tZXRob2QuaWQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBWZXJpZnkgYSBDb25uZWN0IGFjY291bnQgaXMgYWN0aXZlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlDb25uZWN0QWNjb3VudChhY2NvdW50SWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHN0cmlwZSA9IGdldFN0cmlwZUNsaWVudCgpO1xuICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCBzdHJpcGUuYWNjb3VudHMucmV0cmlldmUoYWNjb3VudElkKTtcblxuICAgIHJldHVybiBhY2NvdW50LmRldGFpbHNfc3VibWl0dGVkICYmIGFjY291bnQuY2hhcmdlc19lbmFibGVkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyBDb25uZWN0IGFjY291bnQ6JywgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4iXSwibmFtZXMiOlsiU3RyaXBlIiwic3RyaXBlU2VjcmV0S2V5IiwicHJvY2VzcyIsImVudiIsIlNUUklQRV9TRUNSRVRfS0VZIiwiY29uc29sZSIsIndhcm4iLCJnZXRTdHJpcGVDbGllbnQiLCJFcnJvciIsImFwaVZlcnNpb24iLCJjcmVhdGVDb25uZWN0QWNjb3VudCIsInVzZXJJZCIsImVtYWlsIiwic3RyaXBlIiwiYWNjb3VudCIsImFjY291bnRzIiwiY3JlYXRlIiwidHlwZSIsImNhcGFiaWxpdGllcyIsImNhcmRfcGF5bWVudHMiLCJyZXF1ZXN0ZWQiLCJ0cmFuc2ZlcnMiLCJtZXRhZGF0YSIsInVzZXJfaWQiLCJpZCIsImNyZWF0ZUFjY291bnRMaW5rIiwiYWNjb3VudElkIiwicmV0dXJuVXJsIiwicmVmcmVzaFVybCIsImFjY291bnRMaW5rIiwiYWNjb3VudExpbmtzIiwicmV0dXJuX3VybCIsInJlZnJlc2hfdXJsIiwidXJsIiwiY3JlYXRlT3JHZXRDdXN0b21lciIsIm5hbWUiLCJleGlzdGluZ0N1c3RvbWVycyIsImN1c3RvbWVycyIsImxpc3QiLCJsaW1pdCIsImRhdGEiLCJsZW5ndGgiLCJjdXN0b21lciIsImNyZWF0ZVNldHVwSW50ZW50IiwiY3VzdG9tZXJJZCIsInNldHVwSW50ZW50Iiwic2V0dXBJbnRlbnRzIiwicGF5bWVudF9tZXRob2RfdHlwZXMiLCJzZXR1cEludGVudElkIiwiY2xpZW50U2VjcmV0IiwiY2xpZW50X3NlY3JldCIsImNyZWF0ZVN1YnNjcmlwdGlvbiIsInByaWNlSWQiLCJwYXltZW50TWV0aG9kSWQiLCJzdWJzY3JpcHRpb25QYXJhbXMiLCJpdGVtcyIsInByaWNlIiwicGF5bWVudF9zZXR0aW5ncyIsInNhdmVfZGVmYXVsdF9wYXltZW50X21ldGhvZCIsImV4cGFuZCIsInRyaWFsX3BlcmlvZF9kYXlzIiwiZGVmYXVsdF9wYXltZW50X21ldGhvZCIsInBheW1lbnRfYmVoYXZpb3IiLCJzdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb25zIiwic3Vic2NyaXB0aW9uSWQiLCJzdGF0dXMiLCJjdXJyZW50X3BlcmlvZF9lbmQiLCJ0cmlhbF9lbmQiLCJjcmVhdGVQYXltZW50SW50ZW50IiwicGFyYW1zIiwiYW1vdW50IiwiY29ubmVjdEFjY291bnRJZCIsImFwcGxpY2F0aW9uRmVlIiwib2ZmU2Vzc2lvbiIsInBheW1lbnRJbnRlbnRQYXJhbXMiLCJjdXJyZW5jeSIsInBheW1lbnRfbWV0aG9kIiwib25fYmVoYWxmX29mIiwidHJhbnNmZXJfZGF0YSIsImRlc3RpbmF0aW9uIiwiYXBwbGljYXRpb25fZmVlX2Ftb3VudCIsImNvbmZpcm1hdGlvbl9tZXRob2QiLCJjb25maXJtIiwib2ZmX3Nlc3Npb24iLCJwYXltZW50X21ldGhvZF9vcHRpb25zIiwiY2FyZCIsInJlcXVlc3RfdGhyZWVfZF9zZWN1cmUiLCJwYXltZW50SW50ZW50IiwicGF5bWVudEludGVudHMiLCJwYXltZW50SW50ZW50SWQiLCJyZXF1aXJlc0FjdGlvbiIsImNyZWF0ZVJlZnVuZCIsInJlZnVuZFBhcmFtcyIsInBheW1lbnRfaW50ZW50IiwidW5kZWZpbmVkIiwicmVmdW5kIiwicmVmdW5kcyIsInJlZnVuZElkIiwiZ2V0UGF5bWVudE1ldGhvZEZyb21TZXR1cEludGVudCIsInJldHJpZXZlIiwidmVyaWZ5Q29ubmVjdEFjY291bnQiLCJkZXRhaWxzX3N1Ym1pdHRlZCIsImNoYXJnZXNfZW5hYmxlZCIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/stripe.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@supabase","vendor-chunks/tslib","vendor-chunks/stripe","vendor-chunks/math-intrinsics","vendor-chunks/es-errors","vendor-chunks/qs","vendor-chunks/call-bind-apply-helpers","vendor-chunks/get-proto","vendor-chunks/object-inspect","vendor-chunks/has-symbols","vendor-chunks/gopd","vendor-chunks/function-bind","vendor-chunks/side-channel","vendor-chunks/side-channel-weakmap","vendor-chunks/side-channel-map","vendor-chunks/side-channel-list","vendor-chunks/hasown","vendor-chunks/get-intrinsic","vendor-chunks/es-object-atoms","vendor-chunks/es-define-property","vendor-chunks/dunder-proto","vendor-chunks/call-bound"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fbusiness%2Fonboarding%2Fstep-11-payment-setup%2Froute&page=%2Fapi%2Fbusiness%2Fonboarding%2Fstep-11-payment-setup%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fbusiness%2Fonboarding%2Fstep-11-payment-setup%2Froute.ts&appDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();