"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/onboarding/page",{

/***/ "(app-pages-browser)/./src/lib/fake-business.tsx":
/*!***********************************!*\
  !*** ./src/lib/fake-business.tsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FakeBusinessProvider: function() { return /* binding */ FakeBusinessProvider; },\n/* harmony export */   useFakeBusiness: function() { return /* binding */ useFakeBusiness; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_admin_workspace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/admin-workspace */ \"(app-pages-browser)/./src/lib/admin-workspace.ts\");\n/* __next_internal_client_entry_do_not_use__ FakeBusinessProvider,useFakeBusiness auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst FakeBusinessContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createContext(undefined);\nfunction FakeBusinessProvider(param) {\n    let { children } = param;\n    _s();\n    const [business, setBusiness] = react__WEBPACK_IMPORTED_MODULE_1__.useState(undefined);\n    const [workspace, setWorkspace] = react__WEBPACK_IMPORTED_MODULE_1__.useState(undefined);\n    const [hasHydratedFromStorage, setHasHydratedFromStorage] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        if (false) {}\n        // Check if we have a current user session\n        const checkUserAndLoad = async ()=>{\n            try {\n                var _session_user;\n                // Get current user from Supabase session\n                const { createClientClient } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_lib_supabase-client_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./supabase-client */ \"(app-pages-browser)/./src/lib/supabase-client.ts\"));\n                const supabase = createClientClient();\n                const { data: { session } } = await supabase.auth.getSession();\n                if (!(session === null || session === void 0 ? void 0 : (_session_user = session.user) === null || _session_user === void 0 ? void 0 : _session_user.id)) {\n                    // No user session - don't load any data\n                    setHasHydratedFromStorage(true);\n                    return;\n                }\n                // Business data should be loaded from database via API calls, not localStorage\n                // This ensures proper user isolation and fresh data for each user\n                console.log(\"[FakeBusinessProvider] Using database-only approach - no localStorage\");\n                setHasHydratedFromStorage(true);\n            } catch (error) {\n                console.warn(\"[FakeBusinessProvider] Failed to check session\", error);\n                setHasHydratedFromStorage(true);\n            }\n        };\n        checkUserAndLoad();\n    }, []);\n    // No localStorage persistence - data is stored in database only\n    // This ensures proper user isolation and prevents stale data issues\n    const createBusiness = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((payload)=>{\n        setBusiness(payload);\n    }, []);\n    const updateBusiness = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((updates)=>{\n        setBusiness((existing)=>existing ? {\n                ...existing,\n                ...updates\n            } : existing);\n    }, []);\n    const bootstrapWorkspace = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((seed)=>{\n        const workspaceSnapshot = (0,_lib_admin_workspace__WEBPACK_IMPORTED_MODULE_2__.createWorkspaceFromOnboarding)(seed);\n        setWorkspace(workspaceSnapshot);\n        return workspaceSnapshot;\n    }, []);\n    const updateWorkspace = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((updater)=>{\n        setWorkspace((existing)=>{\n            if (!existing) return existing;\n            const updated = updater(existing);\n            return updated;\n        });\n    }, []);\n    const setCatalog = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((catalog)=>{\n        updateWorkspace((existing)=>({\n                ...existing,\n                catalog,\n                availabilityTemplates: existing.availabilityTemplates.map((template)=>{\n                    const service = catalog.flatMap((category)=>category.services).find((service)=>service.id === template.serviceId);\n                    return service ? {\n                        ...template,\n                        serviceName: service.name\n                    } : template;\n                }),\n                availability: existing.availability.map((entry)=>{\n                    const service = catalog.flatMap((category)=>category.services).find((svc)=>svc.id === entry.serviceId);\n                    if (!service) return entry;\n                    const assignedIds = new Set(service.staffIds);\n                    const filteredStaff = entry.staff.filter((slot)=>assignedIds.has(slot.staffId));\n                    const missingStaff = service.staffIds.filter((id)=>!filteredStaff.some((slot)=>slot.staffId === id)).map((id)=>({\n                            staffId: id,\n                            slots: []\n                        }));\n                    return {\n                        ...entry,\n                        staff: [\n                            ...filteredStaff,\n                            ...missingStaff\n                        ]\n                    };\n                }).filter((entry)=>catalog.some((category)=>category.services.some((svc)=>svc.id === entry.serviceId)))\n            }));\n    }, [\n        updateWorkspace\n    ]);\n    const setStaff = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((staff)=>{\n        updateWorkspace((existing)=>({\n                ...existing,\n                staff,\n                availabilityTemplates: existing.availabilityTemplates.map((template)=>({\n                        ...template,\n                        staffAssignments: template.staffAssignments.map((assignment)=>{\n                            const member = staff.find((staffMember)=>staffMember.id === assignment.staffId);\n                            return {\n                                ...assignment,\n                                staffName: member ? member.name : assignment.staffName\n                            };\n                        })\n                    })),\n                availability: existing.availability.map((entry)=>({\n                        ...entry,\n                        staff: entry.staff.filter((assignment)=>staff.some((member)=>member.id === assignment.staffId))\n                    }))\n            }));\n    }, [\n        updateWorkspace\n    ]);\n    const setAvailability = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((availability)=>{\n        updateWorkspace((existing)=>({\n                ...existing,\n                availability,\n                availabilityTemplates: buildTemplatesFromAvailability(existing.catalog, existing.staff, availability)\n            }));\n    }, [\n        updateWorkspace\n    ]);\n    const setNotifications = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((templates)=>{\n        updateWorkspace((existing)=>({\n                ...existing,\n                notifications: templates\n            }));\n    }, [\n        updateWorkspace\n    ]);\n    const setPolicies = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((policies)=>{\n        updateWorkspace((existing)=>({\n                ...existing,\n                policies\n            }));\n    }, [\n        updateWorkspace\n    ]);\n    const setGiftCards = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((program)=>{\n        updateWorkspace((existing)=>({\n                ...existing,\n                giftCards: program\n            }));\n    }, [\n        updateWorkspace\n    ]);\n    const setPayment = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((updater)=>{\n        updateWorkspace((existing)=>({\n                ...existing,\n                payment: updater(existing.payment)\n            }));\n    }, [\n        updateWorkspace\n    ]);\n    const setIdentity = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((updater)=>{\n        updateWorkspace((existing)=>({\n                ...existing,\n                identity: updater(existing.identity)\n            }));\n    }, [\n        updateWorkspace\n    ]);\n    const performBookingAction = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((bookingId, action)=>{\n        let response;\n        setWorkspace((existing)=>{\n            if (!existing) return existing;\n            const index = existing.bookings.findIndex((booking)=>booking.id === bookingId);\n            if (index === -1) return existing;\n            const targetBooking = existing.bookings[index];\n            const actionResult = applyMoneyBoardAction(targetBooking, action, existing.policies, existing.giftCards);\n            response = actionResult.response;\n            if (!actionResult.shouldPersist) {\n                return existing;\n            }\n            const updatedBookings = [\n                ...existing.bookings\n            ];\n            updatedBookings[index] = actionResult.booking;\n            var _actionResult_giftCards;\n            const updatedWorkspace = {\n                ...existing,\n                bookings: updatedBookings,\n                customers: (0,_lib_admin_workspace__WEBPACK_IMPORTED_MODULE_2__.deriveCustomersFromBookings)(updatedBookings),\n                analytics: (0,_lib_admin_workspace__WEBPACK_IMPORTED_MODULE_2__.recomputeAnalytics)(updatedBookings),\n                giftCards: (_actionResult_giftCards = actionResult.giftCards) !== null && _actionResult_giftCards !== void 0 ? _actionResult_giftCards : existing.giftCards\n            };\n            return updatedWorkspace;\n        });\n        return response;\n    }, []);\n    const recordPublicBooking = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((payload)=>{\n        if (!business) return undefined;\n        let createdBooking;\n        setWorkspace((existing)=>{\n            if (!existing) return existing;\n            const result = createBookingFromPublicFlow(business, existing, payload);\n            if (!result) return existing;\n            createdBooking = result.booking;\n            return result.workspace;\n        });\n        return createdBooking;\n    }, [\n        business\n    ]);\n    const copyAvailabilityTemplate = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((templateId)=>{\n        updateWorkspace((existing)=>{\n            const template = existing.availabilityTemplates.find((entry)=>entry.id === templateId);\n            return template ? {\n                ...existing,\n                availabilityClipboard: {\n                    ...template,\n                    staffAssignments: template.staffAssignments.map((assignment)=>({\n                            ...assignment,\n                            slots: assignment.slots.map((slot)=>({\n                                    ...slot\n                                }))\n                        }))\n                }\n            } : existing;\n        });\n    }, [\n        updateWorkspace\n    ]);\n    const pasteAvailabilityTemplate = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((serviceId)=>{\n        updateWorkspace((existing)=>{\n            if (!existing.availabilityClipboard) return existing;\n            const clipboard = existing.availabilityClipboard;\n            const newAvailability = existing.availability.map((entry)=>entry.serviceId === serviceId ? {\n                    serviceId,\n                    staff: clipboard.staffAssignments.map((assignment)=>({\n                            staffId: assignment.staffId,\n                            slots: assignment.slots.map((slot)=>({\n                                    ...slot\n                                }))\n                        }))\n                } : entry);\n            const newTemplates = existing.availabilityTemplates.some((template)=>template.serviceId === serviceId) ? existing.availabilityTemplates.map((template)=>template.serviceId === serviceId ? {\n                    ...clipboard,\n                    id: template.id,\n                    serviceId,\n                    serviceName: clipboard.serviceName\n                } : template) : [\n                ...existing.availabilityTemplates,\n                {\n                    ...clipboard,\n                    id: \"template_\".concat(serviceId),\n                    serviceId,\n                    serviceName: clipboard.serviceName\n                }\n            ];\n            return {\n                ...existing,\n                availability: newAvailability,\n                availabilityTemplates: newTemplates\n            };\n        });\n    }, [\n        updateWorkspace\n    ]);\n    const clearAvailabilityClipboard = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(()=>{\n        updateWorkspace((existing)=>({\n                ...existing,\n                availabilityClipboard: null\n            }));\n    }, [\n        updateWorkspace\n    ]);\n    const refreshAnalytics = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(()=>{\n        updateWorkspace((existing)=>({\n                ...existing,\n                analytics: (0,_lib_admin_workspace__WEBPACK_IMPORTED_MODULE_2__.recomputeAnalytics)(existing.bookings),\n                customers: (0,_lib_admin_workspace__WEBPACK_IMPORTED_MODULE_2__.deriveCustomersFromBookings)(existing.bookings)\n            }));\n    }, [\n        updateWorkspace\n    ]);\n    const loadSeedBusiness = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(function() {\n        let seed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _lib_admin_workspace__WEBPACK_IMPORTED_MODULE_2__.DEV_WORKSPACE_SEED, overrides = arguments.length > 1 ? arguments[1] : void 0;\n        var _overrides_slug, _ref;\n        const slug = ((_ref = (_overrides_slug = overrides === null || overrides === void 0 ? void 0 : overrides.slug) !== null && _overrides_slug !== void 0 ? _overrides_slug : seed.website.subdomain) !== null && _ref !== void 0 ? _ref : \"preview\").toLowerCase();\n        var _overrides_bookingUrl;\n        const bookingUrl = (_overrides_bookingUrl = overrides === null || overrides === void 0 ? void 0 : overrides.bookingUrl) !== null && _overrides_bookingUrl !== void 0 ? _overrides_bookingUrl : \"https://\".concat(slug, \".main.tld\");\n        var _overrides_previewUrl;\n        const previewUrl = (_overrides_previewUrl = overrides === null || overrides === void 0 ? void 0 : overrides.previewUrl) !== null && _overrides_previewUrl !== void 0 ? _overrides_previewUrl : \"/public/\".concat(slug);\n        var _overrides_id, _overrides_name, _overrides_status, _overrides_createdAt, _overrides_trialEndsAt, _overrides_nextBillDate;\n        const businessPayload = {\n            id: (_overrides_id = overrides === null || overrides === void 0 ? void 0 : overrides.id) !== null && _overrides_id !== void 0 ? _overrides_id : \"biz_\".concat(slug),\n            name: (_overrides_name = overrides === null || overrides === void 0 ? void 0 : overrides.name) !== null && _overrides_name !== void 0 ? _overrides_name : seed.business.businessName,\n            slug,\n            bookingUrl,\n            previewUrl,\n            status: (_overrides_status = overrides === null || overrides === void 0 ? void 0 : overrides.status) !== null && _overrides_status !== void 0 ? _overrides_status : seed.payment.subscriptionStatus,\n            createdAt: (_overrides_createdAt = overrides === null || overrides === void 0 ? void 0 : overrides.createdAt) !== null && _overrides_createdAt !== void 0 ? _overrides_createdAt : new Date().toISOString(),\n            trialEndsAt: (_overrides_trialEndsAt = overrides === null || overrides === void 0 ? void 0 : overrides.trialEndsAt) !== null && _overrides_trialEndsAt !== void 0 ? _overrides_trialEndsAt : seed.payment.trialEndsAt,\n            nextBillDate: (_overrides_nextBillDate = overrides === null || overrides === void 0 ? void 0 : overrides.nextBillDate) !== null && _overrides_nextBillDate !== void 0 ? _overrides_nextBillDate : seed.payment.nextBillDate\n        };\n        const workspaceSnapshot = (0,_lib_admin_workspace__WEBPACK_IMPORTED_MODULE_2__.createWorkspaceFromOnboarding)(seed);\n        let resolvedBusiness = businessPayload;\n        setBusiness((existing)=>{\n            if (existing) {\n                resolvedBusiness = existing;\n                return existing;\n            }\n            resolvedBusiness = businessPayload;\n            return businessPayload;\n        });\n        let resolvedWorkspace = workspaceSnapshot;\n        setWorkspace((existing)=>{\n            if (existing) {\n                resolvedWorkspace = existing;\n                return existing;\n            }\n            resolvedWorkspace = workspaceSnapshot;\n            return workspaceSnapshot;\n        });\n        return {\n            business: resolvedBusiness,\n            workspace: resolvedWorkspace\n        };\n    }, []);\n    const clearBusiness = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(()=>{\n        setBusiness(undefined);\n        setWorkspace(undefined);\n    // Business data is in database, no localStorage to clear\n    }, []);\n    const value = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>({\n            business,\n            workspace,\n            createBusiness,\n            bootstrapWorkspace,\n            loadSeedBusiness,\n            updateBusiness,\n            updateWorkspace,\n            setCatalog,\n            setStaff,\n            setAvailability,\n            setNotifications,\n            setPolicies,\n            setGiftCards,\n            setPayment,\n            setIdentity,\n            performBookingAction,\n            copyAvailabilityTemplate,\n            pasteAvailabilityTemplate,\n            clearAvailabilityClipboard,\n            refreshAnalytics,\n            recordPublicBooking,\n            clearBusiness\n        }), [\n        business,\n        workspace,\n        createBusiness,\n        bootstrapWorkspace,\n        loadSeedBusiness,\n        updateBusiness,\n        updateWorkspace,\n        setCatalog,\n        setStaff,\n        setAvailability,\n        setNotifications,\n        setPolicies,\n        setGiftCards,\n        setPayment,\n        setIdentity,\n        performBookingAction,\n        copyAvailabilityTemplate,\n        pasteAvailabilityTemplate,\n        clearAvailabilityClipboard,\n        refreshAnalytics,\n        recordPublicBooking,\n        clearBusiness\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(FakeBusinessContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/3017387smacbookm/Downloads/Career/Tithi/apps/web/src/lib/fake-business.tsx\",\n        lineNumber: 554,\n        columnNumber: 5\n    }, this);\n}\n_s(FakeBusinessProvider, \"FJSaKVqVBip5wV1YNPwej/chXkw=\");\n_c = FakeBusinessProvider;\nfunction useFakeBusiness() {\n    _s1();\n    const context = react__WEBPACK_IMPORTED_MODULE_1__.useContext(FakeBusinessContext);\n    if (!context) {\n        throw new Error(\"useFakeBusiness must be used within a FakeBusinessProvider\");\n    }\n    return context;\n}\n_s1(useFakeBusiness, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nfunction createBookingFromPublicFlow(business, workspace, payload) {\n    var _payload_giftCard;\n    const serviceResult = findServiceInCatalog(workspace.catalog, payload.serviceId);\n    if (!serviceResult) {\n        return undefined;\n    }\n    const { service, category } = serviceResult;\n    const staffMember = payload.staffId ? workspace.staff.find((member)=>member.id === payload.staffId) : null;\n    const listPriceCents = Math.max(service.priceCents, 0);\n    var _payload_giftCard_amountCents;\n    const requestedGiftCardCents = Math.max((_payload_giftCard_amountCents = (_payload_giftCard = payload.giftCard) === null || _payload_giftCard === void 0 ? void 0 : _payload_giftCard.amountCents) !== null && _payload_giftCard_amountCents !== void 0 ? _payload_giftCard_amountCents : 0, 0);\n    const giftCardAmountCents = Math.min(requestedGiftCardCents, listPriceCents);\n    const authorizationAmountCents = Math.max(listPriceCents - giftCardAmountCents, 0);\n    const normalizedEmail = normalizeEmail(payload.customer.email);\n    const normalizedPhone = payload.customer.phone ? normalizePhone(payload.customer.phone) : undefined;\n    var _workspace_customers_find;\n    const existingCustomer = (_workspace_customers_find = workspace.customers.find((customer)=>normalizeEmail(customer.email) === normalizedEmail)) !== null && _workspace_customers_find !== void 0 ? _workspace_customers_find : normalizedPhone ? workspace.customers.find((customer)=>customer.phone && normalizePhone(customer.phone) === normalizedPhone) : undefined;\n    var _payload_customer_phone, _payload_consent_acceptedAt;\n    const customer = existingCustomer ? {\n        ...existingCustomer,\n        name: payload.customer.name,\n        phone: (_payload_customer_phone = payload.customer.phone) !== null && _payload_customer_phone !== void 0 ? _payload_customer_phone : existingCustomer.phone\n    } : {\n        id: \"cust_\".concat(crypto.randomUUID()),\n        name: payload.customer.name,\n        email: payload.customer.email,\n        phone: payload.customer.phone,\n        createdAt: (_payload_consent_acceptedAt = payload.consent.acceptedAt) !== null && _payload_consent_acceptedAt !== void 0 ? _payload_consent_acceptedAt : new Date().toISOString()\n    };\n    const bookingCode = generateBookingCode(business.slug, workspace.bookings.map((booking)=>booking.code));\n    const authorizationPayment = {\n        id: \"pay_\".concat(crypto.randomUUID()),\n        bookingId: \"booking_\".concat(bookingCode),\n        type: \"authorization\",\n        amountCents: authorizationAmountCents,\n        status: payload.requiresAction ? \"requires_action\" : \"authorized\",\n        occurredAt: payload.startDateTime,\n        notes: \"Card saved securely for manual capture\"\n    };\n    const booking = {\n        id: \"booking_\".concat(bookingCode),\n        code: bookingCode,\n        status: payload.requiresAction ? \"requires_action\" : \"authorized\",\n        serviceId: service.id,\n        serviceName: service.name,\n        categoryName: category.name,\n        durationMinutes: service.durationMinutes,\n        startDateTime: payload.startDateTime,\n        endDateTime: payload.endDateTime,\n        staff: staffMember ? {\n            id: staffMember.id,\n            name: staffMember.name,\n            color: staffMember.color\n        } : null,\n        customer,\n        payments: [\n            authorizationPayment\n        ],\n        financials: {\n            listPriceCents,\n            giftCardAmountCents,\n            platformFeeCents: 0,\n            stripeFeeEstimateCents: 0,\n            netPayoutCents: 0,\n            currency: \"usd\"\n        },\n        policyConsent: payload.consent,\n        requiresAction: Boolean(payload.requiresAction),\n        notes: undefined\n    };\n    const updatedBookings = [\n        booking,\n        ...workspace.bookings\n    ];\n    const updatedCustomers = (0,_lib_admin_workspace__WEBPACK_IMPORTED_MODULE_2__.deriveCustomersFromBookings)(updatedBookings);\n    const updatedAnalytics = (0,_lib_admin_workspace__WEBPACK_IMPORTED_MODULE_2__.recomputeAnalytics)(updatedBookings);\n    const updatedGiftCards = applyGiftCardRedemption(workspace.giftCards, payload, giftCardAmountCents, bookingCode);\n    return {\n        booking,\n        workspace: {\n            ...workspace,\n            bookings: updatedBookings,\n            customers: updatedCustomers,\n            analytics: updatedAnalytics,\n            giftCards: updatedGiftCards\n        }\n    };\n}\nfunction findServiceInCatalog(catalog, serviceId) {\n    for (const category of catalog){\n        const service = category.services.find((entry)=>entry.id === serviceId);\n        if (service) {\n            return {\n                service,\n                category\n            };\n        }\n    }\n    return undefined;\n}\nfunction applyGiftCardRedemption(giftCards, payload, redemptionAmountCents, bookingCode) {\n    var _ledgerForCode_at;\n    if (!giftCards.config.enabled || !payload.giftCard || redemptionAmountCents <= 0) {\n        return giftCards;\n    }\n    const code = payload.giftCard.code.toUpperCase();\n    const ledgerForCode = giftCards.ledger.filter((entry)=>entry.code === code);\n    var _ledgerForCode_at_balanceAfterCents;\n    const lastBalance = (_ledgerForCode_at_balanceAfterCents = (_ledgerForCode_at = ledgerForCode.at(-1)) === null || _ledgerForCode_at === void 0 ? void 0 : _ledgerForCode_at.balanceAfterCents) !== null && _ledgerForCode_at_balanceAfterCents !== void 0 ? _ledgerForCode_at_balanceAfterCents : giftCards.config.amountType === \"amount\" ? giftCards.config.amountValue : 0;\n    const nextBalance = giftCards.config.amountType === \"amount\" ? Math.max(lastBalance - redemptionAmountCents, 0) : 0;\n    var _payload_consent_acceptedAt;\n    const ledgerEntry = {\n        id: \"gcl_\".concat(crypto.randomUUID()),\n        code,\n        bookingCode,\n        deltaCents: -redemptionAmountCents,\n        balanceAfterCents: nextBalance,\n        occurredAt: (_payload_consent_acceptedAt = payload.consent.acceptedAt) !== null && _payload_consent_acceptedAt !== void 0 ? _payload_consent_acceptedAt : new Date().toISOString(),\n        reason: \"redeemed\"\n    };\n    return {\n        ...giftCards,\n        config: {\n            ...giftCards.config,\n            generatedCodes: Array.from(new Set([\n                ...giftCards.config.generatedCodes,\n                code\n            ]))\n        },\n        ledger: [\n            ...giftCards.ledger,\n            ledgerEntry\n        ]\n    };\n}\nfunction generateBookingCode(slug, existingCodes) {\n    const prefix = createBookingPrefix(slug);\n    const year = new Date().getFullYear();\n    let attempt = 0;\n    let code = \"\";\n    do {\n        const sequence = Math.floor(1000 + Math.random() * 9000);\n        code = \"\".concat(prefix, \"-\").concat(year, \"-\").concat(sequence);\n        attempt += 1;\n    }while (existingCodes.includes(code) && attempt < 25);\n    return code;\n}\nfunction createBookingPrefix(slug) {\n    const sanitized = slug.replace(/[^a-z0-9]/gi, \"\");\n    const prefix = sanitized.slice(0, 3).toUpperCase();\n    return prefix.padEnd(3, \"X\");\n}\nfunction normalizeEmail(email) {\n    return email.trim().toLowerCase();\n}\nfunction normalizePhone(phone) {\n    return phone ? phone.replace(/\\D/g, \"\") : \"\";\n}\nfunction buildTemplatesFromAvailability(catalog, staff, availability) {\n    return availability.map((entry)=>{\n        const service = catalog.flatMap((category)=>category.services).find((svc)=>svc.id === entry.serviceId);\n        return {\n            id: \"template_\".concat(entry.serviceId),\n            label: service ? \"\".concat(service.name, \" default\") : \"Default\",\n            serviceId: entry.serviceId,\n            serviceName: service ? service.name : \"Service\",\n            staffAssignments: entry.staff.map((assignment)=>{\n                const member = staff.find((staffMember)=>staffMember.id === assignment.staffId);\n                return {\n                    staffId: assignment.staffId,\n                    staffName: member ? member.name : \"Staff\",\n                    slots: assignment.slots.map((slot)=>({\n                            ...slot\n                        }))\n                };\n            })\n        };\n    });\n}\nfunction applyMoneyBoardAction(booking, action, policies, giftCards) {\n    switch(action){\n        case \"complete\":\n            return completeBooking(booking);\n        case \"no_show\":\n            return noShowBooking(booking, policies);\n        case \"cancel\":\n            return cancelBooking(booking, policies);\n        case \"refund\":\n            return refundBooking(booking, giftCards);\n        default:\n            return {\n                booking,\n                response: {\n                    booking,\n                    status: \"success\",\n                    message: \"No action taken.\"\n                },\n                shouldPersist: false\n            };\n    }\n}\nfunction completeBooking(booking) {\n    if (booking.status === \"captured\") {\n        return {\n            booking,\n            response: {\n                booking,\n                status: \"success\",\n                message: \"This booking is already captured.\"\n            },\n            shouldPersist: false\n        };\n    }\n    if (booking.requiresAction) {\n        return {\n            booking: {\n                ...booking,\n                status: \"requires_action\"\n            },\n            response: {\n                booking,\n                status: \"requires_action\",\n                message: \"Customer must complete authentication.\",\n                payLinkUrl: \"https://pay.stripe.com/pm/\".concat(booking.code.toLowerCase())\n            },\n            shouldPersist: false\n        };\n    }\n    const hasCapture = booking.payments.some((payment)=>payment.type === \"capture\");\n    if (hasCapture) {\n        return {\n            booking,\n            response: {\n                booking,\n                status: \"success\",\n                message: \"Capture already recorded.\"\n            },\n            shouldPersist: false\n        };\n    }\n    const captureAmount = booking.financials.listPriceCents - booking.financials.giftCardAmountCents;\n    const platformFee = Math.round(captureAmount * 0.01);\n    const stripeFee = Math.round(captureAmount * 0.029) + 30;\n    const capturePayment = {\n        id: \"pay_\".concat(crypto.randomUUID()),\n        bookingId: booking.id,\n        type: \"capture\",\n        amountCents: captureAmount,\n        status: \"captured\",\n        occurredAt: new Date().toISOString(),\n        notes: \"Captured from money board\"\n    };\n    const updatedBooking = {\n        ...booking,\n        status: \"captured\",\n        requiresAction: false,\n        payments: [\n            ...booking.payments,\n            capturePayment\n        ],\n        financials: {\n            ...booking.financials,\n            platformFeeCents: platformFee,\n            stripeFeeEstimateCents: stripeFee,\n            netPayoutCents: Math.max(captureAmount - platformFee - stripeFee, 0)\n        }\n    };\n    return {\n        booking: updatedBooking,\n        response: {\n            booking: updatedBooking,\n            status: \"success\",\n            message: \"Capture succeeded â€” funds en route to your Connect account.\"\n        },\n        shouldPersist: true\n    };\n}\nfunction noShowBooking(booking, policies) {\n    const fee = policies.noShowFeeType === \"percent\" ? Math.round(booking.financials.listPriceCents * policies.noShowFeeValue / 100) : Math.round(policies.noShowFeeValue * 100);\n    if (fee <= 0) {\n        const updatedBooking = {\n            ...booking,\n            status: \"no_show\",\n            payments: booking.payments,\n            financials: {\n                ...booking.financials,\n                platformFeeCents: 0,\n                stripeFeeEstimateCents: 0,\n                netPayoutCents: 0\n            }\n        };\n        return {\n            booking: updatedBooking,\n            response: {\n                booking: updatedBooking,\n                status: \"success\",\n                message: \"Marked as no-show with no charge.\"\n            },\n            shouldPersist: true\n        };\n    }\n    const platformFee = Math.round(fee * 0.01);\n    const stripeFee = Math.round(fee * 0.029) + 30;\n    const feePayment = {\n        id: \"pay_\".concat(crypto.randomUUID()),\n        bookingId: booking.id,\n        type: \"no_show_fee\",\n        amountCents: fee,\n        status: \"captured\",\n        occurredAt: new Date().toISOString(),\n        notes: \"No-show fee charged\"\n    };\n    const updatedBooking = {\n        ...booking,\n        status: \"no_show\",\n        requiresAction: false,\n        payments: [\n            ...booking.payments,\n            feePayment\n        ],\n        financials: {\n            ...booking.financials,\n            platformFeeCents: platformFee,\n            stripeFeeEstimateCents: stripeFee,\n            netPayoutCents: Math.max(fee - platformFee - stripeFee, 0)\n        }\n    };\n    return {\n        booking: updatedBooking,\n        response: {\n            booking: updatedBooking,\n            status: \"success\",\n            message: \"No-show fee captured.\"\n        },\n        shouldPersist: true\n    };\n}\nfunction cancelBooking(booking, policies) {\n    const fee = policies.cancellationFeeType === \"percent\" ? Math.round(booking.financials.listPriceCents * policies.cancellationFeeValue / 100) : Math.round(policies.cancellationFeeValue * 100);\n    if (fee <= 0) {\n        const updatedBooking = {\n            ...booking,\n            status: \"canceled\",\n            requiresAction: false,\n            financials: {\n                ...booking.financials,\n                platformFeeCents: 0,\n                stripeFeeEstimateCents: 0,\n                netPayoutCents: 0\n            }\n        };\n        return {\n            booking: updatedBooking,\n            response: {\n                booking: updatedBooking,\n                status: \"success\",\n                message: \"Booking canceled without charge.\"\n            },\n            shouldPersist: true\n        };\n    }\n    const platformFee = Math.round(fee * 0.01);\n    const stripeFee = Math.round(fee * 0.029) + 30;\n    const feePayment = {\n        id: \"pay_\".concat(crypto.randomUUID()),\n        bookingId: booking.id,\n        type: \"cancel_fee\",\n        amountCents: fee,\n        status: \"captured\",\n        occurredAt: new Date().toISOString(),\n        notes: \"Cancellation fee charged\"\n    };\n    const updatedBooking = {\n        ...booking,\n        status: \"canceled\",\n        requiresAction: false,\n        payments: [\n            ...booking.payments,\n            feePayment\n        ],\n        financials: {\n            ...booking.financials,\n            platformFeeCents: platformFee,\n            stripeFeeEstimateCents: stripeFee,\n            netPayoutCents: Math.max(fee - platformFee - stripeFee, 0)\n        }\n    };\n    return {\n        booking: updatedBooking,\n        response: {\n            booking: updatedBooking,\n            status: \"success\",\n            message: \"Cancellation fee captured.\"\n        },\n        shouldPersist: true\n    };\n}\nfunction refundBooking(booking, giftCards) {\n    const capturedAmount = booking.payments.filter((payment)=>payment.type !== \"authorization\" && payment.status === \"captured\").reduce((sum, payment)=>sum + payment.amountCents, 0);\n    if (capturedAmount <= 0) {\n        return {\n            booking,\n            response: {\n                booking,\n                status: \"success\",\n                message: \"No payment to refund.\"\n            },\n            shouldPersist: false\n        };\n    }\n    const refundPayment = {\n        id: \"pay_\".concat(crypto.randomUUID()),\n        bookingId: booking.id,\n        type: \"refund\",\n        amountCents: capturedAmount,\n        status: \"refunded\",\n        occurredAt: new Date().toISOString(),\n        notes: \"Refund processed from admin\"\n    };\n    const updatedBooking = {\n        ...booking,\n        status: \"refunded\",\n        requiresAction: false,\n        payments: [\n            ...booking.payments,\n            refundPayment\n        ],\n        financials: {\n            ...booking.financials,\n            platformFeeCents: 0,\n            stripeFeeEstimateCents: 0,\n            netPayoutCents: 0\n        }\n    };\n    let updatedGiftCards;\n    if (giftCards.config.enabled && giftCards.restoreBalanceOnRefund && booking.financials.giftCardAmountCents > 0) {\n        var _giftCards_ledger_;\n        var _giftCards_config_generatedCodes_, _giftCards_ledger__balanceAfterCents;\n        const restoreEntry = {\n            id: \"gcl_\".concat(crypto.randomUUID()),\n            code: (_giftCards_config_generatedCodes_ = giftCards.config.generatedCodes[0]) !== null && _giftCards_config_generatedCodes_ !== void 0 ? _giftCards_config_generatedCodes_ : \"WELCOME120\",\n            bookingCode: booking.code,\n            deltaCents: booking.financials.giftCardAmountCents,\n            balanceAfterCents: ((_giftCards_ledger__balanceAfterCents = (_giftCards_ledger_ = giftCards.ledger[0]) === null || _giftCards_ledger_ === void 0 ? void 0 : _giftCards_ledger_.balanceAfterCents) !== null && _giftCards_ledger__balanceAfterCents !== void 0 ? _giftCards_ledger__balanceAfterCents : 0) + booking.financials.giftCardAmountCents,\n            occurredAt: new Date().toISOString(),\n            reason: \"refunded\"\n        };\n        updatedGiftCards = {\n            ...giftCards,\n            ledger: [\n                ...giftCards.ledger,\n                restoreEntry\n            ]\n        };\n    }\n    return {\n        booking: updatedBooking,\n        response: {\n            booking: updatedBooking,\n            status: \"success\",\n            message: \"Refund issued. Gift card balance restored if applicable.\"\n        },\n        shouldPersist: true,\n        giftCards: updatedGiftCards\n    };\n}\nvar _c;\n$RefreshReg$(_c, \"FakeBusinessProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZmFrZS1idXNpbmVzcy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFK0I7QUFnQkE7QUFxRi9CLE1BQU1LLG9DQUFzQkwsZ0RBQW1CLENBQzdDTztBQUdLLFNBQVNDLHFCQUFxQixLQUEyQztRQUEzQyxFQUFFQyxRQUFRLEVBQWlDLEdBQTNDOztJQUNuQyxNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR1gsMkNBQWMsQ0FBMkJPO0lBQ3pFLE1BQU0sQ0FBQ00sV0FBV0MsYUFBYSxHQUFHZCwyQ0FBYyxDQUFvQ087SUFDcEYsTUFBTSxDQUFDUSx3QkFBd0JDLDBCQUEwQixHQUFHaEIsMkNBQWMsQ0FBQztJQUUzRUEsNENBQWUsQ0FBQztRQUNkLElBQUksS0FBNkIsRUFBRSxFQUFPO1FBRTFDLDBDQUEwQztRQUMxQyxNQUFNa0IsbUJBQW1CO1lBQ3ZCLElBQUk7b0JBTUdDO2dCQUxMLHlDQUF5QztnQkFDekMsTUFBTSxFQUFFQyxrQkFBa0IsRUFBRSxHQUFHLE1BQU0sdU5BQU87Z0JBQzVDLE1BQU1DLFdBQVdEO2dCQUNqQixNQUFNLEVBQUVFLE1BQU0sRUFBRUgsT0FBTyxFQUFFLEVBQUUsR0FBRyxNQUFNRSxTQUFTRSxJQUFJLENBQUNDLFVBQVU7Z0JBRTVELElBQUksRUFBQ0wsb0JBQUFBLCtCQUFBQSxnQkFBQUEsUUFBU00sSUFBSSxjQUFiTixvQ0FBQUEsY0FBZU8sRUFBRSxHQUFFO29CQUN0Qix3Q0FBd0M7b0JBQ3hDViwwQkFBMEI7b0JBQzFCO2dCQUNGO2dCQUVBLCtFQUErRTtnQkFDL0Usa0VBQWtFO2dCQUNsRVcsUUFBUUMsR0FBRyxDQUFDO2dCQUVaWiwwQkFBMEI7WUFDNUIsRUFBRSxPQUFPYSxPQUFPO2dCQUNkRixRQUFRRyxJQUFJLENBQUMsa0RBQWtERDtnQkFDL0RiLDBCQUEwQjtZQUM1QjtRQUNGO1FBRUFFO0lBQ0YsR0FBRyxFQUFFO0lBRUwsZ0VBQWdFO0lBQ2hFLG9FQUFvRTtJ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QkMsd0JBQXdCO1lBQ3hCQyxnQkFBZ0I7UUFDbEI7SUFDRjtJQUVBLElBQUlNO0lBQ0osSUFDRTVHLFVBQVVnSCxNQUFNLENBQUNDLE9BQU8sSUFDeEJqSCxVQUFVdUssc0JBQXNCLElBQ2hDM0osUUFBUXVGLFVBQVUsQ0FBQzdCLG1CQUFtQixHQUFHLEdBQ3pDO1lBT0t0RTtZQUpHQSxtQ0FJSEE7UUFOTCxNQUFNd0ssZUFBZTtZQUNuQnBPLElBQUksT0FBMkIsT0FBcEI2SSxPQUFPQyxVQUFVO1lBQzVCSyxNQUFNdkYsQ0FBQUEsb0NBQUFBLFVBQVVnSCxNQUFNLENBQUNhLGNBQWMsQ0FBQyxFQUFFLGNBQWxDN0gsK0NBQUFBLG9DQUFzQztZQUM1Q3FGLGFBQWF6RSxRQUFRMkUsSUFBSTtZQUN6Qm9DLFlBQVkvRyxRQUFRdUYsVUFBVSxDQUFDN0IsbUJBQW1CO1lBQ2xEZ0QsbUJBQ0UsQ0FBQ3RILENBQUFBLHdDQUFBQSxxQkFBQUEsVUFBVW1ILE1BQU0sQ0FBQyxFQUFFLGNBQW5CbkgseUNBQUFBLG1CQUFxQnNILGlCQUFpQixjQUF0Q3RILGtEQUFBQSx1Q0FBMEMsS0FBS1ksUUFBUXVGLFVBQVUsQ0FBQzdCLG1CQUFtQjtZQUN4RnFCLFlBQVksSUFBSTVDLE9BQU9DLFdBQVc7WUFDbEM0RSxRQUFRO1FBQ1Y7UUFDQWhCLG1CQUFtQjtZQUNqQixHQUFHNUcsU0FBUztZQUNabUgsUUFBUTttQkFBSW5ILFVBQVVtSCxNQUFNO2dCQUFFcUQ7YUFBYTtRQUM3QztJQUNGO0lBRUEsT0FBTztRQUNMNUosU0FBU2dKO1FBQ1RwSixVQUFVO1lBQ1JJLFNBQVNnSjtZQUNUaEgsUUFBUTtZQUNSd0csU0FBUztRQUNYO1FBQ0FwSSxlQUFlO1FBQ2ZoQixXQUFXNEc7SUFDYjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvZmFrZS1idXNpbmVzcy50c3g/YTA0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7XG4gIERFVl9XT1JLU1BBQ0VfU0VFRCxcbiAgY3JlYXRlV29ya3NwYWNlRnJvbU9uYm9hcmRpbmcsXG4gIGRlcml2ZUN1c3RvbWVyc0Zyb21Cb29raW5ncyxcbiAgcmVjb21wdXRlQW5hbHl0aWNzLFxuICB0eXBlIEJvb2tpbmdBY3Rpb25SZXNwb25zZSxcbiAgdHlwZSBGYWtlQnVzaW5lc3NXb3Jrc3BhY2UsXG4gIHR5cGUgRmFrZUJvb2tpbmcsXG4gIHR5cGUgRmFrZUN1c3RvbWVyLFxuICB0eXBlIEZha2VCb29raW5nUG9saWN5Q29uc2VudCxcbiAgdHlwZSBHaWZ0Q2FyZExlZGdlckVudHJ5LFxuICB0eXBlIEdpZnRDYXJkUHJvZ3JhbVN0YXRlLFxuICB0eXBlIE1vbmV5Qm9hcmRBY3Rpb24sXG4gIHR5cGUgV29ya3NwYWNlU2VlZElucHV0XG59IGZyb20gXCJAL2xpYi9hZG1pbi13b3Jrc3BhY2VcIjtcbmltcG9ydCB0eXBlIHtcbiAgTm90aWZpY2F0aW9uVGVtcGxhdGUsXG4gIFBvbGljaWVzQ29uZmlnLFxuICBTZXJ2aWNlQXZhaWxhYmlsaXR5LFxuICBTZXJ2aWNlQ2F0ZWdvcnksXG4gIFN0YWZmTWVtYmVyXG59IGZyb20gXCJAL2xpYi9vbmJvYXJkaW5nLXR5cGVzXCI7XG5cbmV4cG9ydCB0eXBlIEJ1c2luZXNzU3Vic2NyaXB0aW9uU3RhdHVzID0gXCJ0cmlhbFwiIHwgXCJhY3RpdmVcIiB8IFwicGF1c2VkXCIgfCBcImNhbmNlbGVkXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmFrZUJ1c2luZXNzIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBzbHVnOiBzdHJpbmc7XG4gIGJvb2tpbmdVcmw6IHN0cmluZztcbiAgcHJldmlld1VybDogc3RyaW5nO1xuICBzdGF0dXM6IEJ1c2luZXNzU3Vic2NyaXB0aW9uU3RhdHVzO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbiAgdHJpYWxFbmRzQXQ/OiBzdHJpbmc7XG4gIG5leHRCaWxsRGF0ZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEZha2VCdXNpbmVzc0NvbnRleHRWYWx1ZSB7XG4gIGJ1c2luZXNzPzogRmFrZUJ1c2luZXNzO1xuICB3b3Jrc3BhY2U/OiBGYWtlQnVzaW5lc3NXb3Jrc3BhY2U7XG4gIGNyZWF0ZUJ1c2luZXNzOiAoYnVzaW5lc3M6IEZha2VCdXNpbmVzcykgPT4gdm9pZDtcbiAgYm9vdHN0cmFwV29ya3NwYWNlOiAoc2VlZDogV29ya3NwYWNlU2VlZElucHV0KSA9PiBGYWtlQnVzaW5lc3NXb3Jrc3BhY2UgfCB1bmRlZmluZWQ7XG4gIGxvYWRTZWVkQnVzaW5lc3M6IChcbiAgICBzZWVkPzogV29ya3NwYWNlU2VlZElucHV0LFxuICAgIG92ZXJyaWRlcz86IFBhcnRpYWw8RmFrZUJ1c2luZXNzPlxuICApID0+IHsgYnVzaW5lc3M6IEZha2VCdXNpbmVzczsgd29ya3NwYWNlOiBGYWtlQnVzaW5lc3NXb3Jrc3BhY2UgfTtcbiAgdXBkYXRlQnVzaW5lc3M6ICh1cGRhdGVzOiBQYXJ0aWFsPEZha2VCdXNpbmVzcz4pID0+IHZvaWQ7XG4gIHVwZGF0ZVdvcmtzcGFjZTogKFxuICAgIHVwZGF0ZXI6ICh3b3Jrc3BhY2U6IEZha2VCdXNpbmVzc1dvcmtzcGFjZSkgPT4gRmFrZUJ1c2luZXNzV29ya3NwYWNlXG4gICkgPT4gdm9pZDtcbiAgc2V0Q2F0YWxvZzogKGNhdGFsb2c6IFNlcnZpY2VDYXRlZ29yeVtdKSA9PiB2b2lkO1xuICBzZXRTdGFmZjogKHN0YWZmOiBTdGFmZk1lbWJlcltdKSA9PiB2b2lkO1xuICBzZXRBdmFpbGFiaWxpdHk6IChhdmFpbGFiaWxpdHk6IFNlcnZpY2VBdmFpbGFiaWxpdHlbXSkgPT4gdm9pZDtcbiAgc2V0Tm90aWZpY2F0aW9uczogKHRlbXBsYXRlczogTm90aWZpY2F0aW9uVGVtcGxhdGVbXSkgPT4gdm9pZDtcbiAgc2V0UG9saWNpZXM6IChwb2xpY2llczogUG9saWNpZXNDb25maWcpID0+IHZvaWQ7XG4gIHNldEdpZnRDYXJkczogKHByb2dyYW06IEdpZnRDYXJkUHJvZ3JhbVN0YXRlKSA9PiB2b2lkO1xuICBzZXRQYXltZW50OiAoXG4gICAgdXBkYXRlcjogKFxuICAgICAgcGF5bWVudDogRmFrZUJ1c2luZXNzV29ya3NwYWNlW1wicGF5bWVudFwiXVxuICAgICkgPT4gRmFrZUJ1c2luZXNzV29ya3NwYWNlW1wicGF5bWVudFwiXVxuICApID0+IHZvaWQ7XG4gIHNldElkZW50aXR5OiAoXG4gICAgdXBkYXRlcjogKFxuICAgICAgaWRlbnRpdHk6IEZha2VCdXNpbmVzc1dvcmtzcGFjZVtcImlkZW50aXR5XCJdXG4gICAgKSA9PiBGYWtlQnVzaW5lc3NXb3Jrc3BhY2VbXCJpZGVudGl0eVwiXVxuICApID0+IHZvaWQ7XG4gIHBlcmZvcm1Cb29raW5nQWN0aW9uOiAoXG4gICAgYm9va2luZ0lkOiBzdHJpbmcsXG4gICAgYWN0aW9uOiBNb25leUJvYXJkQWN0aW9uXG4gICkgPT4gQm9va2luZ0FjdGlvblJlc3BvbnNlIHwgdW5kZWZpbmVkO1xuICBjb3B5QXZhaWxhYmlsaXR5VGVtcGxhdGU6ICh0ZW1wbGF0ZUlkOiBzdHJpbmcpID0+IHZvaWQ7XG4gIHBhc3RlQXZhaWxhYmlsaXR5VGVtcGxhdGU6IChzZXJ2aWNlSWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgY2xlYXJBdmFpbGFiaWxpdHlDbGlwYm9hcmQ6ICgpID0+IHZvaWQ7XG4gIHJlZnJlc2hBbmFseXRpY3M6ICgpID0+IHZvaWQ7XG4gIHJlY29yZFB1YmxpY0Jvb2tpbmc6IChwYXlsb2FkOiBQdWJsaWNCb29raW5nUGF5bG9hZCkgPT4gRmFrZUJvb2tpbmcgfCB1bmRlZmluZWQ7XG4gIGNsZWFyQnVzaW5lc3M6ICgpID0+IHZvaWQ7XG59XG5cbi8vIFJlbW92ZWQgU1RPUkFHRV9LRVkgLSBubyBsb2NhbFN0b3JhZ2UgdXNhZ2UsIGFsbCBkYXRhIGluIGRhdGFiYXNlXG5cbmV4cG9ydCBpbnRlcmZhY2UgUHVibGljQm9va2luZ1BheWxvYWQge1xuICBzZXJ2aWNlSWQ6IHN0cmluZztcbiAgc3RhZmZJZD86IHN0cmluZyB8IG51bGw7XG4gIHN0YXJ0RGF0ZVRpbWU6IHN0cmluZztcbiAgZW5kRGF0ZVRpbWU6IHN0cmluZztcbiAgY3VzdG9tZXI6IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgZW1haWw6IHN0cmluZztcbiAgICBwaG9uZT86IHN0cmluZztcbiAgfTtcbiAgY29uc2VudDogRmFrZUJvb2tpbmdQb2xpY3lDb25zZW50O1xuICBnaWZ0Q2FyZD86IHtcbiAgICBjb2RlOiBzdHJpbmc7XG4gICAgYW1vdW50Q2VudHM6IG51bWJlcjtcbiAgfTtcbiAgcGF5bWVudE1ldGhvZDogc3RyaW5nO1xuICByZXF1aXJlc0FjdGlvbj86IGJvb2xlYW47XG59XG5cbmNvbnN0IEZha2VCdXNpbmVzc0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PEZha2VCdXNpbmVzc0NvbnRleHRWYWx1ZSB8IHVuZGVmaW5lZD4oXG4gIHVuZGVmaW5lZFxuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIEZha2VCdXNpbmVzc1Byb3ZpZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pIHtcbiAgY29uc3QgW2J1c2luZXNzLCBzZXRCdXNpbmVzc10gPSBSZWFjdC51c2VTdGF0ZTxGYWtlQnVzaW5lc3MgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG4gIGNvbnN0IFt3b3Jrc3BhY2UsIHNldFdvcmtzcGFjZV0gPSBSZWFjdC51c2VTdGF0ZTxGYWtlQnVzaW5lc3NXb3Jrc3BhY2UgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG4gIGNvbnN0IFtoYXNIeWRyYXRlZEZyb21TdG9yYWdlLCBzZXRIYXNIeWRyYXRlZEZyb21TdG9yYWdlXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhIGN1cnJlbnQgdXNlciBzZXNzaW9uXG4gICAgY29uc3QgY2hlY2tVc2VyQW5kTG9hZCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEdldCBjdXJyZW50IHVzZXIgZnJvbSBTdXBhYmFzZSBzZXNzaW9uXG4gICAgICAgIGNvbnN0IHsgY3JlYXRlQ2xpZW50Q2xpZW50IH0gPSBhd2FpdCBpbXBvcnQoJy4vc3VwYWJhc2UtY2xpZW50Jyk7XG4gICAgICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50Q2xpZW50KCk7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFzZXNzaW9uPy51c2VyPy5pZCkge1xuICAgICAgICAgIC8vIE5vIHVzZXIgc2Vzc2lvbiAtIGRvbid0IGxvYWQgYW55IGRhdGFcbiAgICAgICAgICBzZXRIYXNIeWRyYXRlZEZyb21TdG9yYWdlKHRydWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQnVzaW5lc3MgZGF0YSBzaG91bGQgYmUgbG9hZGVkIGZyb20gZGF0YWJhc2UgdmlhIEFQSSBjYWxscywgbm90IGxvY2FsU3RvcmFnZVxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgcHJvcGVyIHVzZXIgaXNvbGF0aW9uIGFuZCBmcmVzaCBkYXRhIGZvciBlYWNoIHVzZXJcbiAgICAgICAgY29uc29sZS5sb2coJ1tGYWtlQnVzaW5lc3NQcm92aWRlcl0gVXNpbmcgZGF0YWJhc2Utb25seSBhcHByb2FjaCAtIG5vIGxvY2FsU3RvcmFnZScpO1xuICAgICAgICBcbiAgICAgICAgc2V0SGFzSHlkcmF0ZWRGcm9tU3RvcmFnZSh0cnVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltGYWtlQnVzaW5lc3NQcm92aWRlcl0gRmFpbGVkIHRvIGNoZWNrIHNlc3Npb25cIiwgZXJyb3IpO1xuICAgICAgICBzZXRIYXNIeWRyYXRlZEZyb21TdG9yYWdlKHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgY2hlY2tVc2VyQW5kTG9hZCgpO1xuICB9LCBbXSk7XG5cbiAgLy8gTm8gbG9jYWxTdG9yYWdlIHBlcnNpc3RlbmNlIC0gZGF0YSBpcyBzdG9yZWQgaW4gZGF0YWJhc2Ugb25seVxuICAvLyBUaGlzIGVuc3VyZXMgcHJvcGVyIHVzZXIgaXNvbGF0aW9uIGFuZCBwcmV2ZW50cyBzdGFsZSBkYXRhIGlzc3Vlc1xuXG4gIGNvbnN0IGNyZWF0ZUJ1c2luZXNzID0gUmVhY3QudXNlQ2FsbGJhY2soKHBheWxvYWQ6IEZha2VCdXNpbmVzcykgPT4ge1xuICAgIHNldEJ1c2luZXNzKHBheWxvYWQpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgdXBkYXRlQnVzaW5lc3MgPSBSZWFjdC51c2VDYWxsYmFjaygodXBkYXRlczogUGFydGlhbDxGYWtlQnVzaW5lc3M+KSA9PiB7XG4gICAgc2V0QnVzaW5lc3MoKGV4aXN0aW5nKSA9PiAoZXhpc3RpbmcgPyB7IC4uLmV4aXN0aW5nLCAuLi51cGRhdGVzIH0gOiBleGlzdGluZykpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgYm9vdHN0cmFwV29ya3NwYWNlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKHNlZWQ6IFdvcmtzcGFjZVNlZWRJbnB1dCk6IEZha2VCdXNpbmVzc1dvcmtzcGFjZSB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICBjb25zdCB3b3Jrc3BhY2VTbmFwc2hvdCA9IGNyZWF0ZVdvcmtzcGFjZUZyb21PbmJvYXJkaW5nKHNlZWQpO1xuICAgICAgc2V0V29ya3NwYWNlKHdvcmtzcGFjZVNuYXBzaG90KTtcbiAgICAgIHJldHVybiB3b3Jrc3BhY2VTbmFwc2hvdDtcbiAgICB9LFxuICAgIFtdXG4gICk7XG5cbiAgY29uc3QgdXBkYXRlV29ya3NwYWNlID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKHVwZGF0ZXI6ICh3b3Jrc3BhY2U6IEZha2VCdXNpbmVzc1dvcmtzcGFjZSkgPT4gRmFrZUJ1c2luZXNzV29ya3NwYWNlKSA9PiB7XG4gICAgICBzZXRXb3Jrc3BhY2UoKGV4aXN0aW5nKSA9PiB7XG4gICAgICAgIGlmICghZXhpc3RpbmcpIHJldHVybiBleGlzdGluZztcbiAgICAgICAgY29uc3QgdXBkYXRlZCA9IHVwZGF0ZXIoZXhpc3RpbmcpO1xuICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW11cbiAgKTtcblxuICBjb25zdCBzZXRDYXRhbG9nID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGNhdGFsb2c6IFNlcnZpY2VDYXRlZ29yeVtdKSA9PiB7XG4gICAgICB1cGRhdGVXb3Jrc3BhY2UoKGV4aXN0aW5nKSA9PiAoe1xuICAgICAgICAuLi5leGlzdGluZyxcbiAgICAgICAgY2F0YWxvZyxcbiAgICAgICAgYXZhaWxhYmlsaXR5VGVtcGxhdGVzOiBleGlzdGluZy5hdmFpbGFiaWxpdHlUZW1wbGF0ZXMubWFwKCh0ZW1wbGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBjYXRhbG9nXG4gICAgICAgICAgICAuZmxhdE1hcCgoY2F0ZWdvcnkpID0+IGNhdGVnb3J5LnNlcnZpY2VzKVxuICAgICAgICAgICAgLmZpbmQoKHNlcnZpY2UpID0+IHNlcnZpY2UuaWQgPT09IHRlbXBsYXRlLnNlcnZpY2VJZCk7XG4gICAgICAgICAgcmV0dXJuIHNlcnZpY2VcbiAgICAgICAgICAgID8geyAuLi50ZW1wbGF0ZSwgc2VydmljZU5hbWU6IHNlcnZpY2UubmFtZSB9XG4gICAgICAgICAgICA6IHRlbXBsYXRlO1xuICAgICAgICB9KSxcbiAgICAgICAgYXZhaWxhYmlsaXR5OiBleGlzdGluZy5hdmFpbGFiaWxpdHlcbiAgICAgICAgICAubWFwKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VydmljZSA9IGNhdGFsb2dcbiAgICAgICAgICAgICAgLmZsYXRNYXAoKGNhdGVnb3J5KSA9PiBjYXRlZ29yeS5zZXJ2aWNlcylcbiAgICAgICAgICAgICAgLmZpbmQoKHN2YykgPT4gc3ZjLmlkID09PSBlbnRyeS5zZXJ2aWNlSWQpO1xuICAgICAgICAgICAgaWYgKCFzZXJ2aWNlKSByZXR1cm4gZW50cnk7XG4gICAgICAgICAgICBjb25zdCBhc3NpZ25lZElkcyA9IG5ldyBTZXQoc2VydmljZS5zdGFmZklkcyk7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZFN0YWZmID0gZW50cnkuc3RhZmYuZmlsdGVyKChzbG90KSA9PiBhc3NpZ25lZElkcy5oYXMoc2xvdC5zdGFmZklkKSk7XG4gICAgICAgICAgICBjb25zdCBtaXNzaW5nU3RhZmYgPSBzZXJ2aWNlLnN0YWZmSWRzXG4gICAgICAgICAgICAgIC5maWx0ZXIoKGlkKSA9PiAhZmlsdGVyZWRTdGFmZi5zb21lKChzbG90KSA9PiBzbG90LnN0YWZmSWQgPT09IGlkKSlcbiAgICAgICAgICAgICAgLm1hcCgoaWQpID0+ICh7XG4gICAgICAgICAgICAgICAgc3RhZmZJZDogaWQsXG4gICAgICAgICAgICAgICAgc2xvdHM6IFtdXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmVudHJ5LFxuICAgICAgICAgICAgICBzdGFmZjogWy4uLmZpbHRlcmVkU3RhZmYsIC4uLm1pc3NpbmdTdGFmZl1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmlsdGVyKChlbnRyeSkgPT5cbiAgICAgICAgICAgIGNhdGFsb2cuc29tZSgoY2F0ZWdvcnkpID0+IGNhdGVnb3J5LnNlcnZpY2VzLnNvbWUoKHN2YykgPT4gc3ZjLmlkID09PSBlbnRyeS5zZXJ2aWNlSWQpKVxuICAgICAgICAgIClcbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIFt1cGRhdGVXb3Jrc3BhY2VdXG4gICk7XG5cbiAgY29uc3Qgc2V0U3RhZmYgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoc3RhZmY6IFN0YWZmTWVtYmVyW10pID0+IHtcbiAgICAgIHVwZGF0ZVdvcmtzcGFjZSgoZXhpc3RpbmcpID0+ICh7XG4gICAgICAgIC4uLmV4aXN0aW5nLFxuICAgICAgICBzdGFmZixcbiAgICAgICAgYXZhaWxhYmlsaXR5VGVtcGxhdGVzOiBleGlzdGluZy5hdmFpbGFiaWxpdHlUZW1wbGF0ZXMubWFwKCh0ZW1wbGF0ZSkgPT4gKHtcbiAgICAgICAgICAuLi50ZW1wbGF0ZSxcbiAgICAgICAgICBzdGFmZkFzc2lnbm1lbnRzOiB0ZW1wbGF0ZS5zdGFmZkFzc2lnbm1lbnRzLm1hcCgoYXNzaWdubWVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVtYmVyID0gc3RhZmYuZmluZCgoc3RhZmZNZW1iZXIpID0+IHN0YWZmTWVtYmVyLmlkID09PSBhc3NpZ25tZW50LnN0YWZmSWQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uYXNzaWdubWVudCxcbiAgICAgICAgICAgICAgc3RhZmZOYW1lOiBtZW1iZXIgPyBtZW1iZXIubmFtZSA6IGFzc2lnbm1lbnQuc3RhZmZOYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pKSxcbiAgICAgICAgYXZhaWxhYmlsaXR5OiBleGlzdGluZy5hdmFpbGFiaWxpdHkubWFwKChlbnRyeSkgPT4gKHtcbiAgICAgICAgICAuLi5lbnRyeSxcbiAgICAgICAgICBzdGFmZjogZW50cnkuc3RhZmYuZmlsdGVyKChhc3NpZ25tZW50KSA9PlxuICAgICAgICAgICAgc3RhZmYuc29tZSgobWVtYmVyKSA9PiBtZW1iZXIuaWQgPT09IGFzc2lnbm1lbnQuc3RhZmZJZClcbiAgICAgICAgICApXG4gICAgICAgIH0pKVxuICAgICAgfSkpO1xuICAgIH0sXG4gICAgW3VwZGF0ZVdvcmtzcGFjZV1cbiAgKTtcblxuICBjb25zdCBzZXRBdmFpbGFiaWxpdHkgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoYXZhaWxhYmlsaXR5OiBTZXJ2aWNlQXZhaWxhYmlsaXR5W10pID0+IHtcbiAgICAgIHVwZGF0ZVdvcmtzcGFjZSgoZXhpc3RpbmcpID0+ICh7XG4gICAgICAgIC4uLmV4aXN0aW5nLFxuICAgICAgICBhdmFpbGFiaWxpdHksXG4gICAgICAgIGF2YWlsYWJpbGl0eVRlbXBsYXRlczogYnVpbGRUZW1wbGF0ZXNGcm9tQXZhaWxhYmlsaXR5KFxuICAgICAgICAgIGV4aXN0aW5nLmNhdGFsb2csXG4gICAgICAgICAgZXhpc3Rpbmcuc3RhZmYsXG4gICAgICAgICAgYXZhaWxhYmlsaXR5XG4gICAgICAgIClcbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIFt1cGRhdGVXb3Jrc3BhY2VdXG4gICk7XG5cbiAgY29uc3Qgc2V0Tm90aWZpY2F0aW9ucyA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICh0ZW1wbGF0ZXM6IE5vdGlmaWNhdGlvblRlbXBsYXRlW10pID0+IHtcbiAgICAgIHVwZGF0ZVdvcmtzcGFjZSgoZXhpc3RpbmcpID0+ICh7XG4gICAgICAgIC4uLmV4aXN0aW5nLFxuICAgICAgICBub3RpZmljYXRpb25zOiB0ZW1wbGF0ZXNcbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIFt1cGRhdGVXb3Jrc3BhY2VdXG4gICk7XG5cbiAgY29uc3Qgc2V0UG9saWNpZXMgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAocG9saWNpZXM6IFBvbGljaWVzQ29uZmlnKSA9PiB7XG4gICAgICB1cGRhdGVXb3Jrc3BhY2UoKGV4aXN0aW5nKSA9PiAoe1xuICAgICAgICAuLi5leGlzdGluZyxcbiAgICAgICAgcG9saWNpZXNcbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIFt1cGRhdGVXb3Jrc3BhY2VdXG4gICk7XG5cbiAgY29uc3Qgc2V0R2lmdENhcmRzID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKHByb2dyYW06IEdpZnRDYXJkUHJvZ3JhbVN0YXRlKSA9PiB7XG4gICAgICB1cGRhdGVXb3Jrc3BhY2UoKGV4aXN0aW5nKSA9PiAoe1xuICAgICAgICAuLi5leGlzdGluZyxcbiAgICAgICAgZ2lmdENhcmRzOiBwcm9ncmFtXG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBbdXBkYXRlV29ya3NwYWNlXVxuICApO1xuXG4gIGNvbnN0IHNldFBheW1lbnQgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAodXBkYXRlcjogKHBheW1lbnQ6IEZha2VCdXNpbmVzc1dvcmtzcGFjZVtcInBheW1lbnRcIl0pID0+IEZha2VCdXNpbmVzc1dvcmtzcGFjZVtcInBheW1lbnRcIl0pID0+IHtcbiAgICAgIHVwZGF0ZVdvcmtzcGFjZSgoZXhpc3RpbmcpID0+ICh7XG4gICAgICAgIC4uLmV4aXN0aW5nLFxuICAgICAgICBwYXltZW50OiB1cGRhdGVyKGV4aXN0aW5nLnBheW1lbnQpXG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBbdXBkYXRlV29ya3NwYWNlXVxuICApO1xuXG4gIGNvbnN0IHNldElkZW50aXR5ID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKFxuICAgICAgdXBkYXRlcjogKFxuICAgICAgICBpZGVudGl0eTogRmFrZUJ1c2luZXNzV29ya3NwYWNlW1wiaWRlbnRpdHlcIl1cbiAgICAgICkgPT4gRmFrZUJ1c2luZXNzV29ya3NwYWNlW1wiaWRlbnRpdHlcIl1cbiAgICApID0+IHtcbiAgICAgIHVwZGF0ZVdvcmtzcGFjZSgoZXhpc3RpbmcpID0+ICh7XG4gICAgICAgIC4uLmV4aXN0aW5nLFxuICAgICAgICBpZGVudGl0eTogdXBkYXRlcihleGlzdGluZy5pZGVudGl0eSlcbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIFt1cGRhdGVXb3Jrc3BhY2VdXG4gICk7XG5cbiAgY29uc3QgcGVyZm9ybUJvb2tpbmdBY3Rpb24gPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoYm9va2luZ0lkOiBzdHJpbmcsIGFjdGlvbjogTW9uZXlCb2FyZEFjdGlvbikgPT4ge1xuICAgICAgbGV0IHJlc3BvbnNlOiBCb29raW5nQWN0aW9uUmVzcG9uc2UgfCB1bmRlZmluZWQ7XG4gICAgICBzZXRXb3Jrc3BhY2UoKGV4aXN0aW5nKSA9PiB7XG4gICAgICAgIGlmICghZXhpc3RpbmcpIHJldHVybiBleGlzdGluZztcbiAgICAgICAgY29uc3QgaW5kZXggPSBleGlzdGluZy5ib29raW5ncy5maW5kSW5kZXgoKGJvb2tpbmcpID0+IGJvb2tpbmcuaWQgPT09IGJvb2tpbmdJZCk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBleGlzdGluZztcblxuICAgICAgICBjb25zdCB0YXJnZXRCb29raW5nID0gZXhpc3RpbmcuYm9va2luZ3NbaW5kZXhdO1xuICAgICAgICBjb25zdCBhY3Rpb25SZXN1bHQgPSBhcHBseU1vbmV5Qm9hcmRBY3Rpb24oXG4gICAgICAgICAgdGFyZ2V0Qm9va2luZyxcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgZXhpc3RpbmcucG9saWNpZXMsXG4gICAgICAgICAgZXhpc3RpbmcuZ2lmdENhcmRzXG4gICAgICAgICk7XG5cbiAgICAgICAgcmVzcG9uc2UgPSBhY3Rpb25SZXN1bHQucmVzcG9uc2U7XG4gICAgICAgIGlmICghYWN0aW9uUmVzdWx0LnNob3VsZFBlcnNpc3QpIHtcbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cGRhdGVkQm9va2luZ3MgPSBbLi4uZXhpc3RpbmcuYm9va2luZ3NdO1xuICAgICAgICB1cGRhdGVkQm9va2luZ3NbaW5kZXhdID0gYWN0aW9uUmVzdWx0LmJvb2tpbmc7XG5cbiAgICAgICAgY29uc3QgdXBkYXRlZFdvcmtzcGFjZTogRmFrZUJ1c2luZXNzV29ya3NwYWNlID0ge1xuICAgICAgICAgIC4uLmV4aXN0aW5nLFxuICAgICAgICAgIGJvb2tpbmdzOiB1cGRhdGVkQm9va2luZ3MsXG4gICAgICAgICAgY3VzdG9tZXJzOiBkZXJpdmVDdXN0b21lcnNGcm9tQm9va2luZ3ModXBkYXRlZEJvb2tpbmdzKSxcbiAgICAgICAgICBhbmFseXRpY3M6IHJlY29tcHV0ZUFuYWx5dGljcyh1cGRhdGVkQm9va2luZ3MpLFxuICAgICAgICAgIGdpZnRDYXJkczogYWN0aW9uUmVzdWx0LmdpZnRDYXJkcyA/PyBleGlzdGluZy5naWZ0Q2FyZHNcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdXBkYXRlZFdvcmtzcGFjZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG4gICAgW11cbiAgKTtcblxuICBjb25zdCByZWNvcmRQdWJsaWNCb29raW5nID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKHBheWxvYWQ6IFB1YmxpY0Jvb2tpbmdQYXlsb2FkKSA9PiB7XG4gICAgICBpZiAoIWJ1c2luZXNzKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgbGV0IGNyZWF0ZWRCb29raW5nOiBGYWtlQm9va2luZyB8IHVuZGVmaW5lZDtcbiAgICAgIHNldFdvcmtzcGFjZSgoZXhpc3RpbmcpID0+IHtcbiAgICAgICAgaWYgKCFleGlzdGluZykgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBjcmVhdGVCb29raW5nRnJvbVB1YmxpY0Zsb3coXG4gICAgICAgICAgYnVzaW5lc3MsXG4gICAgICAgICAgZXhpc3RpbmcsXG4gICAgICAgICAgcGF5bG9hZFxuICAgICAgICApO1xuICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICBjcmVhdGVkQm9va2luZyA9IHJlc3VsdC5ib29raW5nO1xuICAgICAgICByZXR1cm4gcmVzdWx0LndvcmtzcGFjZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNyZWF0ZWRCb29raW5nO1xuICAgIH0sXG4gICAgW2J1c2luZXNzXVxuICApO1xuXG4gIGNvbnN0IGNvcHlBdmFpbGFiaWxpdHlUZW1wbGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKCh0ZW1wbGF0ZUlkOiBzdHJpbmcpID0+IHtcbiAgICB1cGRhdGVXb3Jrc3BhY2UoKGV4aXN0aW5nKSA9PiB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IGV4aXN0aW5nLmF2YWlsYWJpbGl0eVRlbXBsYXRlcy5maW5kKChlbnRyeSkgPT4gZW50cnkuaWQgPT09IHRlbXBsYXRlSWQpO1xuICAgICAgcmV0dXJuIHRlbXBsYXRlXG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4uZXhpc3RpbmcsXG4gICAgICAgICAgICBhdmFpbGFiaWxpdHlDbGlwYm9hcmQ6IHtcbiAgICAgICAgICAgICAgLi4udGVtcGxhdGUsXG4gICAgICAgICAgICAgIHN0YWZmQXNzaWdubWVudHM6IHRlbXBsYXRlLnN0YWZmQXNzaWdubWVudHMubWFwKChhc3NpZ25tZW50KSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLmFzc2lnbm1lbnQsXG4gICAgICAgICAgICAgICAgc2xvdHM6IGFzc2lnbm1lbnQuc2xvdHMubWFwKChzbG90KSA9PiAoeyAuLi5zbG90IH0pKVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIDogZXhpc3Rpbmc7XG4gICAgfSk7XG4gIH0sIFt1cGRhdGVXb3Jrc3BhY2VdKTtcblxuICBjb25zdCBwYXN0ZUF2YWlsYWJpbGl0eVRlbXBsYXRlID0gUmVhY3QudXNlQ2FsbGJhY2soKHNlcnZpY2VJZDogc3RyaW5nKSA9PiB7XG4gICAgdXBkYXRlV29ya3NwYWNlKChleGlzdGluZykgPT4ge1xuICAgICAgaWYgKCFleGlzdGluZy5hdmFpbGFiaWxpdHlDbGlwYm9hcmQpIHJldHVybiBleGlzdGluZztcbiAgICAgIGNvbnN0IGNsaXBib2FyZCA9IGV4aXN0aW5nLmF2YWlsYWJpbGl0eUNsaXBib2FyZDtcbiAgICAgIGNvbnN0IG5ld0F2YWlsYWJpbGl0eSA9IGV4aXN0aW5nLmF2YWlsYWJpbGl0eS5tYXAoKGVudHJ5KSA9PlxuICAgICAgICBlbnRyeS5zZXJ2aWNlSWQgPT09IHNlcnZpY2VJZFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBzZXJ2aWNlSWQsXG4gICAgICAgICAgICAgIHN0YWZmOiBjbGlwYm9hcmQuc3RhZmZBc3NpZ25tZW50cy5tYXAoKGFzc2lnbm1lbnQpID0+ICh7XG4gICAgICAgICAgICAgICAgc3RhZmZJZDogYXNzaWdubWVudC5zdGFmZklkLFxuICAgICAgICAgICAgICAgIHNsb3RzOiBhc3NpZ25tZW50LnNsb3RzLm1hcCgoc2xvdCkgPT4gKHsgLi4uc2xvdCB9KSlcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiBlbnRyeVxuICAgICAgKTtcblxuICAgICAgY29uc3QgbmV3VGVtcGxhdGVzID0gZXhpc3RpbmcuYXZhaWxhYmlsaXR5VGVtcGxhdGVzLnNvbWUoXG4gICAgICAgICh0ZW1wbGF0ZSkgPT4gdGVtcGxhdGUuc2VydmljZUlkID09PSBzZXJ2aWNlSWRcbiAgICAgIClcbiAgICAgICAgPyBleGlzdGluZy5hdmFpbGFiaWxpdHlUZW1wbGF0ZXMubWFwKCh0ZW1wbGF0ZSkgPT5cbiAgICAgICAgICAgIHRlbXBsYXRlLnNlcnZpY2VJZCA9PT0gc2VydmljZUlkXG4gICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgLi4uY2xpcGJvYXJkLFxuICAgICAgICAgICAgICAgICAgaWQ6IHRlbXBsYXRlLmlkLFxuICAgICAgICAgICAgICAgICAgc2VydmljZUlkLFxuICAgICAgICAgICAgICAgICAgc2VydmljZU5hbWU6IGNsaXBib2FyZC5zZXJ2aWNlTmFtZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgOiB0ZW1wbGF0ZVxuICAgICAgICAgIClcbiAgICAgICAgOiBbXG4gICAgICAgICAgICAuLi5leGlzdGluZy5hdmFpbGFiaWxpdHlUZW1wbGF0ZXMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLmNsaXBib2FyZCxcbiAgICAgICAgICAgICAgaWQ6IGB0ZW1wbGF0ZV8ke3NlcnZpY2VJZH1gLFxuICAgICAgICAgICAgICBzZXJ2aWNlSWQsXG4gICAgICAgICAgICAgIHNlcnZpY2VOYW1lOiBjbGlwYm9hcmQuc2VydmljZU5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5leGlzdGluZyxcbiAgICAgICAgYXZhaWxhYmlsaXR5OiBuZXdBdmFpbGFiaWxpdHksXG4gICAgICAgIGF2YWlsYWJpbGl0eVRlbXBsYXRlczogbmV3VGVtcGxhdGVzXG4gICAgICB9O1xuICAgIH0pO1xuICB9LCBbdXBkYXRlV29ya3NwYWNlXSk7XG5cbiAgY29uc3QgY2xlYXJBdmFpbGFiaWxpdHlDbGlwYm9hcmQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgdXBkYXRlV29ya3NwYWNlKChleGlzdGluZykgPT4gKHtcbiAgICAgIC4uLmV4aXN0aW5nLFxuICAgICAgYXZhaWxhYmlsaXR5Q2xpcGJvYXJkOiBudWxsXG4gICAgfSkpO1xuICB9LCBbdXBkYXRlV29ya3NwYWNlXSk7XG5cbiAgY29uc3QgcmVmcmVzaEFuYWx5dGljcyA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICB1cGRhdGVXb3Jrc3BhY2UoKGV4aXN0aW5nKSA9PiAoe1xuICAgICAgLi4uZXhpc3RpbmcsXG4gICAgICBhbmFseXRpY3M6IHJlY29tcHV0ZUFuYWx5dGljcyhleGlzdGluZy5ib29raW5ncyksXG4gICAgICBjdXN0b21lcnM6IGRlcml2ZUN1c3RvbWVyc0Zyb21Cb29raW5ncyhleGlzdGluZy5ib29raW5ncylcbiAgICB9KSk7XG4gIH0sIFt1cGRhdGVXb3Jrc3BhY2VdKTtcblxuICBjb25zdCBsb2FkU2VlZEJ1c2luZXNzID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKFxuICAgICAgc2VlZDogV29ya3NwYWNlU2VlZElucHV0ID0gREVWX1dPUktTUEFDRV9TRUVELFxuICAgICAgb3ZlcnJpZGVzPzogUGFydGlhbDxGYWtlQnVzaW5lc3M+XG4gICAgKSA9PiB7XG4gICAgICBjb25zdCBzbHVnID0gKG92ZXJyaWRlcz8uc2x1ZyA/PyBzZWVkLndlYnNpdGUuc3ViZG9tYWluID8/IFwicHJldmlld1wiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgYm9va2luZ1VybCA9IG92ZXJyaWRlcz8uYm9va2luZ1VybCA/PyBgaHR0cHM6Ly8ke3NsdWd9Lm1haW4udGxkYDtcbiAgICAgIGNvbnN0IHByZXZpZXdVcmwgPSBvdmVycmlkZXM/LnByZXZpZXdVcmwgPz8gYC9wdWJsaWMvJHtzbHVnfWA7XG4gICAgICBjb25zdCBidXNpbmVzc1BheWxvYWQ6IEZha2VCdXNpbmVzcyA9IHtcbiAgICAgICAgaWQ6IG92ZXJyaWRlcz8uaWQgPz8gYGJpel8ke3NsdWd9YCxcbiAgICAgICAgbmFtZTogb3ZlcnJpZGVzPy5uYW1lID8/IHNlZWQuYnVzaW5lc3MuYnVzaW5lc3NOYW1lLFxuICAgICAgICBzbHVnLFxuICAgICAgICBib29raW5nVXJsLFxuICAgICAgICBwcmV2aWV3VXJsLFxuICAgICAgICBzdGF0dXM6IG92ZXJyaWRlcz8uc3RhdHVzID8/IHNlZWQucGF5bWVudC5zdWJzY3JpcHRpb25TdGF0dXMsXG4gICAgICAgIGNyZWF0ZWRBdDogb3ZlcnJpZGVzPy5jcmVhdGVkQXQgPz8gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB0cmlhbEVuZHNBdDogb3ZlcnJpZGVzPy50cmlhbEVuZHNBdCA/PyBzZWVkLnBheW1lbnQudHJpYWxFbmRzQXQsXG4gICAgICAgIG5leHRCaWxsRGF0ZTogb3ZlcnJpZGVzPy5uZXh0QmlsbERhdGUgPz8gc2VlZC5wYXltZW50Lm5leHRCaWxsRGF0ZVxuICAgICAgfTtcblxuICAgICAgY29uc3Qgd29ya3NwYWNlU25hcHNob3QgPSBjcmVhdGVXb3Jrc3BhY2VGcm9tT25ib2FyZGluZyhzZWVkKTtcblxuICAgICAgbGV0IHJlc29sdmVkQnVzaW5lc3MgPSBidXNpbmVzc1BheWxvYWQ7XG4gICAgICBzZXRCdXNpbmVzcygoZXhpc3RpbmcpID0+IHtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgcmVzb2x2ZWRCdXNpbmVzcyA9IGV4aXN0aW5nO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlZEJ1c2luZXNzID0gYnVzaW5lc3NQYXlsb2FkO1xuICAgICAgICByZXR1cm4gYnVzaW5lc3NQYXlsb2FkO1xuICAgICAgfSk7XG5cbiAgICAgIGxldCByZXNvbHZlZFdvcmtzcGFjZSA9IHdvcmtzcGFjZVNuYXBzaG90O1xuICAgICAgc2V0V29ya3NwYWNlKChleGlzdGluZykgPT4ge1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICByZXNvbHZlZFdvcmtzcGFjZSA9IGV4aXN0aW5nO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlZFdvcmtzcGFjZSA9IHdvcmtzcGFjZVNuYXBzaG90O1xuICAgICAgICByZXR1cm4gd29ya3NwYWNlU25hcHNob3Q7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHsgYnVzaW5lc3M6IHJlc29sdmVkQnVzaW5lc3MsIHdvcmtzcGFjZTogcmVzb2x2ZWRXb3Jrc3BhY2UgfTtcbiAgICB9LFxuICAgIFtdXG4gICk7XG5cbiAgY29uc3QgY2xlYXJCdXNpbmVzcyA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRCdXNpbmVzcyh1bmRlZmluZWQpO1xuICAgIHNldFdvcmtzcGFjZSh1bmRlZmluZWQpO1xuICAgIC8vIEJ1c2luZXNzIGRhdGEgaXMgaW4gZGF0YWJhc2UsIG5vIGxvY2FsU3RvcmFnZSB0byBjbGVhclxuICB9LCBbXSk7XG5cbiAgY29uc3QgdmFsdWUgPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBidXNpbmVzcyxcbiAgICAgIHdvcmtzcGFjZSxcbiAgICAgIGNyZWF0ZUJ1c2luZXNzLFxuICAgICAgYm9vdHN0cmFwV29ya3NwYWNlLFxuICAgICAgbG9hZFNlZWRCdXNpbmVzcyxcbiAgICAgIHVwZGF0ZUJ1c2luZXNzLFxuICAgICAgdXBkYXRlV29ya3NwYWNlLFxuICAgICAgc2V0Q2F0YWxvZyxcbiAgICAgIHNldFN0YWZmLFxuICAgICAgc2V0QXZhaWxhYmlsaXR5LFxuICAgICAgc2V0Tm90aWZpY2F0aW9ucyxcbiAgICAgIHNldFBvbGljaWVzLFxuICAgICAgc2V0R2lmdENhcmRzLFxuICAgICAgc2V0UGF5bWVudCxcbiAgICAgIHNldElkZW50aXR5LFxuICAgICAgcGVyZm9ybUJvb2tpbmdBY3Rpb24sXG4gICAgICBjb3B5QXZhaWxhYmlsaXR5VGVtcGxhdGUsXG4gICAgICBwYXN0ZUF2YWlsYWJpbGl0eVRlbXBsYXRlLFxuICAgICAgY2xlYXJBdmFpbGFiaWxpdHlDbGlwYm9hcmQsXG4gICAgICByZWZyZXNoQW5hbHl0aWNzLFxuICAgICAgcmVjb3JkUHVibGljQm9va2luZyxcbiAgICAgIGNsZWFyQnVzaW5lc3NcbiAgICB9KSxcbiAgICBbXG4gICAgICBidXNpbmVzcyxcbiAgICAgIHdvcmtzcGFjZSxcbiAgICAgIGNyZWF0ZUJ1c2luZXNzLFxuICAgICAgYm9vdHN0cmFwV29ya3NwYWNlLFxuICAgICAgbG9hZFNlZWRCdXNpbmVzcyxcbiAgICAgIHVwZGF0ZUJ1c2luZXNzLFxuICAgICAgdXBkYXRlV29ya3NwYWNlLFxuICAgICAgc2V0Q2F0YWxvZyxcbiAgICAgIHNldFN0YWZmLFxuICAgICAgc2V0QXZhaWxhYmlsaXR5LFxuICAgICAgc2V0Tm90aWZpY2F0aW9ucyxcbiAgICAgIHNldFBvbGljaWVzLFxuICAgICAgc2V0R2lmdENhcmRzLFxuICAgICAgc2V0UGF5bWVudCxcbiAgICAgIHNldElkZW50aXR5LFxuICAgICAgcGVyZm9ybUJvb2tpbmdBY3Rpb24sXG4gICAgICBjb3B5QXZhaWxhYmlsaXR5VGVtcGxhdGUsXG4gICAgICBwYXN0ZUF2YWlsYWJpbGl0eVRlbXBsYXRlLFxuICAgICAgY2xlYXJBdmFpbGFiaWxpdHlDbGlwYm9hcmQsXG4gICAgICByZWZyZXNoQW5hbHl0aWNzLFxuICAgICAgcmVjb3JkUHVibGljQm9va2luZyxcbiAgICAgIGNsZWFyQnVzaW5lc3NcbiAgICBdXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8RmFrZUJ1c2luZXNzQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dmFsdWV9PntjaGlsZHJlbn08L0Zha2VCdXNpbmVzc0NvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VGYWtlQnVzaW5lc3MoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KEZha2VCdXNpbmVzc0NvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VGYWtlQnVzaW5lc3MgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIEZha2VCdXNpbmVzc1Byb3ZpZGVyXCIpO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCb29raW5nRnJvbVB1YmxpY0Zsb3coXG4gIGJ1c2luZXNzOiBGYWtlQnVzaW5lc3MsXG4gIHdvcmtzcGFjZTogRmFrZUJ1c2luZXNzV29ya3NwYWNlLFxuICBwYXlsb2FkOiBQdWJsaWNCb29raW5nUGF5bG9hZFxuKTogeyBib29raW5nOiBGYWtlQm9va2luZzsgd29ya3NwYWNlOiBGYWtlQnVzaW5lc3NXb3Jrc3BhY2UgfSB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHNlcnZpY2VSZXN1bHQgPSBmaW5kU2VydmljZUluQ2F0YWxvZyh3b3Jrc3BhY2UuY2F0YWxvZywgcGF5bG9hZC5zZXJ2aWNlSWQpO1xuICBpZiAoIXNlcnZpY2VSZXN1bHQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgeyBzZXJ2aWNlLCBjYXRlZ29yeSB9ID0gc2VydmljZVJlc3VsdDtcbiAgY29uc3Qgc3RhZmZNZW1iZXIgPSBwYXlsb2FkLnN0YWZmSWRcbiAgICA/IHdvcmtzcGFjZS5zdGFmZi5maW5kKChtZW1iZXIpID0+IG1lbWJlci5pZCA9PT0gcGF5bG9hZC5zdGFmZklkKVxuICAgIDogbnVsbDtcblxuICBjb25zdCBsaXN0UHJpY2VDZW50cyA9IE1hdGgubWF4KHNlcnZpY2UucHJpY2VDZW50cywgMCk7XG4gIGNvbnN0IHJlcXVlc3RlZEdpZnRDYXJkQ2VudHMgPSBNYXRoLm1heChwYXlsb2FkLmdpZnRDYXJkPy5hbW91bnRDZW50cyA/PyAwLCAwKTtcbiAgY29uc3QgZ2lmdENhcmRBbW91bnRDZW50cyA9IE1hdGgubWluKHJlcXVlc3RlZEdpZnRDYXJkQ2VudHMsIGxpc3RQcmljZUNlbnRzKTtcbiAgY29uc3QgYXV0aG9yaXphdGlvbkFtb3VudENlbnRzID0gTWF0aC5tYXgobGlzdFByaWNlQ2VudHMgLSBnaWZ0Q2FyZEFtb3VudENlbnRzLCAwKTtcblxuICBjb25zdCBub3JtYWxpemVkRW1haWwgPSBub3JtYWxpemVFbWFpbChwYXlsb2FkLmN1c3RvbWVyLmVtYWlsKTtcbiAgY29uc3Qgbm9ybWFsaXplZFBob25lID0gcGF5bG9hZC5jdXN0b21lci5waG9uZSA/IG5vcm1hbGl6ZVBob25lKHBheWxvYWQuY3VzdG9tZXIucGhvbmUpIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IGV4aXN0aW5nQ3VzdG9tZXIgPVxuICAgIHdvcmtzcGFjZS5jdXN0b21lcnMuZmluZCgoY3VzdG9tZXIpID0+IG5vcm1hbGl6ZUVtYWlsKGN1c3RvbWVyLmVtYWlsKSA9PT0gbm9ybWFsaXplZEVtYWlsKSA/P1xuICAgIChub3JtYWxpemVkUGhvbmVcbiAgICAgID8gd29ya3NwYWNlLmN1c3RvbWVycy5maW5kKFxuICAgICAgICAgIChjdXN0b21lcikgPT4gY3VzdG9tZXIucGhvbmUgJiYgbm9ybWFsaXplUGhvbmUoY3VzdG9tZXIucGhvbmUpID09PSBub3JtYWxpemVkUGhvbmVcbiAgICAgICAgKVxuICAgICAgOiB1bmRlZmluZWQpO1xuXG4gIGNvbnN0IGN1c3RvbWVyOiBGYWtlQ3VzdG9tZXIgPSBleGlzdGluZ0N1c3RvbWVyXG4gICAgPyB7XG4gICAgICAgIC4uLmV4aXN0aW5nQ3VzdG9tZXIsXG4gICAgICAgIG5hbWU6IHBheWxvYWQuY3VzdG9tZXIubmFtZSxcbiAgICAgICAgcGhvbmU6IHBheWxvYWQuY3VzdG9tZXIucGhvbmUgPz8gZXhpc3RpbmdDdXN0b21lci5waG9uZVxuICAgICAgfVxuICAgIDoge1xuICAgICAgICBpZDogYGN1c3RfJHtjcnlwdG8ucmFuZG9tVVVJRCgpfWAsXG4gICAgICAgIG5hbWU6IHBheWxvYWQuY3VzdG9tZXIubmFtZSxcbiAgICAgICAgZW1haWw6IHBheWxvYWQuY3VzdG9tZXIuZW1haWwsXG4gICAgICAgIHBob25lOiBwYXlsb2FkLmN1c3RvbWVyLnBob25lLFxuICAgICAgICBjcmVhdGVkQXQ6IHBheWxvYWQuY29uc2VudC5hY2NlcHRlZEF0ID8/IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfTtcblxuICBjb25zdCBib29raW5nQ29kZSA9IGdlbmVyYXRlQm9va2luZ0NvZGUoXG4gICAgYnVzaW5lc3Muc2x1ZyxcbiAgICB3b3Jrc3BhY2UuYm9va2luZ3MubWFwKChib29raW5nKSA9PiBib29raW5nLmNvZGUpXG4gICk7XG5cbiAgY29uc3QgYXV0aG9yaXphdGlvblBheW1lbnQ6IEZha2VCb29raW5nW1wicGF5bWVudHNcIl1bbnVtYmVyXSA9IHtcbiAgICBpZDogYHBheV8ke2NyeXB0by5yYW5kb21VVUlEKCl9YCxcbiAgICBib29raW5nSWQ6IGBib29raW5nXyR7Ym9va2luZ0NvZGV9YCxcbiAgICB0eXBlOiBcImF1dGhvcml6YXRpb25cIixcbiAgICBhbW91bnRDZW50czogYXV0aG9yaXphdGlvbkFtb3VudENlbnRzLFxuICAgIHN0YXR1czogcGF5bG9hZC5yZXF1aXJlc0FjdGlvbiA/IFwicmVxdWlyZXNfYWN0aW9uXCIgOiBcImF1dGhvcml6ZWRcIixcbiAgICBvY2N1cnJlZEF0OiBwYXlsb2FkLnN0YXJ0RGF0ZVRpbWUsXG4gICAgbm90ZXM6IFwiQ2FyZCBzYXZlZCBzZWN1cmVseSBmb3IgbWFudWFsIGNhcHR1cmVcIlxuICB9O1xuXG4gIGNvbnN0IGJvb2tpbmc6IEZha2VCb29raW5nID0ge1xuICAgIGlkOiBgYm9va2luZ18ke2Jvb2tpbmdDb2RlfWAsXG4gICAgY29kZTogYm9va2luZ0NvZGUsXG4gICAgc3RhdHVzOiBwYXlsb2FkLnJlcXVpcmVzQWN0aW9uID8gXCJyZXF1aXJlc19hY3Rpb25cIiA6IFwiYXV0aG9yaXplZFwiLFxuICAgIHNlcnZpY2VJZDogc2VydmljZS5pZCxcbiAgICBzZXJ2aWNlTmFtZTogc2VydmljZS5uYW1lLFxuICAgIGNhdGVnb3J5TmFtZTogY2F0ZWdvcnkubmFtZSxcbiAgICBkdXJhdGlvbk1pbnV0ZXM6IHNlcnZpY2UuZHVyYXRpb25NaW51dGVzLFxuICAgIHN0YXJ0RGF0ZVRpbWU6IHBheWxvYWQuc3RhcnREYXRlVGltZSxcbiAgICBlbmREYXRlVGltZTogcGF5bG9hZC5lbmREYXRlVGltZSxcbiAgICBzdGFmZjogc3RhZmZNZW1iZXJcbiAgICAgID8geyBpZDogc3RhZmZNZW1iZXIuaWQsIG5hbWU6IHN0YWZmTWVtYmVyLm5hbWUsIGNvbG9yOiBzdGFmZk1lbWJlci5jb2xvciB9XG4gICAgICA6IG51bGwsXG4gICAgY3VzdG9tZXIsXG4gICAgcGF5bWVudHM6IFthdXRob3JpemF0aW9uUGF5bWVudF0sXG4gICAgZmluYW5jaWFsczoge1xuICAgICAgbGlzdFByaWNlQ2VudHMsXG4gICAgICBnaWZ0Q2FyZEFtb3VudENlbnRzLFxuICAgICAgcGxhdGZvcm1GZWVDZW50czogMCxcbiAgICAgIHN0cmlwZUZlZUVzdGltYXRlQ2VudHM6IDAsXG4gICAgICBuZXRQYXlvdXRDZW50czogMCxcbiAgICAgIGN1cnJlbmN5OiBcInVzZFwiXG4gICAgfSxcbiAgICBwb2xpY3lDb25zZW50OiBwYXlsb2FkLmNvbnNlbnQsXG4gICAgcmVxdWlyZXNBY3Rpb246IEJvb2xlYW4ocGF5bG9hZC5yZXF1aXJlc0FjdGlvbiksXG4gICAgbm90ZXM6IHVuZGVmaW5lZFxuICB9O1xuXG4gIGNvbnN0IHVwZGF0ZWRCb29raW5ncyA9IFtib29raW5nLCAuLi53b3Jrc3BhY2UuYm9va2luZ3NdO1xuICBjb25zdCB1cGRhdGVkQ3VzdG9tZXJzID0gZGVyaXZlQ3VzdG9tZXJzRnJvbUJvb2tpbmdzKHVwZGF0ZWRCb29raW5ncyk7XG4gIGNvbnN0IHVwZGF0ZWRBbmFseXRpY3MgPSByZWNvbXB1dGVBbmFseXRpY3ModXBkYXRlZEJvb2tpbmdzKTtcbiAgY29uc3QgdXBkYXRlZEdpZnRDYXJkcyA9IGFwcGx5R2lmdENhcmRSZWRlbXB0aW9uKFxuICAgIHdvcmtzcGFjZS5naWZ0Q2FyZHMsXG4gICAgcGF5bG9hZCxcbiAgICBnaWZ0Q2FyZEFtb3VudENlbnRzLFxuICAgIGJvb2tpbmdDb2RlXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBib29raW5nLFxuICAgIHdvcmtzcGFjZToge1xuICAgICAgLi4ud29ya3NwYWNlLFxuICAgICAgYm9va2luZ3M6IHVwZGF0ZWRCb29raW5ncyxcbiAgICAgIGN1c3RvbWVyczogdXBkYXRlZEN1c3RvbWVycyxcbiAgICAgIGFuYWx5dGljczogdXBkYXRlZEFuYWx5dGljcyxcbiAgICAgIGdpZnRDYXJkczogdXBkYXRlZEdpZnRDYXJkc1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZmluZFNlcnZpY2VJbkNhdGFsb2coXG4gIGNhdGFsb2c6IFNlcnZpY2VDYXRlZ29yeVtdLFxuICBzZXJ2aWNlSWQ6IHN0cmluZ1xuKTogeyBzZXJ2aWNlOiBTZXJ2aWNlQ2F0ZWdvcnlbXCJzZXJ2aWNlc1wiXVtudW1iZXJdOyBjYXRlZ29yeTogU2VydmljZUNhdGVnb3J5IH0gfCB1bmRlZmluZWQge1xuICBmb3IgKGNvbnN0IGNhdGVnb3J5IG9mIGNhdGFsb2cpIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gY2F0ZWdvcnkuc2VydmljZXMuZmluZCgoZW50cnkpID0+IGVudHJ5LmlkID09PSBzZXJ2aWNlSWQpO1xuICAgIGlmIChzZXJ2aWNlKSB7XG4gICAgICByZXR1cm4geyBzZXJ2aWNlLCBjYXRlZ29yeSB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBhcHBseUdpZnRDYXJkUmVkZW1wdGlvbihcbiAgZ2lmdENhcmRzOiBHaWZ0Q2FyZFByb2dyYW1TdGF0ZSxcbiAgcGF5bG9hZDogUHVibGljQm9va2luZ1BheWxvYWQsXG4gIHJlZGVtcHRpb25BbW91bnRDZW50czogbnVtYmVyLFxuICBib29raW5nQ29kZTogc3RyaW5nXG4pOiBHaWZ0Q2FyZFByb2dyYW1TdGF0ZSB7XG4gIGlmICghZ2lmdENhcmRzLmNvbmZpZy5lbmFibGVkIHx8ICFwYXlsb2FkLmdpZnRDYXJkIHx8IHJlZGVtcHRpb25BbW91bnRDZW50cyA8PSAwKSB7XG4gICAgcmV0dXJuIGdpZnRDYXJkcztcbiAgfVxuXG4gIGNvbnN0IGNvZGUgPSBwYXlsb2FkLmdpZnRDYXJkLmNvZGUudG9VcHBlckNhc2UoKTtcbiAgY29uc3QgbGVkZ2VyRm9yQ29kZSA9IGdpZnRDYXJkcy5sZWRnZXIuZmlsdGVyKChlbnRyeSkgPT4gZW50cnkuY29kZSA9PT0gY29kZSk7XG4gIGNvbnN0IGxhc3RCYWxhbmNlID1cbiAgICBsZWRnZXJGb3JDb2RlLmF0KC0xKT8uYmFsYW5jZUFmdGVyQ2VudHMgPz9cbiAgICAoZ2lmdENhcmRzLmNvbmZpZy5hbW91bnRUeXBlID09PSBcImFtb3VudFwiID8gZ2lmdENhcmRzLmNvbmZpZy5hbW91bnRWYWx1ZSA6IDApO1xuICBjb25zdCBuZXh0QmFsYW5jZSA9XG4gICAgZ2lmdENhcmRzLmNvbmZpZy5hbW91bnRUeXBlID09PSBcImFtb3VudFwiXG4gICAgICA/IE1hdGgubWF4KGxhc3RCYWxhbmNlIC0gcmVkZW1wdGlvbkFtb3VudENlbnRzLCAwKVxuICAgICAgOiAwO1xuXG4gIGNvbnN0IGxlZGdlckVudHJ5OiBHaWZ0Q2FyZExlZGdlckVudHJ5ID0ge1xuICAgIGlkOiBgZ2NsXyR7Y3J5cHRvLnJhbmRvbVVVSUQoKX1gLFxuICAgIGNvZGUsXG4gICAgYm9va2luZ0NvZGUsXG4gICAgZGVsdGFDZW50czogLXJlZGVtcHRpb25BbW91bnRDZW50cyxcbiAgICBiYWxhbmNlQWZ0ZXJDZW50czogbmV4dEJhbGFuY2UsXG4gICAgb2NjdXJyZWRBdDogcGF5bG9hZC5jb25zZW50LmFjY2VwdGVkQXQgPz8gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHJlYXNvbjogXCJyZWRlZW1lZFwiXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5naWZ0Q2FyZHMsXG4gICAgY29uZmlnOiB7XG4gICAgICAuLi5naWZ0Q2FyZHMuY29uZmlnLFxuICAgICAgZ2VuZXJhdGVkQ29kZXM6IEFycmF5LmZyb20obmV3IFNldChbLi4uZ2lmdENhcmRzLmNvbmZpZy5nZW5lcmF0ZWRDb2RlcywgY29kZV0pKVxuICAgIH0sXG4gICAgbGVkZ2VyOiBbLi4uZ2lmdENhcmRzLmxlZGdlciwgbGVkZ2VyRW50cnldXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQm9va2luZ0NvZGUoc2x1Zzogc3RyaW5nLCBleGlzdGluZ0NvZGVzOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gIGNvbnN0IHByZWZpeCA9IGNyZWF0ZUJvb2tpbmdQcmVmaXgoc2x1Zyk7XG4gIGNvbnN0IHllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gIGxldCBhdHRlbXB0ID0gMDtcbiAgbGV0IGNvZGUgPSBcIlwiO1xuICBkbyB7XG4gICAgY29uc3Qgc2VxdWVuY2UgPSBNYXRoLmZsb29yKDEwMDAgKyBNYXRoLnJhbmRvbSgpICogOTAwMCk7XG4gICAgY29kZSA9IGAke3ByZWZpeH0tJHt5ZWFyfS0ke3NlcXVlbmNlfWA7XG4gICAgYXR0ZW1wdCArPSAxO1xuICB9IHdoaWxlIChleGlzdGluZ0NvZGVzLmluY2x1ZGVzKGNvZGUpICYmIGF0dGVtcHQgPCAyNSk7XG4gIHJldHVybiBjb2RlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCb29raW5nUHJlZml4KHNsdWc6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHNhbml0aXplZCA9IHNsdWcucmVwbGFjZSgvW15hLXowLTldL2dpLCBcIlwiKTtcbiAgY29uc3QgcHJlZml4ID0gc2FuaXRpemVkLnNsaWNlKDAsIDMpLnRvVXBwZXJDYXNlKCk7XG4gIHJldHVybiBwcmVmaXgucGFkRW5kKDMsIFwiWFwiKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplRW1haWwoZW1haWw6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBlbWFpbC50cmltKCkudG9Mb3dlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUGhvbmUocGhvbmU/OiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gcGhvbmUgPyBwaG9uZS5yZXBsYWNlKC9cXEQvZywgXCJcIikgOiBcIlwiO1xufVxuXG5mdW5jdGlvbiBidWlsZFRlbXBsYXRlc0Zyb21BdmFpbGFiaWxpdHkoXG4gIGNhdGFsb2c6IFNlcnZpY2VDYXRlZ29yeVtdLFxuICBzdGFmZjogU3RhZmZNZW1iZXJbXSxcbiAgYXZhaWxhYmlsaXR5OiBTZXJ2aWNlQXZhaWxhYmlsaXR5W11cbikge1xuICByZXR1cm4gYXZhaWxhYmlsaXR5Lm1hcCgoZW50cnkpID0+IHtcbiAgICBjb25zdCBzZXJ2aWNlID0gY2F0YWxvZ1xuICAgICAgLmZsYXRNYXAoKGNhdGVnb3J5KSA9PiBjYXRlZ29yeS5zZXJ2aWNlcylcbiAgICAgIC5maW5kKChzdmMpID0+IHN2Yy5pZCA9PT0gZW50cnkuc2VydmljZUlkKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGB0ZW1wbGF0ZV8ke2VudHJ5LnNlcnZpY2VJZH1gLFxuICAgICAgbGFiZWw6IHNlcnZpY2UgPyBgJHtzZXJ2aWNlLm5hbWV9IGRlZmF1bHRgIDogXCJEZWZhdWx0XCIsXG4gICAgICBzZXJ2aWNlSWQ6IGVudHJ5LnNlcnZpY2VJZCxcbiAgICAgIHNlcnZpY2VOYW1lOiBzZXJ2aWNlID8gc2VydmljZS5uYW1lIDogXCJTZXJ2aWNlXCIsXG4gICAgICBzdGFmZkFzc2lnbm1lbnRzOiBlbnRyeS5zdGFmZi5tYXAoKGFzc2lnbm1lbnQpID0+IHtcbiAgICAgICAgY29uc3QgbWVtYmVyID0gc3RhZmYuZmluZCgoc3RhZmZNZW1iZXIpID0+IHN0YWZmTWVtYmVyLmlkID09PSBhc3NpZ25tZW50LnN0YWZmSWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YWZmSWQ6IGFzc2lnbm1lbnQuc3RhZmZJZCxcbiAgICAgICAgICBzdGFmZk5hbWU6IG1lbWJlciA/IG1lbWJlci5uYW1lIDogXCJTdGFmZlwiLFxuICAgICAgICAgIHNsb3RzOiBhc3NpZ25tZW50LnNsb3RzLm1hcCgoc2xvdCkgPT4gKHsgLi4uc2xvdCB9KSlcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgfTtcbiAgfSk7XG59XG5cbmludGVyZmFjZSBBY3Rpb25SZXN1bHQge1xuICBib29raW5nOiBGYWtlQm9va2luZztcbiAgcmVzcG9uc2U6IEJvb2tpbmdBY3Rpb25SZXNwb25zZTtcbiAgc2hvdWxkUGVyc2lzdDogYm9vbGVhbjtcbiAgZ2lmdENhcmRzPzogR2lmdENhcmRQcm9ncmFtU3RhdGU7XG59XG5cbmZ1bmN0aW9uIGFwcGx5TW9uZXlCb2FyZEFjdGlvbihcbiAgYm9va2luZzogRmFrZUJvb2tpbmcsXG4gIGFjdGlvbjogTW9uZXlCb2FyZEFjdGlvbixcbiAgcG9saWNpZXM6IFBvbGljaWVzQ29uZmlnLFxuICBnaWZ0Q2FyZHM6IEdpZnRDYXJkUHJvZ3JhbVN0YXRlXG4pOiBBY3Rpb25SZXN1bHQge1xuICBzd2l0Y2ggKGFjdGlvbikge1xuICAgIGNhc2UgXCJjb21wbGV0ZVwiOlxuICAgICAgcmV0dXJuIGNvbXBsZXRlQm9va2luZyhib29raW5nKTtcbiAgICBjYXNlIFwibm9fc2hvd1wiOlxuICAgICAgcmV0dXJuIG5vU2hvd0Jvb2tpbmcoYm9va2luZywgcG9saWNpZXMpO1xuICAgIGNhc2UgXCJjYW5jZWxcIjpcbiAgICAgIHJldHVybiBjYW5jZWxCb29raW5nKGJvb2tpbmcsIHBvbGljaWVzKTtcbiAgICBjYXNlIFwicmVmdW5kXCI6XG4gICAgICByZXR1cm4gcmVmdW5kQm9va2luZyhib29raW5nLCBnaWZ0Q2FyZHMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBib29raW5nLFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIGJvb2tpbmcsXG4gICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICBtZXNzYWdlOiBcIk5vIGFjdGlvbiB0YWtlbi5cIlxuICAgICAgICB9LFxuICAgICAgICBzaG91bGRQZXJzaXN0OiBmYWxzZVxuICAgICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wbGV0ZUJvb2tpbmcoYm9va2luZzogRmFrZUJvb2tpbmcpOiBBY3Rpb25SZXN1bHQge1xuICBpZiAoYm9va2luZy5zdGF0dXMgPT09IFwiY2FwdHVyZWRcIikge1xuICAgIHJldHVybiB7XG4gICAgICBib29raW5nLFxuICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgYm9va2luZyxcbiAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWVzc2FnZTogXCJUaGlzIGJvb2tpbmcgaXMgYWxyZWFkeSBjYXB0dXJlZC5cIlxuICAgICAgfSxcbiAgICAgIHNob3VsZFBlcnNpc3Q6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIGlmIChib29raW5nLnJlcXVpcmVzQWN0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJvb2tpbmc6IHtcbiAgICAgICAgLi4uYm9va2luZyxcbiAgICAgICAgc3RhdHVzOiBcInJlcXVpcmVzX2FjdGlvblwiXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgYm9va2luZyxcbiAgICAgICAgc3RhdHVzOiBcInJlcXVpcmVzX2FjdGlvblwiLFxuICAgICAgICBtZXNzYWdlOiBcIkN1c3RvbWVyIG11c3QgY29tcGxldGUgYXV0aGVudGljYXRpb24uXCIsXG4gICAgICAgIHBheUxpbmtVcmw6IGBodHRwczovL3BheS5zdHJpcGUuY29tL3BtLyR7Ym9va2luZy5jb2RlLnRvTG93ZXJDYXNlKCl9YFxuICAgICAgfSxcbiAgICAgIHNob3VsZFBlcnNpc3Q6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGhhc0NhcHR1cmUgPSBib29raW5nLnBheW1lbnRzLnNvbWUoKHBheW1lbnQpID0+IHBheW1lbnQudHlwZSA9PT0gXCJjYXB0dXJlXCIpO1xuICBpZiAoaGFzQ2FwdHVyZSkge1xuICAgIHJldHVybiB7XG4gICAgICBib29raW5nLFxuICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgYm9va2luZyxcbiAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWVzc2FnZTogXCJDYXB0dXJlIGFscmVhZHkgcmVjb3JkZWQuXCJcbiAgICAgIH0sXG4gICAgICBzaG91bGRQZXJzaXN0OiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBjb25zdCBjYXB0dXJlQW1vdW50ID1cbiAgICBib29raW5nLmZpbmFuY2lhbHMubGlzdFByaWNlQ2VudHMgLSBib29raW5nLmZpbmFuY2lhbHMuZ2lmdENhcmRBbW91bnRDZW50cztcbiAgY29uc3QgcGxhdGZvcm1GZWUgPSBNYXRoLnJvdW5kKGNhcHR1cmVBbW91bnQgKiAwLjAxKTtcbiAgY29uc3Qgc3RyaXBlRmVlID0gTWF0aC5yb3VuZChjYXB0dXJlQW1vdW50ICogMC4wMjkpICsgMzA7XG5cbiAgY29uc3QgY2FwdHVyZVBheW1lbnQgPSB7XG4gICAgaWQ6IGBwYXlfJHtjcnlwdG8ucmFuZG9tVVVJRCgpfWAsXG4gICAgYm9va2luZ0lkOiBib29raW5nLmlkLFxuICAgIHR5cGU6IFwiY2FwdHVyZVwiIGFzIGNvbnN0LFxuICAgIGFtb3VudENlbnRzOiBjYXB0dXJlQW1vdW50LFxuICAgIHN0YXR1czogXCJjYXB0dXJlZFwiIGFzIGNvbnN0LFxuICAgIG9jY3VycmVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBub3RlczogXCJDYXB0dXJlZCBmcm9tIG1vbmV5IGJvYXJkXCJcbiAgfTtcblxuICBjb25zdCB1cGRhdGVkQm9va2luZzogRmFrZUJvb2tpbmcgPSB7XG4gICAgLi4uYm9va2luZyxcbiAgICBzdGF0dXM6IFwiY2FwdHVyZWRcIixcbiAgICByZXF1aXJlc0FjdGlvbjogZmFsc2UsXG4gICAgcGF5bWVudHM6IFsuLi5ib29raW5nLnBheW1lbnRzLCBjYXB0dXJlUGF5bWVudF0sXG4gICAgZmluYW5jaWFsczoge1xuICAgICAgLi4uYm9va2luZy5maW5hbmNpYWxzLFxuICAgICAgcGxhdGZvcm1GZWVDZW50czogcGxhdGZvcm1GZWUsXG4gICAgICBzdHJpcGVGZWVFc3RpbWF0ZUNlbnRzOiBzdHJpcGVGZWUsXG4gICAgICBuZXRQYXlvdXRDZW50czogTWF0aC5tYXgoY2FwdHVyZUFtb3VudCAtIHBsYXRmb3JtRmVlIC0gc3RyaXBlRmVlLCAwKVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGJvb2tpbmc6IHVwZGF0ZWRCb29raW5nLFxuICAgIHJlc3BvbnNlOiB7XG4gICAgICBib29raW5nOiB1cGRhdGVkQm9va2luZyxcbiAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICBtZXNzYWdlOiBcIkNhcHR1cmUgc3VjY2VlZGVkIOKAlCBmdW5kcyBlbiByb3V0ZSB0byB5b3VyIENvbm5lY3QgYWNjb3VudC5cIlxuICAgIH0sXG4gICAgc2hvdWxkUGVyc2lzdDogdHJ1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBub1Nob3dCb29raW5nKGJvb2tpbmc6IEZha2VCb29raW5nLCBwb2xpY2llczogUG9saWNpZXNDb25maWcpOiBBY3Rpb25SZXN1bHQge1xuICBjb25zdCBmZWUgPVxuICAgIHBvbGljaWVzLm5vU2hvd0ZlZVR5cGUgPT09IFwicGVyY2VudFwiXG4gICAgICA/IE1hdGgucm91bmQoKGJvb2tpbmcuZmluYW5jaWFscy5saXN0UHJpY2VDZW50cyAqIHBvbGljaWVzLm5vU2hvd0ZlZVZhbHVlKSAvIDEwMClcbiAgICAgIDogTWF0aC5yb3VuZChwb2xpY2llcy5ub1Nob3dGZWVWYWx1ZSAqIDEwMCk7XG5cbiAgaWYgKGZlZSA8PSAwKSB7XG4gICAgY29uc3QgdXBkYXRlZEJvb2tpbmc6IEZha2VCb29raW5nID0ge1xuICAgICAgLi4uYm9va2luZyxcbiAgICAgIHN0YXR1czogXCJub19zaG93XCIsXG4gICAgICBwYXltZW50czogYm9va2luZy5wYXltZW50cyxcbiAgICAgIGZpbmFuY2lhbHM6IHtcbiAgICAgICAgLi4uYm9va2luZy5maW5hbmNpYWxzLFxuICAgICAgICBwbGF0Zm9ybUZlZUNlbnRzOiAwLFxuICAgICAgICBzdHJpcGVGZWVFc3RpbWF0ZUNlbnRzOiAwLFxuICAgICAgICBuZXRQYXlvdXRDZW50czogMFxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGJvb2tpbmc6IHVwZGF0ZWRCb29raW5nLFxuICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgYm9va2luZzogdXBkYXRlZEJvb2tpbmcsXG4gICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICAgIG1lc3NhZ2U6IFwiTWFya2VkIGFzIG5vLXNob3cgd2l0aCBubyBjaGFyZ2UuXCJcbiAgICAgIH0sXG4gICAgICBzaG91bGRQZXJzaXN0OiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHBsYXRmb3JtRmVlID0gTWF0aC5yb3VuZChmZWUgKiAwLjAxKTtcbiAgY29uc3Qgc3RyaXBlRmVlID0gTWF0aC5yb3VuZChmZWUgKiAwLjAyOSkgKyAzMDtcblxuICBjb25zdCBmZWVQYXltZW50ID0ge1xuICAgIGlkOiBgcGF5XyR7Y3J5cHRvLnJhbmRvbVVVSUQoKX1gLFxuICAgIGJvb2tpbmdJZDogYm9va2luZy5pZCxcbiAgICB0eXBlOiBcIm5vX3Nob3dfZmVlXCIgYXMgY29uc3QsXG4gICAgYW1vdW50Q2VudHM6IGZlZSxcbiAgICBzdGF0dXM6IFwiY2FwdHVyZWRcIiBhcyBjb25zdCxcbiAgICBvY2N1cnJlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgbm90ZXM6IFwiTm8tc2hvdyBmZWUgY2hhcmdlZFwiXG4gIH07XG5cbiAgY29uc3QgdXBkYXRlZEJvb2tpbmc6IEZha2VCb29raW5nID0ge1xuICAgIC4uLmJvb2tpbmcsXG4gICAgc3RhdHVzOiBcIm5vX3Nob3dcIixcbiAgICByZXF1aXJlc0FjdGlvbjogZmFsc2UsXG4gICAgcGF5bWVudHM6IFsuLi5ib29raW5nLnBheW1lbnRzLCBmZWVQYXltZW50XSxcbiAgICBmaW5hbmNpYWxzOiB7XG4gICAgICAuLi5ib29raW5nLmZpbmFuY2lhbHMsXG4gICAgICBwbGF0Zm9ybUZlZUNlbnRzOiBwbGF0Zm9ybUZlZSxcbiAgICAgIHN0cmlwZUZlZUVzdGltYXRlQ2VudHM6IHN0cmlwZUZlZSxcbiAgICAgIG5ldFBheW91dENlbnRzOiBNYXRoLm1heChmZWUgLSBwbGF0Zm9ybUZlZSAtIHN0cmlwZUZlZSwgMClcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBib29raW5nOiB1cGRhdGVkQm9va2luZyxcbiAgICByZXNwb25zZToge1xuICAgICAgYm9va2luZzogdXBkYXRlZEJvb2tpbmcsXG4gICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiLFxuICAgICAgbWVzc2FnZTogXCJOby1zaG93IGZlZSBjYXB0dXJlZC5cIlxuICAgIH0sXG4gICAgc2hvdWxkUGVyc2lzdDogdHJ1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjYW5jZWxCb29raW5nKGJvb2tpbmc6IEZha2VCb29raW5nLCBwb2xpY2llczogUG9saWNpZXNDb25maWcpOiBBY3Rpb25SZXN1bHQge1xuICBjb25zdCBmZWUgPVxuICAgIHBvbGljaWVzLmNhbmNlbGxhdGlvbkZlZVR5cGUgPT09IFwicGVyY2VudFwiXG4gICAgICA/IE1hdGgucm91bmQoKGJvb2tpbmcuZmluYW5jaWFscy5saXN0UHJpY2VDZW50cyAqIHBvbGljaWVzLmNhbmNlbGxhdGlvbkZlZVZhbHVlKSAvIDEwMClcbiAgICAgIDogTWF0aC5yb3VuZChwb2xpY2llcy5jYW5jZWxsYXRpb25GZWVWYWx1ZSAqIDEwMCk7XG5cbiAgaWYgKGZlZSA8PSAwKSB7XG4gICAgY29uc3QgdXBkYXRlZEJvb2tpbmc6IEZha2VCb29raW5nID0ge1xuICAgICAgLi4uYm9va2luZyxcbiAgICAgIHN0YXR1czogXCJjYW5jZWxlZFwiLFxuICAgICAgcmVxdWlyZXNBY3Rpb246IGZhbHNlLFxuICAgICAgZmluYW5jaWFsczoge1xuICAgICAgICAuLi5ib29raW5nLmZpbmFuY2lhbHMsXG4gICAgICAgIHBsYXRmb3JtRmVlQ2VudHM6IDAsXG4gICAgICAgIHN0cmlwZUZlZUVzdGltYXRlQ2VudHM6IDAsXG4gICAgICAgIG5ldFBheW91dENlbnRzOiAwXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgYm9va2luZzogdXBkYXRlZEJvb2tpbmcsXG4gICAgICByZXNwb25zZToge1xuICAgICAgICBib29raW5nOiB1cGRhdGVkQm9va2luZyxcbiAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWVzc2FnZTogXCJCb29raW5nIGNhbmNlbGVkIHdpdGhvdXQgY2hhcmdlLlwiXG4gICAgICB9LFxuICAgICAgc2hvdWxkUGVyc2lzdDogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBjb25zdCBwbGF0Zm9ybUZlZSA9IE1hdGgucm91bmQoZmVlICogMC4wMSk7XG4gIGNvbnN0IHN0cmlwZUZlZSA9IE1hdGgucm91bmQoZmVlICogMC4wMjkpICsgMzA7XG5cbiAgY29uc3QgZmVlUGF5bWVudCA9IHtcbiAgICBpZDogYHBheV8ke2NyeXB0by5yYW5kb21VVUlEKCl9YCxcbiAgICBib29raW5nSWQ6IGJvb2tpbmcuaWQsXG4gICAgdHlwZTogXCJjYW5jZWxfZmVlXCIgYXMgY29uc3QsXG4gICAgYW1vdW50Q2VudHM6IGZlZSxcbiAgICBzdGF0dXM6IFwiY2FwdHVyZWRcIiBhcyBjb25zdCxcbiAgICBvY2N1cnJlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgbm90ZXM6IFwiQ2FuY2VsbGF0aW9uIGZlZSBjaGFyZ2VkXCJcbiAgfTtcblxuICBjb25zdCB1cGRhdGVkQm9va2luZzogRmFrZUJvb2tpbmcgPSB7XG4gICAgLi4uYm9va2luZyxcbiAgICBzdGF0dXM6IFwiY2FuY2VsZWRcIixcbiAgICByZXF1aXJlc0FjdGlvbjogZmFsc2UsXG4gICAgcGF5bWVudHM6IFsuLi5ib29raW5nLnBheW1lbnRzLCBmZWVQYXltZW50XSxcbiAgICBmaW5hbmNpYWxzOiB7XG4gICAgICAuLi5ib29raW5nLmZpbmFuY2lhbHMsXG4gICAgICBwbGF0Zm9ybUZlZUNlbnRzOiBwbGF0Zm9ybUZlZSxcbiAgICAgIHN0cmlwZUZlZUVzdGltYXRlQ2VudHM6IHN0cmlwZUZlZSxcbiAgICAgIG5ldFBheW91dENlbnRzOiBNYXRoLm1heChmZWUgLSBwbGF0Zm9ybUZlZSAtIHN0cmlwZUZlZSwgMClcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBib29raW5nOiB1cGRhdGVkQm9va2luZyxcbiAgICByZXNwb25zZToge1xuICAgICAgYm9va2luZzogdXBkYXRlZEJvb2tpbmcsXG4gICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiLFxuICAgICAgbWVzc2FnZTogXCJDYW5jZWxsYXRpb24gZmVlIGNhcHR1cmVkLlwiXG4gICAgfSxcbiAgICBzaG91bGRQZXJzaXN0OiB0cnVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlZnVuZEJvb2tpbmcoYm9va2luZzogRmFrZUJvb2tpbmcsIGdpZnRDYXJkczogR2lmdENhcmRQcm9ncmFtU3RhdGUpOiBBY3Rpb25SZXN1bHQge1xuICBjb25zdCBjYXB0dXJlZEFtb3VudCA9IGJvb2tpbmcucGF5bWVudHNcbiAgICAuZmlsdGVyKChwYXltZW50KSA9PiBwYXltZW50LnR5cGUgIT09IFwiYXV0aG9yaXphdGlvblwiICYmIHBheW1lbnQuc3RhdHVzID09PSBcImNhcHR1cmVkXCIpXG4gICAgLnJlZHVjZSgoc3VtLCBwYXltZW50KSA9PiBzdW0gKyBwYXltZW50LmFtb3VudENlbnRzLCAwKTtcblxuICBpZiAoY2FwdHVyZWRBbW91bnQgPD0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBib29raW5nLFxuICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgYm9va2luZyxcbiAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWVzc2FnZTogXCJObyBwYXltZW50IHRvIHJlZnVuZC5cIlxuICAgICAgfSxcbiAgICAgIHNob3VsZFBlcnNpc3Q6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHJlZnVuZFBheW1lbnQgPSB7XG4gICAgaWQ6IGBwYXlfJHtjcnlwdG8ucmFuZG9tVVVJRCgpfWAsXG4gICAgYm9va2luZ0lkOiBib29raW5nLmlkLFxuICAgIHR5cGU6IFwicmVmdW5kXCIgYXMgY29uc3QsXG4gICAgYW1vdW50Q2VudHM6IGNhcHR1cmVkQW1vdW50LFxuICAgIHN0YXR1czogXCJyZWZ1bmRlZFwiIGFzIGNvbnN0LFxuICAgIG9jY3VycmVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBub3RlczogXCJSZWZ1bmQgcHJvY2Vzc2VkIGZyb20gYWRtaW5cIlxuICB9O1xuXG4gIGNvbnN0IHVwZGF0ZWRCb29raW5nOiBGYWtlQm9va2luZyA9IHtcbiAgICAuLi5ib29raW5nLFxuICAgIHN0YXR1czogXCJyZWZ1bmRlZFwiLFxuICAgIHJlcXVpcmVzQWN0aW9uOiBmYWxzZSxcbiAgICBwYXltZW50czogWy4uLmJvb2tpbmcucGF5bWVudHMsIHJlZnVuZFBheW1lbnRdLFxuICAgIGZpbmFuY2lhbHM6IHtcbiAgICAgIC4uLmJvb2tpbmcuZmluYW5jaWFscyxcbiAgICAgIHBsYXRmb3JtRmVlQ2VudHM6IDAsXG4gICAgICBzdHJpcGVGZWVFc3RpbWF0ZUNlbnRzOiAwLFxuICAgICAgbmV0UGF5b3V0Q2VudHM6IDBcbiAgICB9XG4gIH07XG5cbiAgbGV0IHVwZGF0ZWRHaWZ0Q2FyZHM6IEdpZnRDYXJkUHJvZ3JhbVN0YXRlIHwgdW5kZWZpbmVkO1xuICBpZiAoXG4gICAgZ2lmdENhcmRzLmNvbmZpZy5lbmFibGVkICYmXG4gICAgZ2lmdENhcmRzLnJlc3RvcmVCYWxhbmNlT25SZWZ1bmQgJiZcbiAgICBib29raW5nLmZpbmFuY2lhbHMuZ2lmdENhcmRBbW91bnRDZW50cyA+IDBcbiAgKSB7XG4gICAgY29uc3QgcmVzdG9yZUVudHJ5ID0ge1xuICAgICAgaWQ6IGBnY2xfJHtjcnlwdG8ucmFuZG9tVVVJRCgpfWAsXG4gICAgICBjb2RlOiBnaWZ0Q2FyZHMuY29uZmlnLmdlbmVyYXRlZENvZGVzWzBdID8/IFwiV0VMQ09NRTEyMFwiLFxuICAgICAgYm9va2luZ0NvZGU6IGJvb2tpbmcuY29kZSxcbiAgICAgIGRlbHRhQ2VudHM6IGJvb2tpbmcuZmluYW5jaWFscy5naWZ0Q2FyZEFtb3VudENlbnRzLFxuICAgICAgYmFsYW5jZUFmdGVyQ2VudHM6XG4gICAgICAgIChnaWZ0Q2FyZHMubGVkZ2VyWzBdPy5iYWxhbmNlQWZ0ZXJDZW50cyA/PyAwKSArIGJvb2tpbmcuZmluYW5jaWFscy5naWZ0Q2FyZEFtb3VudENlbnRzLFxuICAgICAgb2NjdXJyZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgcmVhc29uOiBcInJlZnVuZGVkXCIgYXMgY29uc3RcbiAgICB9O1xuICAgIHVwZGF0ZWRHaWZ0Q2FyZHMgPSB7XG4gICAgICAuLi5naWZ0Q2FyZHMsXG4gICAgICBsZWRnZXI6IFsuLi5naWZ0Q2FyZHMubGVkZ2VyLCByZXN0b3JlRW50cnldXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYm9va2luZzogdXBkYXRlZEJvb2tpbmcsXG4gICAgcmVzcG9uc2U6IHtcbiAgICAgIGJvb2tpbmc6IHVwZGF0ZWRCb29raW5nLFxuICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgIG1lc3NhZ2U6IFwiUmVmdW5kIGlzc3VlZC4gR2lmdCBjYXJkIGJhbGFuY2UgcmVzdG9yZWQgaWYgYXBwbGljYWJsZS5cIlxuICAgIH0sXG4gICAgc2hvdWxkUGVyc2lzdDogdHJ1ZSxcbiAgICBnaWZ0Q2FyZHM6IHVwZGF0ZWRHaWZ0Q2FyZHNcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsIkRFVl9XT1JLU1BBQ0VfU0VFRCIsImNyZWF0ZVdvcmtzcGFjZUZyb21PbmJvYXJkaW5nIiwiZGVyaXZlQ3VzdG9tZXJzRnJvbUJvb2tpbmdzIiwicmVjb21wdXRlQW5hbHl0aWNzIiwiRmFrZUJ1c2luZXNzQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1bmRlZmluZWQiLCJGYWtlQnVzaW5lc3NQcm92aWRlciIsImNoaWxkcmVuIiwiYnVzaW5lc3MiLCJzZXRCdXNpbmVzcyIsInVzZVN0YXRlIiwid29ya3NwYWNlIiwic2V0V29ya3NwYWNlIiwiaGFzSHlkcmF0ZWRGcm9tU3RvcmFnZSIsInNldEhhc0h5ZHJhdGVkRnJvbVN0b3JhZ2UiLCJ1c2VFZmZlY3QiLCJjaGVja1VzZXJBbmRMb2FkIiwic2Vzc2lvbiIsImNyZWF0ZUNsaWVudENsaWVudCIsInN1cGFiYXNlIiwiZGF0YSIsImF1dGgiLCJnZXRTZXNzaW9uIiwidXNlciIsImlkIiwiY29uc29sZSIsImxvZyIsImVycm9yIiwid2FybiIsImNyZWF0ZUJ1c2luZXNzIiwidXNlQ2FsbGJhY2siLCJwYXlsb2FkIiwidXBkYXRlQnVzaW5lc3MiLCJ1cGRhdGVzIiwiZXhpc3RpbmciLCJib290c3RyYXBXb3Jrc3BhY2UiLCJzZWVkIiwid29ya3NwYWNlU25hcHNob3QiLCJ1cGRhdGVXb3Jrc3BhY2UiLCJ1cGRhdGVyIiwidXBkYXRlZCIsInNldENhdGFsb2ciLCJjYXRhbG9nIiwiYXZhaWxhYmlsaXR5VGVtcGxhdGVzIiwibWFwIiwidGVtcGxhdGUiLCJzZXJ2aWNlIiwiZmxhdE1hcCIsImNhdGVnb3J5Iiwic2VydmljZXMiLCJmaW5kIiwic2VydmljZUlkIiwic2VydmljZU5hbWUiLCJuYW1lIiwiYXZhaWxhYmlsaXR5IiwiZW50cnkiLCJzdmMiLCJhc3NpZ25lZElkcyIsIlNldCIsInN0YWZmSWRzIiwiZmlsdGVyZWRTdGFmZiIsInN0YWZmIiwiZmlsdGVyIiwic2xvdCIsImhhcyIsInN0YWZmSWQiLCJtaXNzaW5nU3RhZmYiLCJzb21lIiwic2xvdHMiLCJzZXRTdGFmZiIsInN0YWZmQXNzaWdubWVudHMiLCJhc3NpZ25tZW50IiwibWVtYmVyIiwic3RhZmZNZW1iZXIiLCJzdGFmZk5hbWUiLCJzZXRBdmFpbGFiaWxpdHkiLCJidWlsZFRlbXBsYXRlc0Zyb21BdmFpbGFiaWxpdHkiLCJzZXROb3RpZmljYXRpb25zIiwidGVtcGxhdGVzIiwibm90aWZpY2F0aW9ucyIsInNldFBvbGljaWVzIiwicG9saWNpZXMiLCJzZXRHaWZ0Q2FyZHMiLCJwcm9ncmFtIiwiZ2lmdENhcmRzIiwic2V0UGF5bWVudCIsInBheW1lbnQiLCJzZXRJZGVudGl0eSIsImlkZW50aXR5IiwicGVyZm9ybUJvb2tpbmdBY3Rpb24iLCJib29raW5nSWQiLCJhY3Rpb24iLCJyZXNwb25zZSIsImluZGV4IiwiYm9va2luZ3MiLCJmaW5kSW5kZXgiLCJib29raW5nIiwidGFyZ2V0Qm9va2luZyIsImFjdGlvblJlc3VsdCIsImFwcGx5TW9uZXlCb2FyZEFjdGlvbiIsInNob3VsZFBlcnNpc3QiLCJ1cGRhdGVkQm9va2luZ3MiLCJ1cGRhdGVkV29ya3NwYWNlIiwiY3VzdG9tZXJzIiwiYW5hbHl0aWNzIiwicmVjb3JkUHVibGljQm9va2luZyIsImNyZWF0ZWRCb29raW5nIiwicmVzdWx0IiwiY3JlYXRlQm9va2luZ0Zyb21QdWJsaWNGbG93IiwiY29weUF2YWlsYWJpbGl0eVRlbXBsYXRlIiwidGVtcGxhdGVJZCIsImF2YWlsYWJpbGl0eUNsaXBib2FyZCIsInBhc3RlQXZhaWxhYmlsaXR5VGVtcGxhdGUiLCJjbGlwYm9hcmQiLCJuZXdBdmFpbGFiaWxpdHkiLCJuZXdUZW1wbGF0ZXMiLCJjbGVhckF2YWlsYWJpbGl0eUNsaXBib2FyZCIsInJlZnJlc2hBbmFseXRpY3MiLCJsb2FkU2VlZEJ1c2luZXNzIiwib3ZlcnJpZGVzIiwic2x1ZyIsIndlYnNpdGUiLCJzdWJkb21haW4iLCJ0b0xvd2VyQ2FzZSIsImJvb2tpbmdVcmwiLCJwcmV2aWV3VXJsIiwiYnVzaW5lc3NQYXlsb2FkIiwiYnVzaW5lc3NOYW1lIiwic3RhdHVzIiwic3Vic2NyaXB0aW9uU3RhdHVzIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidHJpYWxFbmRzQXQiLCJuZXh0QmlsbERhdGUiLCJyZXNvbHZlZEJ1c2luZXNzIiwicmVzb2x2ZWRXb3Jrc3BhY2UiLCJjbGVhckJ1c2luZXNzIiwidmFsdWUiLCJ1c2VNZW1vIiwiUHJvdmlkZXIiLCJ1c2VGYWtlQnVzaW5lc3MiLCJjb250ZXh0IiwidXNlQ29udGV4dCIsIkVycm9yIiwic2VydmljZVJlc3VsdCIsImZpbmRTZXJ2aWNlSW5DYXRhbG9nIiwibGlzdFByaWNlQ2VudHMiLCJNYXRoIiwibWF4IiwicHJpY2VDZW50cyIsInJlcXVlc3RlZEdpZnRDYXJkQ2VudHMiLCJnaWZ0Q2FyZCIsImFtb3VudENlbnRzIiwiZ2lmdENhcmRBbW91bnRDZW50cyIsIm1pbiIsImF1dGhvcml6YXRpb25BbW91bnRDZW50cyIsIm5vcm1hbGl6ZWRFbWFpbCIsIm5vcm1hbGl6ZUVtYWlsIiwiY3VzdG9tZXIiLCJlbWFpbCIsIm5vcm1hbGl6ZWRQaG9uZSIsInBob25lIiwibm9ybWFsaXplUGhvbmUiLCJleGlzdGluZ0N1c3RvbWVyIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsImNvbnNlbnQiLCJhY2NlcHRlZEF0IiwiYm9va2luZ0NvZGUiLCJnZW5lcmF0ZUJvb2tpbmdDb2RlIiwiY29kZSIsImF1dGhvcml6YXRpb25QYXltZW50IiwidHlwZSIsInJlcXVpcmVzQWN0aW9uIiwib2NjdXJyZWRBdCIsInN0YXJ0RGF0ZVRpbWUiLCJub3RlcyIsImNhdGVnb3J5TmFtZSIsImR1cmF0aW9uTWludXRlcyIsImVuZERhdGVUaW1lIiwiY29sb3IiLCJwYXltZW50cyIsImZpbmFuY2lhbHMiLCJwbGF0Zm9ybUZlZUNlbnRzIiwic3RyaXBlRmVlRXN0aW1hdGVDZW50cyIsIm5ldFBheW91dENlbnRzIiwiY3VycmVuY3kiLCJwb2xpY3lDb25zZW50IiwiQm9vbGVhbiIsInVwZGF0ZWRDdXN0b21lcnMiLCJ1cGRhdGVkQW5hbHl0aWNzIiwidXBkYXRlZEdpZnRDYXJkcyIsImFwcGx5R2lmdENhcmRSZWRlbXB0aW9uIiwicmVkZW1wdGlvbkFtb3VudENlbnRzIiwibGVkZ2VyRm9yQ29kZSIsImNvbmZpZyIsImVuYWJsZWQiLCJ0b1VwcGVyQ2FzZSIsImxlZGdlciIsImxhc3RCYWxhbmNlIiwiYXQiLCJiYWxhbmNlQWZ0ZXJDZW50cyIsImFtb3VudFR5cGUiLCJhbW91bnRWYWx1ZSIsIm5leHRCYWxhbmNlIiwibGVkZ2VyRW50cnkiLCJkZWx0YUNlbnRzIiwicmVhc29uIiwiZ2VuZXJhdGVkQ29kZXMiLCJBcnJheSIsImZyb20iLCJleGlzdGluZ0NvZGVzIiwicHJlZml4IiwiY3JlYXRlQm9va2luZ1ByZWZpeCIsInllYXIiLCJnZXRGdWxsWWVhciIsImF0dGVtcHQiLCJzZXF1ZW5jZSIsImZsb29yIiwicmFuZG9tIiwiaW5jbHVkZXMiLCJzYW5pdGl6ZWQiLCJyZXBsYWNlIiwic2xpY2UiLCJwYWRFbmQiLCJ0cmltIiwibGFiZWwiLCJjb21wbGV0ZUJvb2tpbmciLCJub1Nob3dCb29raW5nIiwiY2FuY2VsQm9va2luZyIsInJlZnVuZEJvb2tpbmciLCJtZXNzYWdlIiwicGF5TGlua1VybCIsImhhc0NhcHR1cmUiLCJjYXB0dXJlQW1vdW50IiwicGxhdGZvcm1GZWUiLCJyb3VuZCIsInN0cmlwZUZlZSIsImNhcHR1cmVQYXltZW50IiwidXBkYXRlZEJvb2tpbmciLCJmZWUiLCJub1Nob3dGZWVUeXBlIiwibm9TaG93RmVlVmFsdWUiLCJmZWVQYXltZW50IiwiY2FuY2VsbGF0aW9uRmVlVHlwZSIsImNhbmNlbGxhdGlvbkZlZVZhbHVlIiwiY2FwdHVyZWRBbW91bnQiLCJyZWR1Y2UiLCJzdW0iLCJyZWZ1bmRQYXltZW50IiwicmVzdG9yZUJhbGFuY2VPblJlZnVuZCIsInJlc3RvcmVFbnRyeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/fake-business.tsx\n"));

/***/ })

});