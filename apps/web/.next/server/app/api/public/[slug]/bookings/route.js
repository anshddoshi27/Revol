"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/public/[slug]/bookings/route";
exports.ids = ["app/api/public/[slug]/bookings/route"];
exports.modules = {

/***/ "../../client/components/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/client/components/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/action-async-storage.external.js");

/***/ }),

/***/ "../../client/components/request-async-storage.external":
/*!********************************************************************************!*\
  !*** external "next/dist/client/components/request-async-storage.external.js" ***!
  \********************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/request-async-storage.external.js");

/***/ }),

/***/ "../../client/components/static-generation-async-storage.external":
/*!******************************************************************************************!*\
  !*** external "next/dist/client/components/static-generation-async-storage.external.js" ***!
  \******************************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/static-generation-async-storage.external.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute&page=%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute.ts&appDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute&page=%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute.ts&appDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_3017387smacbookm_Downloads_Career_Tithi_apps_web_src_app_api_public_slug_bookings_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/public/[slug]/bookings/route.ts */ \"(rsc)/./src/app/api/public/[slug]/bookings/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/public/[slug]/bookings/route\",\n        pathname: \"/api/public/[slug]/bookings\",\n        filename: \"route\",\n        bundlePath: \"app/api/public/[slug]/bookings/route\"\n    },\n    resolvedPagePath: \"/Users/3017387smacbookm/Downloads/Career/Tithi/apps/web/src/app/api/public/[slug]/bookings/route.ts\",\n    nextConfigOutput,\n    userland: _Users_3017387smacbookm_Downloads_Career_Tithi_apps_web_src_app_api_public_slug_bookings_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/public/[slug]/bookings/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZwdWJsaWMlMkYlNUJzbHVnJTVEJTJGYm9va2luZ3MlMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRnB1YmxpYyUyRiU1QnNsdWclNUQlMkZib29raW5ncyUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRnB1YmxpYyUyRiU1QnNsdWclNUQlMkZib29raW5ncyUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRjMwMTczODdzbWFjYm9va20lMkZEb3dubG9hZHMlMkZDYXJlZXIlMkZUaXRoaSUyRmFwcHMlMkZ3ZWIlMkZzcmMlMkZhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPSUyRlVzZXJzJTJGMzAxNzM4N3NtYWNib29rbSUyRkRvd25sb2FkcyUyRkNhcmVlciUyRlRpdGhpJTJGYXBwcyUyRndlYiZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD0mcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ2M7QUFDbUQ7QUFDaEk7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdIQUFtQjtBQUMzQztBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVk7QUFDWixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBaUU7QUFDekU7QUFDQTtBQUNBLFdBQVcsNEVBQVc7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUN1SDs7QUFFdkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvPzgzMTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiL1VzZXJzLzMwMTczODdzbWFjYm9va20vRG93bmxvYWRzL0NhcmVlci9UaXRoaS9hcHBzL3dlYi9zcmMvYXBwL2FwaS9wdWJsaWMvW3NsdWddL2Jvb2tpbmdzL3JvdXRlLnRzXCI7XG4vLyBXZSBpbmplY3QgdGhlIG5leHRDb25maWdPdXRwdXQgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IG5leHRDb25maWdPdXRwdXQgPSBcIlwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9wdWJsaWMvW3NsdWddL2Jvb2tpbmdzL3JvdXRlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvcHVibGljL1tzbHVnXS9ib29raW5nc1wiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvcHVibGljL1tzbHVnXS9ib29raW5ncy9yb3V0ZVwiXG4gICAgfSxcbiAgICByZXNvbHZlZFBhZ2VQYXRoOiBcIi9Vc2Vycy8zMDE3Mzg3c21hY2Jvb2ttL0Rvd25sb2Fkcy9DYXJlZXIvVGl0aGkvYXBwcy93ZWIvc3JjL2FwcC9hcGkvcHVibGljL1tzbHVnXS9ib29raW5ncy9yb3V0ZS50c1wiLFxuICAgIG5leHRDb25maWdPdXRwdXQsXG4gICAgdXNlcmxhbmRcbn0pO1xuLy8gUHVsbCBvdXQgdGhlIGV4cG9ydHMgdGhhdCB3ZSBuZWVkIHRvIGV4cG9zZSBmcm9tIHRoZSBtb2R1bGUuIFRoaXMgc2hvdWxkXG4vLyBiZSBlbGltaW5hdGVkIHdoZW4gd2UndmUgbW92ZWQgdGhlIG90aGVyIHJvdXRlcyB0byB0aGUgbmV3IGZvcm1hdC4gVGhlc2Vcbi8vIGFyZSB1c2VkIHRvIGhvb2sgaW50byB0aGUgcm91dGUuXG5jb25zdCB7IHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmNvbnN0IG9yaWdpbmFsUGF0aG5hbWUgPSBcIi9hcGkvcHVibGljL1tzbHVnXS9ib29raW5ncy9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute&page=%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute.ts&appDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./src/app/api/public/[slug]/bookings/route.ts":
/*!*****************************************************!*\
  !*** ./src/app/api/public/[slug]/bookings/route.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/db */ \"(rsc)/./src/lib/db.ts\");\n/* harmony import */ var _lib_stripe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/stripe */ \"(rsc)/./src/lib/stripe.ts\");\n/* harmony import */ var _lib_notifications__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/notifications */ \"(rsc)/./src/lib/notifications.ts\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n/**\n * POST /api/public/{slug}/bookings\n * \n * Creates a new booking with card setup (no charge yet)\n * No authentication required - this is a public endpoint\n * \n * Body: {\n *   service_id: string\n *   staff_id: string\n *   start_at: string (ISO timestamp)\n *   customer: { name, email, phone }\n *   gift_card_code?: string\n *   consent_ip?: string\n *   consent_user_agent?: string\n * }\n */ async function POST(request, { params }) {\n    try {\n        const { slug } = params;\n        const body = await request.json();\n        const { service_id, staff_id, start_at, customer, gift_card_code } = body;\n        // Extract consent metadata from headers (for production compliance)\n        const consent_ip = request.headers.get(\"x-forwarded-for\")?.split(\",\")[0]?.trim() || request.headers.get(\"x-real-ip\") || null;\n        const consent_user_agent = request.headers.get(\"user-agent\") || null;\n        if (!slug) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Subdomain is required\"\n            }, {\n                status: 400\n            });\n        }\n        // Validate required fields\n        if (!service_id || !staff_id || !start_at || !customer) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Missing required fields: service_id, staff_id, start_at, customer\"\n            }, {\n                status: 400\n            });\n        }\n        if (!customer.name || !customer.email) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Customer name and email are required\"\n            }, {\n                status: 400\n            });\n        }\n        const supabase = (0,_lib_db__WEBPACK_IMPORTED_MODULE_1__.createAdminClient)();\n        // Get business by subdomain (only active or trial businesses can accept bookings)\n        const { data: business, error: businessError } = await supabase.from(\"businesses\").select(\"*\").eq(\"subdomain\", slug.toLowerCase()).in(\"subscription_status\", [\n            \"active\",\n            \"trial\"\n        ]).is(\"deleted_at\", null).single();\n        if (businessError || !business) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Business not found\"\n            }, {\n                status: 404\n            });\n        }\n        // Get service details\n        const { data: service, error: serviceError } = await supabase.from(\"services\").select(\"*\").eq(\"id\", service_id).eq(\"business_id\", business.id).eq(\"is_active\", true).is(\"deleted_at\", null).single();\n        if (serviceError || !service) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Service not found\"\n            }, {\n                status: 404\n            });\n        }\n        // Validate slot is still available (check unique constraint)\n        const startAtDate = new Date(start_at);\n        const endAtDate = new Date(startAtDate.getTime() + service.duration_min * 60 * 1000);\n        // Check for existing bookings that overlap with this time slot\n        const { data: existingBookings, error: bookingCheckError } = await supabase.from(\"bookings\").select(\"id, start_at, end_at\").eq(\"staff_id\", staff_id).eq(\"business_id\", business.id).in(\"status\", [\n            \"pending\",\n            \"scheduled\",\n            \"held\"\n        ]).is(\"deleted_at\", null);\n        if (bookingCheckError) {\n            console.error(\"Error checking existing bookings:\", bookingCheckError);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Failed to validate slot availability\"\n            }, {\n                status: 500\n            });\n        }\n        // Check if any existing booking overlaps with the requested slot\n        const hasOverlap = existingBookings?.some((booking)=>{\n            const bookingStart = new Date(booking.start_at);\n            const bookingEnd = new Date(booking.end_at || booking.start_at);\n            // Check if time ranges overlap\n            return startAtDate < bookingEnd && endAtDate > bookingStart;\n        });\n        if (hasOverlap) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"This time slot is no longer available\"\n            }, {\n                status: 409\n            });\n        }\n        // Validate gift card if provided\n        let final_price_cents = service.price_cents;\n        let gift_card_id = null;\n        let gift_card_amount_applied_cents = 0;\n        if (gift_card_code) {\n            const { data: giftCard, error: giftCardError } = await supabase.from(\"gift_cards\").select(\"*\").eq(\"user_id\", business.user_id).eq(\"business_id\", business.id).eq(\"code\", gift_card_code.toUpperCase().trim()).eq(\"is_active\", true).is(\"deleted_at\", null).single();\n            if (giftCardError || !giftCard) {\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Invalid gift card code\"\n                }, {\n                    status: 400\n                });\n            }\n            // Check expiration\n            if (giftCard.expires_at && new Date(giftCard.expires_at) < new Date()) {\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Gift card has expired\"\n                }, {\n                    status: 400\n                });\n            }\n            gift_card_id = giftCard.id;\n            // Calculate discount\n            if (giftCard.discount_type === \"amount\") {\n                // For amount-type gift cards, calculate remaining balance\n                // by subtracting amounts already applied in pending/completed bookings\n                const { data: existingBookings } = await supabase.from(\"bookings\").select(\"gift_card_amount_applied_cents, status\").eq(\"gift_card_id\", giftCard.id).in(\"status\", [\n                    \"pending\",\n                    \"scheduled\",\n                    \"completed\",\n                    \"held\"\n                ]).is(\"deleted_at\", null);\n                // Sum up amounts already applied in pending/completed bookings\n                const alreadyAppliedCents = existingBookings?.reduce((sum, booking)=>{\n                    return sum + (booking.gift_card_amount_applied_cents || 0);\n                }, 0) || 0;\n                // Calculate remaining available balance\n                const remainingBalanceCents = Math.max(0, giftCard.current_balance_cents - alreadyAppliedCents);\n                // Check if there's any remaining balance\n                if (remainingBalanceCents <= 0) {\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                        error: \"Gift card has no remaining balance\"\n                    }, {\n                        status: 400\n                    });\n                }\n                // Apply only the remaining balance (not the full current_balance_cents)\n                gift_card_amount_applied_cents = Math.min(remainingBalanceCents, service.price_cents);\n                final_price_cents = service.price_cents - gift_card_amount_applied_cents;\n            } else if (giftCard.discount_type === \"percent\") {\n                const percentOff = giftCard.percent_off || 0;\n                if (percentOff <= 0 || percentOff > 100) {\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                        error: \"Invalid gift card discount percentage\"\n                    }, {\n                        status: 400\n                    });\n                }\n                gift_card_amount_applied_cents = Math.round(service.price_cents * percentOff / 100);\n                final_price_cents = service.price_cents - gift_card_amount_applied_cents;\n            }\n            if (final_price_cents < 0) {\n                final_price_cents = 0;\n                gift_card_amount_applied_cents = service.price_cents;\n            }\n        }\n        // Get current active policy and create snapshot\n        const { data: policy, error: policyError } = await supabase.from(\"business_policies\").select(\"*\").eq(\"business_id\", business.id).eq(\"is_active\", true).order(\"version\", {\n            ascending: false\n        }).limit(1).maybeSingle();\n        if (policyError) {\n            console.error(\"Error fetching business policies:\", policyError);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Failed to fetch business policies\",\n                details: policyError.message\n            }, {\n                status: 500\n            });\n        }\n        if (!policy) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Business policies not found\"\n            }, {\n                status: 500\n            });\n        }\n        // Create policy snapshot with all required fields\n        const policySnapshot = {\n            cancellation_policy_text: policy.cancellation_policy_text,\n            no_show_policy_text: policy.no_show_policy_text,\n            refund_policy_text: policy.refund_policy_text,\n            cash_policy_text: policy.cash_policy_text,\n            no_show_fee_type: policy.no_show_fee_type,\n            no_show_fee_amount_cents: policy.no_show_fee_amount_cents,\n            no_show_fee_percent: policy.no_show_fee_percent,\n            cancel_fee_type: policy.cancel_fee_type,\n            cancel_fee_amount_cents: policy.cancel_fee_amount_cents,\n            cancel_fee_percent: policy.cancel_fee_percent,\n            version: policy.version,\n            snapshot_at: new Date().toISOString()\n        };\n        // Calculate policy hash for compliance (SHA-256 of policy snapshot)\n        const policyHash = (0,crypto__WEBPACK_IMPORTED_MODULE_4__.createHash)(\"sha256\").update(JSON.stringify(policySnapshot)).digest(\"hex\");\n        // Create or find customer\n        let customerId;\n        let stripeCustomerId;\n        const { data: existingCustomer } = await supabase.from(\"customers\").select(\"id, stripe_customer_id\").eq(\"business_id\", business.id).eq(\"email\", customer.email.toLowerCase().trim()).single();\n        if (existingCustomer) {\n            customerId = existingCustomer.id;\n            // Update customer info if needed\n            const updateData = {\n                name: customer.name,\n                updated_at: new Date().toISOString()\n            };\n            if (customer.phone) {\n                updateData.phone = customer.phone;\n            }\n            await supabase.from(\"customers\").update(updateData).eq(\"id\", customerId);\n            // Get or create Stripe Customer ID\n            if (existingCustomer.stripe_customer_id) {\n                stripeCustomerId = existingCustomer.stripe_customer_id;\n            } else {\n                stripeCustomerId = await (0,_lib_stripe__WEBPACK_IMPORTED_MODULE_2__.createOrGetCustomer)(customer.email.toLowerCase().trim(), customer.name, {\n                    business_id: business.id\n                });\n                await supabase.from(\"customers\").update({\n                    stripe_customer_id: stripeCustomerId\n                }).eq(\"id\", customerId);\n            }\n        } else {\n            // Create Stripe Customer first\n            stripeCustomerId = await (0,_lib_stripe__WEBPACK_IMPORTED_MODULE_2__.createOrGetCustomer)(customer.email.toLowerCase().trim(), customer.name, {\n                business_id: business.id\n            });\n            // Create customer record\n            const { data: newCustomer, error: customerError } = await supabase.from(\"customers\").insert({\n                user_id: business.user_id,\n                business_id: business.id,\n                name: customer.name,\n                email: customer.email.toLowerCase().trim(),\n                phone: customer.phone || null,\n                stripe_customer_id: stripeCustomerId,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            }).select(\"id\").single();\n            if (customerError || !newCustomer) {\n                console.error(\"Error creating customer:\", customerError);\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    error: \"Failed to create customer\",\n                    details: customerError?.message\n                }, {\n                    status: 500\n                });\n            }\n            customerId = newCustomer.id;\n        }\n        // Create booking\n        const { data: booking, error: bookingError } = await supabase.from(\"bookings\").insert({\n            user_id: business.user_id,\n            business_id: business.id,\n            customer_id: customerId,\n            service_id,\n            staff_id,\n            status: \"pending\",\n            start_at: start_at,\n            end_at: endAtDate.toISOString(),\n            duration_min: service.duration_min,\n            price_cents: service.price_cents,\n            final_price_cents,\n            gift_card_id,\n            gift_card_amount_applied_cents,\n            source: \"public\",\n            policy_snapshot: policySnapshot,\n            // policy_hash: policyHash, // Column doesn't exist in schema - removed\n            consent_at: new Date().toISOString(),\n            consent_ip: consent_ip || null,\n            consent_user_agent: consent_user_agent || null,\n            payment_status: \"none\",\n            last_money_action: \"none\",\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString()\n        }).select(\"id\").single();\n        if (bookingError || !booking) {\n            console.error(\"Error creating booking:\", bookingError);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Failed to create booking\",\n                details: bookingError?.message\n            }, {\n                status: 500\n            });\n        }\n        // Create SetupIntent to save card (must use Stripe Customer ID, not email)\n        if (!stripeCustomerId) {\n            console.error(\"No Stripe customer ID available for SetupIntent\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Failed to set up payment method\"\n            }, {\n                status: 500\n            });\n        }\n        const setupIntent = await (0,_lib_stripe__WEBPACK_IMPORTED_MODULE_2__.createSetupIntent)(stripeCustomerId, {\n            booking_id: booking.id,\n            business_id: business.id\n        });\n        // Create booking payment record (status will be updated to 'card_saved' by webhook when SetupIntent succeeds)\n        const { error: paymentError } = await supabase.from(\"booking_payments\").insert({\n            user_id: business.user_id,\n            business_id: business.id,\n            booking_id: booking.id,\n            stripe_setup_intent_id: setupIntent.setupIntentId,\n            amount_cents: final_price_cents,\n            money_action: \"none\",\n            status: \"none\",\n            currency: \"usd\",\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString()\n        });\n        if (paymentError) {\n            console.error(\"Error creating booking payment:\", paymentError);\n        // Continue anyway - payment can be updated later\n        }\n        // Generate booking code (e.g., TITHI-1234)\n        const bookingCode = `TITHI-${booking.id.slice(0, 8).toUpperCase()}`;\n        // Emit booking_created notification (async, don't wait)\n        (0,_lib_notifications__WEBPACK_IMPORTED_MODULE_3__.emitNotification)(business.id, \"booking_created\", booking.id, supabase).catch((err)=>{\n            console.error(\"Error emitting booking_created notification:\", err);\n        // Don't fail the request if notification fails\n        });\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            booking_id: booking.id,\n            booking_code: bookingCode,\n            client_secret: setupIntent.clientSecret,\n            setup_intent_id: setupIntent.setupIntentId,\n            final_price_cents,\n            message: \"Booking created successfully. Please complete payment setup.\"\n        });\n    } catch (error) {\n        console.error(\"Error in public booking:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Internal server error\",\n            details: error instanceof Error ? error.message : \"Unknown error\"\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvYXBwL2FwaS9wdWJsaWMvW3NsdWddL2Jvb2tpbmdzL3JvdXRlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMkM7QUFDRTtBQUMwRDtBQUNoRDtBQUNuQjtBQUVwQzs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDTSxlQUFlTSxLQUNwQkMsT0FBZ0IsRUFDaEIsRUFBRUMsTUFBTSxFQUFnQztJQUV4QyxJQUFJO1FBQ0YsTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBR0Q7UUFDakIsTUFBTUUsT0FBTyxNQUFNSCxRQUFRSSxJQUFJO1FBQy9CLE1BQU0sRUFDSkMsVUFBVSxFQUNWQyxRQUFRLEVBQ1JDLFFBQVEsRUFDUkMsUUFBUSxFQUNSQyxjQUFjLEVBQ2YsR0FBR047UUFFSixvRUFBb0U7UUFDcEUsTUFBTU8sYUFBYVYsUUFBUVcsT0FBTyxDQUFDQyxHQUFHLENBQUMsb0JBQW9CQyxNQUFNLElBQUksQ0FBQyxFQUFFLEVBQUVDLFVBQ3hEZCxRQUFRVyxPQUFPLENBQUNDLEdBQUcsQ0FBQyxnQkFDcEI7UUFDbEIsTUFBTUcscUJBQXFCZixRQUFRVyxPQUFPLENBQUNDLEdBQUcsQ0FBQyxpQkFBaUI7UUFFaEUsSUFBSSxDQUFDVixNQUFNO1lBQ1QsT0FBT1QscURBQVlBLENBQUNXLElBQUksQ0FDdEI7Z0JBQUVZLE9BQU87WUFBd0IsR0FDakM7Z0JBQUVDLFFBQVE7WUFBSTtRQUVsQjtRQUVBLDJCQUEyQjtRQUMzQixJQUFJLENBQUNaLGNBQWMsQ0FBQ0MsWUFBWSxDQUFDQyxZQUFZLENBQUNDLFVBQVU7WUFDdEQsT0FBT2YscURBQVlBLENBQUNXLElBQUksQ0FDdEI7Z0JBQUVZLE9BQU87WUFBb0UsR0FDN0U7Z0JBQUVDLFFBQVE7WUFBSTtRQUVsQjtRQUVBLElBQUksQ0FBQ1QsU0FBU1UsSUFBSSxJQUFJLENBQUNWLFNBQVNXLEtBQUssRUFBRTtZQUNyQyxPQUFPMUIscURBQVlBLENBQUNXLElBQUksQ0FDdEI7Z0JBQUVZLE9BQU87WUFBdUMs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QUFLLENBQUMsR0FBRyxHQUFHckUsV0FBVyxHQUFHLENBQUM7UUFFbkUsd0RBQXdEO1FBQ3hEMUQsb0VBQWdCQSxDQUFDeUIsU0FBU1csRUFBRSxFQUFFLG1CQUFtQlcsUUFBUVgsRUFBRSxFQUFFYixVQUFVeUcsS0FBSyxDQUFDLENBQUNDO1lBQzVFckYsUUFBUXpCLEtBQUssQ0FBQyxnREFBZ0Q4RztRQUM5RCwrQ0FBK0M7UUFDakQ7UUFFQSxPQUFPckkscURBQVlBLENBQUNXLElBQUksQ0FBQztZQUN2QmdILFlBQVl4RSxRQUFRWCxFQUFFO1lBQ3RCOEYsY0FBY0o7WUFDZEssZUFBZWIsWUFBWWMsWUFBWTtZQUN2Q0MsaUJBQWlCZixZQUFZSSxhQUFhO1lBQzFDdkU7WUFDQTRCLFNBQVM7UUFDWDtJQUNGLEVBQUUsT0FBTzVELE9BQU87UUFDZHlCLFFBQVF6QixLQUFLLENBQUMsNEJBQTRCQTtRQUMxQyxPQUFPdkIscURBQVlBLENBQUNXLElBQUksQ0FDdEI7WUFBRVksT0FBTztZQUF5QjJELFNBQVMzRCxpQkFBaUJtSCxRQUFRbkgsTUFBTTRELE9BQU8sR0FBRztRQUFnQixHQUNwRztZQUFFM0QsUUFBUTtRQUFJO0lBRWxCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9zcmMvYXBwL2FwaS9wdWJsaWMvW3NsdWddL2Jvb2tpbmdzL3JvdXRlLnRzPzRkYmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuaW1wb3J0IHsgY3JlYXRlQWRtaW5DbGllbnQgfSBmcm9tICdAL2xpYi9kYic7XG5pbXBvcnQgeyBjcmVhdGVPckdldEN1c3RvbWVyLCBjcmVhdGVTZXR1cEludGVudCwgZ2V0UGF5bWVudE1ldGhvZEZyb21TZXR1cEludGVudCB9IGZyb20gJ0AvbGliL3N0cmlwZSc7XG5pbXBvcnQgeyBlbWl0Tm90aWZpY2F0aW9uIH0gZnJvbSAnQC9saWIvbm90aWZpY2F0aW9ucyc7XG5pbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSAnY3J5cHRvJztcblxuLyoqXG4gKiBQT1NUIC9hcGkvcHVibGljL3tzbHVnfS9ib29raW5nc1xuICogXG4gKiBDcmVhdGVzIGEgbmV3IGJvb2tpbmcgd2l0aCBjYXJkIHNldHVwIChubyBjaGFyZ2UgeWV0KVxuICogTm8gYXV0aGVudGljYXRpb24gcmVxdWlyZWQgLSB0aGlzIGlzIGEgcHVibGljIGVuZHBvaW50XG4gKiBcbiAqIEJvZHk6IHtcbiAqICAgc2VydmljZV9pZDogc3RyaW5nXG4gKiAgIHN0YWZmX2lkOiBzdHJpbmdcbiAqICAgc3RhcnRfYXQ6IHN0cmluZyAoSVNPIHRpbWVzdGFtcClcbiAqICAgY3VzdG9tZXI6IHsgbmFtZSwgZW1haWwsIHBob25lIH1cbiAqICAgZ2lmdF9jYXJkX2NvZGU/OiBzdHJpbmdcbiAqICAgY29uc2VudF9pcD86IHN0cmluZ1xuICogICBjb25zZW50X3VzZXJfYWdlbnQ/OiBzdHJpbmdcbiAqIH1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFBPU1QoXG4gIHJlcXVlc3Q6IFJlcXVlc3QsXG4gIHsgcGFyYW1zIH06IHsgcGFyYW1zOiB7IHNsdWc6IHN0cmluZyB9IH1cbikge1xuICB0cnkge1xuICAgIGNvbnN0IHsgc2x1ZyB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAgICBjb25zdCB7XG4gICAgICBzZXJ2aWNlX2lkLFxuICAgICAgc3RhZmZfaWQsXG4gICAgICBzdGFydF9hdCxcbiAgICAgIGN1c3RvbWVyLFxuICAgICAgZ2lmdF9jYXJkX2NvZGUsXG4gICAgfSA9IGJvZHk7XG5cbiAgICAvLyBFeHRyYWN0IGNvbnNlbnQgbWV0YWRhdGEgZnJvbSBoZWFkZXJzIChmb3IgcHJvZHVjdGlvbiBjb21wbGlhbmNlKVxuICAgIGNvbnN0IGNvbnNlbnRfaXAgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KCd4LWZvcndhcmRlZC1mb3InKT8uc3BsaXQoJywnKVswXT8udHJpbSgpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5nZXQoJ3gtcmVhbC1pcCcpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgY29uc3QgY29uc2VudF91c2VyX2FnZW50ID0gcmVxdWVzdC5oZWFkZXJzLmdldCgndXNlci1hZ2VudCcpIHx8IG51bGw7XG5cbiAgICBpZiAoIXNsdWcpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ1N1YmRvbWFpbiBpcyByZXF1aXJlZCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkc1xuICAgIGlmICghc2VydmljZV9pZCB8fCAhc3RhZmZfaWQgfHwgIXN0YXJ0X2F0IHx8ICFjdXN0b21lcikge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnTWlzc2luZyByZXF1aXJlZCBmaWVsZHM6IHNlcnZpY2VfaWQsIHN0YWZmX2lkLCBzdGFydF9hdCwgY3VzdG9tZXInIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWN1c3RvbWVyLm5hbWUgfHwgIWN1c3RvbWVyLmVtYWlsKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdDdXN0b21lciBuYW1lIGFuZCBlbWFpbCBhcmUgcmVxdWlyZWQnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUFkbWluQ2xpZW50KCk7XG5cbiAgICAvLyBHZXQgYnVzaW5lc3MgYnkgc3ViZG9tYWluIChvbmx5IGFjdGl2ZSBvciB0cmlhbCBidXNpbmVzc2VzIGNhbiBhY2NlcHQgYm9va2luZ3MpXG4gICAgY29uc3QgeyBkYXRhOiBidXNpbmVzcywgZXJyb3I6IGJ1c2luZXNzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYnVzaW5lc3NlcycpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgnc3ViZG9tYWluJywgc2x1Zy50b0xvd2VyQ2FzZSgpKVxuICAgICAgLmluKCdzdWJzY3JpcHRpb25fc3RhdHVzJywgWydhY3RpdmUnLCAndHJpYWwnXSlcbiAgICAgIC5pcygnZGVsZXRlZF9hdCcsIG51bGwpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoYnVzaW5lc3NFcnJvciB8fCAhYnVzaW5lc3MpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0J1c2luZXNzIG5vdCBmb3VuZCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwNCB9XG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEdldCBzZXJ2aWNlIGRldGFpbHNcbiAgICBjb25zdCB7IGRhdGE6IHNlcnZpY2UsIGVycm9yOiBzZXJ2aWNlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnc2VydmljZXMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2lkJywgc2VydmljZV9pZClcbiAgICAgIC5lcSgnYnVzaW5lc3NfaWQnLCBidXNpbmVzcy5pZClcbiAgICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcbiAgICAgIC5pcygnZGVsZXRlZF9hdCcsIG51bGwpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoc2VydmljZUVycm9yIHx8ICFzZXJ2aWNlKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdTZXJ2aWNlIG5vdCBmb3VuZCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwNCB9XG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHNsb3QgaXMgc3RpbGwgYXZhaWxhYmxlIChjaGVjayB1bmlxdWUgY29uc3RyYWludClcbiAgICBjb25zdCBzdGFydEF0RGF0ZSA9IG5ldyBEYXRlKHN0YXJ0X2F0KTtcbiAgICBjb25zdCBlbmRBdERhdGUgPSBuZXcgRGF0ZShzdGFydEF0RGF0ZS5nZXRUaW1lKCkgKyBzZXJ2aWNlLmR1cmF0aW9uX21pbiAqIDYwICogMTAwMCk7XG5cbiAgICAvLyBDaGVjayBmb3IgZXhpc3RpbmcgYm9va2luZ3MgdGhhdCBvdmVybGFwIHdpdGggdGhpcyB0aW1lIHNsb3RcbiAgICBjb25zdCB7IGRhdGE6IGV4aXN0aW5nQm9va2luZ3MsIGVycm9yOiBib29raW5nQ2hlY2tFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdib29raW5ncycpXG4gICAgICAuc2VsZWN0KCdpZCwgc3RhcnRfYXQsIGVuZF9hdCcpXG4gICAgICAuZXEoJ3N0YWZmX2lkJywgc3RhZmZfaWQpXG4gICAgICAuZXEoJ2J1c2luZXNzX2lkJywgYnVzaW5lc3MuaWQpXG4gICAgICAuaW4oJ3N0YXR1cycsIFsncGVuZGluZycsICdzY2hlZHVsZWQnLCAnaGVsZCddKVxuICAgICAgLmlzKCdkZWxldGVkX2F0JywgbnVsbCk7XG5cbiAgICBpZiAoYm9va2luZ0NoZWNrRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGV4aXN0aW5nIGJvb2tpbmdzOicsIGJvb2tpbmdDaGVja0Vycm9yKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0ZhaWxlZCB0byB2YWxpZGF0ZSBzbG90IGF2YWlsYWJpbGl0eScgfSxcbiAgICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFueSBleGlzdGluZyBib29raW5nIG92ZXJsYXBzIHdpdGggdGhlIHJlcXVlc3RlZCBzbG90XG4gICAgY29uc3QgaGFzT3ZlcmxhcCA9IGV4aXN0aW5nQm9va2luZ3M/LnNvbWUoYm9va2luZyA9PiB7XG4gICAgICBjb25zdCBib29raW5nU3RhcnQgPSBuZXcgRGF0ZShib29raW5nLnN0YXJ0X2F0KTtcbiAgICAgIGNvbnN0IGJvb2tpbmdFbmQgPSBuZXcgRGF0ZShib29raW5nLmVuZF9hdCB8fCBib29raW5nLnN0YXJ0X2F0KTtcbiAgICAgIC8vIENoZWNrIGlmIHRpbWUgcmFuZ2VzIG92ZXJsYXBcbiAgICAgIHJldHVybiBzdGFydEF0RGF0ZSA8IGJvb2tpbmdFbmQgJiYgZW5kQXREYXRlID4gYm9va2luZ1N0YXJ0O1xuICAgIH0pO1xuXG4gICAgaWYgKGhhc092ZXJsYXApIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ1RoaXMgdGltZSBzbG90IGlzIG5vIGxvbmdlciBhdmFpbGFibGUnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDkgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBnaWZ0IGNhcmQgaWYgcHJvdmlkZWRcbiAgICBsZXQgZmluYWxfcHJpY2VfY2VudHMgPSBzZXJ2aWNlLnByaWNlX2NlbnRzO1xuICAgIGxldCBnaWZ0X2NhcmRfaWQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgIGxldCBnaWZ0X2NhcmRfYW1vdW50X2FwcGxpZWRfY2VudHMgPSAwO1xuXG4gICAgaWYgKGdpZnRfY2FyZF9jb2RlKSB7XG4gICAgICBjb25zdCB7IGRhdGE6IGdpZnRDYXJkLCBlcnJvcjogZ2lmdENhcmRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2dpZnRfY2FyZHMnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgYnVzaW5lc3MudXNlcl9pZClcbiAgICAgICAgLmVxKCdidXNpbmVzc19pZCcsIGJ1c2luZXNzLmlkKVxuICAgICAgICAuZXEoJ2NvZGUnLCBnaWZ0X2NhcmRfY29kZS50b1VwcGVyQ2FzZSgpLnRyaW0oKSlcbiAgICAgICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKVxuICAgICAgICAuaXMoJ2RlbGV0ZWRfYXQnLCBudWxsKVxuICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgIGlmIChnaWZ0Q2FyZEVycm9yIHx8ICFnaWZ0Q2FyZCkge1xuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgeyBlcnJvcjogJ0ludmFsaWQgZ2lmdCBjYXJkIGNvZGUnIH0sXG4gICAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGV4cGlyYXRpb25cbiAgICAgIGlmIChnaWZ0Q2FyZC5leHBpcmVzX2F0ICYmIG5ldyBEYXRlKGdpZnRDYXJkLmV4cGlyZXNfYXQpIDwgbmV3IERhdGUoKSkge1xuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgeyBlcnJvcjogJ0dpZnQgY2FyZCBoYXMgZXhwaXJlZCcgfSxcbiAgICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZ2lmdF9jYXJkX2lkID0gZ2lmdENhcmQuaWQ7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBkaXNjb3VudFxuICAgICAgaWYgKGdpZnRDYXJkLmRpc2NvdW50X3R5cGUgPT09ICdhbW91bnQnKSB7XG4gICAgICAgIC8vIEZvciBhbW91bnQtdHlwZSBnaWZ0IGNhcmRzLCBjYWxjdWxhdGUgcmVtYWluaW5nIGJhbGFuY2VcbiAgICAgICAgLy8gYnkgc3VidHJhY3RpbmcgYW1vdW50cyBhbHJlYWR5IGFwcGxpZWQgaW4gcGVuZGluZy9jb21wbGV0ZWQgYm9va2luZ3NcbiAgICAgICAgY29uc3QgeyBkYXRhOiBleGlzdGluZ0Jvb2tpbmdzIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdib29raW5ncycpXG4gICAgICAgICAgLnNlbGVjdCgnZ2lmdF9jYXJkX2Ftb3VudF9hcHBsaWVkX2NlbnRzLCBzdGF0dXMnKVxuICAgICAgICAgIC5lcSgnZ2lmdF9jYXJkX2lkJywgZ2lmdENhcmQuaWQpXG4gICAgICAgICAgLmluKCdzdGF0dXMnLCBbJ3BlbmRpbmcnLCAnc2NoZWR1bGVkJywgJ2NvbXBsZXRlZCcsICdoZWxkJ10pXG4gICAgICAgICAgLmlzKCdkZWxldGVkX2F0JywgbnVsbCk7XG5cbiAgICAgICAgLy8gU3VtIHVwIGFtb3VudHMgYWxyZWFkeSBhcHBsaWVkIGluIHBlbmRpbmcvY29tcGxldGVkIGJvb2tpbmdzXG4gICAgICAgIGNvbnN0IGFscmVhZHlBcHBsaWVkQ2VudHMgPSBleGlzdGluZ0Jvb2tpbmdzPy5yZWR1Y2UoKHN1bSwgYm9va2luZykgPT4ge1xuICAgICAgICAgIHJldHVybiBzdW0gKyAoYm9va2luZy5naWZ0X2NhcmRfYW1vdW50X2FwcGxpZWRfY2VudHMgfHwgMCk7XG4gICAgICAgIH0sIDApIHx8IDA7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHJlbWFpbmluZyBhdmFpbGFibGUgYmFsYW5jZVxuICAgICAgICBjb25zdCByZW1haW5pbmdCYWxhbmNlQ2VudHMgPSBNYXRoLm1heCgwLCBnaWZ0Q2FyZC5jdXJyZW50X2JhbGFuY2VfY2VudHMgLSBhbHJlYWR5QXBwbGllZENlbnRzKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGFueSByZW1haW5pbmcgYmFsYW5jZVxuICAgICAgICBpZiAocmVtYWluaW5nQmFsYW5jZUNlbnRzIDw9IDApIHtcbiAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgICAgICB7IGVycm9yOiAnR2lmdCBjYXJkIGhhcyBubyByZW1haW5pbmcgYmFsYW5jZScgfSxcbiAgICAgICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSBvbmx5IHRoZSByZW1haW5pbmcgYmFsYW5jZSAobm90IHRoZSBmdWxsIGN1cnJlbnRfYmFsYW5jZV9jZW50cylcbiAgICAgICAgZ2lmdF9jYXJkX2Ftb3VudF9hcHBsaWVkX2NlbnRzID0gTWF0aC5taW4ocmVtYWluaW5nQmFsYW5jZUNlbnRzLCBzZXJ2aWNlLnByaWNlX2NlbnRzKTtcbiAgICAgICAgZmluYWxfcHJpY2VfY2VudHMgPSBzZXJ2aWNlLnByaWNlX2NlbnRzIC0gZ2lmdF9jYXJkX2Ftb3VudF9hcHBsaWVkX2NlbnRzO1xuICAgICAgfSBlbHNlIGlmIChnaWZ0Q2FyZC5kaXNjb3VudF90eXBlID09PSAncGVyY2VudCcpIHtcbiAgICAgICAgY29uc3QgcGVyY2VudE9mZiA9IGdpZnRDYXJkLnBlcmNlbnRfb2ZmIHx8IDA7XG4gICAgICAgIGlmIChwZXJjZW50T2ZmIDw9IDAgfHwgcGVyY2VudE9mZiA+IDEwMCkge1xuICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgICAgIHsgZXJyb3I6ICdJbnZhbGlkIGdpZnQgY2FyZCBkaXNjb3VudCBwZXJjZW50YWdlJyB9LFxuICAgICAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBnaWZ0X2NhcmRfYW1vdW50X2FwcGxpZWRfY2VudHMgPSBNYXRoLnJvdW5kKChzZXJ2aWNlLnByaWNlX2NlbnRzICogcGVyY2VudE9mZikgLyAxMDApO1xuICAgICAgICBmaW5hbF9wcmljZV9jZW50cyA9IHNlcnZpY2UucHJpY2VfY2VudHMgLSBnaWZ0X2NhcmRfYW1vdW50X2FwcGxpZWRfY2VudHM7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbF9wcmljZV9jZW50cyA8IDApIHtcbiAgICAgICAgZmluYWxfcHJpY2VfY2VudHMgPSAwO1xuICAgICAgICBnaWZ0X2NhcmRfYW1vdW50X2FwcGxpZWRfY2VudHMgPSBzZXJ2aWNlLnByaWNlX2NlbnRzO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldCBjdXJyZW50IGFjdGl2ZSBwb2xpY3kgYW5kIGNyZWF0ZSBzbmFwc2hvdFxuICAgIGNvbnN0IHsgZGF0YTogcG9saWN5LCBlcnJvcjogcG9saWN5RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYnVzaW5lc3NfcG9saWNpZXMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ2J1c2luZXNzX2lkJywgYnVzaW5lc3MuaWQpXG4gICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG4gICAgICAub3JkZXIoJ3ZlcnNpb24nLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgIC5saW1pdCgxKVxuICAgICAgLm1heWJlU2luZ2xlKCk7XG5cbiAgICBpZiAocG9saWN5RXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGJ1c2luZXNzIHBvbGljaWVzOicsIHBvbGljeUVycm9yKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0ZhaWxlZCB0byBmZXRjaCBidXNpbmVzcyBwb2xpY2llcycsIGRldGFpbHM6IHBvbGljeUVycm9yLm1lc3NhZ2UgfSxcbiAgICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghcG9saWN5KSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIHsgZXJyb3I6ICdCdXNpbmVzcyBwb2xpY2llcyBub3QgZm91bmQnIH0sXG4gICAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgcG9saWN5IHNuYXBzaG90IHdpdGggYWxsIHJlcXVpcmVkIGZpZWxkc1xuICAgIGNvbnN0IHBvbGljeVNuYXBzaG90ID0ge1xuICAgICAgY2FuY2VsbGF0aW9uX3BvbGljeV90ZXh0OiBwb2xpY3kuY2FuY2VsbGF0aW9uX3BvbGljeV90ZXh0LFxuICAgICAgbm9fc2hvd19wb2xpY3lfdGV4dDogcG9saWN5Lm5vX3Nob3dfcG9saWN5X3RleHQsXG4gICAgICByZWZ1bmRfcG9saWN5X3RleHQ6IHBvbGljeS5yZWZ1bmRfcG9saWN5X3RleHQsXG4gICAgICBjYXNoX3BvbGljeV90ZXh0OiBwb2xpY3kuY2FzaF9wb2xpY3lfdGV4dCxcbiAgICAgIG5vX3Nob3dfZmVlX3R5cGU6IHBvbGljeS5ub19zaG93X2ZlZV90eXBlLFxuICAgICAgbm9fc2hvd19mZWVfYW1vdW50X2NlbnRzOiBwb2xpY3kubm9fc2hvd19mZWVfYW1vdW50X2NlbnRzLFxuICAgICAgbm9fc2hvd19mZWVfcGVyY2VudDogcG9saWN5Lm5vX3Nob3dfZmVlX3BlcmNlbnQsXG4gICAgICBjYW5jZWxfZmVlX3R5cGU6IHBvbGljeS5jYW5jZWxfZmVlX3R5cGUsXG4gICAgICBjYW5jZWxfZmVlX2Ftb3VudF9jZW50czogcG9saWN5LmNhbmNlbF9mZWVfYW1vdW50X2NlbnRzLFxuICAgICAgY2FuY2VsX2ZlZV9wZXJjZW50OiBwb2xpY3kuY2FuY2VsX2ZlZV9wZXJjZW50LFxuICAgICAgdmVyc2lvbjogcG9saWN5LnZlcnNpb24sXG4gICAgICBzbmFwc2hvdF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH07XG5cbiAgICAvLyBDYWxjdWxhdGUgcG9saWN5IGhhc2ggZm9yIGNvbXBsaWFuY2UgKFNIQS0yNTYgb2YgcG9saWN5IHNuYXBzaG90KVxuICAgIGNvbnN0IHBvbGljeUhhc2ggPSBjcmVhdGVIYXNoKCdzaGEyNTYnKVxuICAgICAgLnVwZGF0ZShKU09OLnN0cmluZ2lmeShwb2xpY3lTbmFwc2hvdCkpXG4gICAgICAuZGlnZXN0KCdoZXgnKTtcblxuICAgIC8vIENyZWF0ZSBvciBmaW5kIGN1c3RvbWVyXG4gICAgbGV0IGN1c3RvbWVySWQ6IHN0cmluZztcbiAgICBsZXQgc3RyaXBlQ3VzdG9tZXJJZDogc3RyaW5nO1xuICAgIFxuICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmdDdXN0b21lciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjdXN0b21lcnMnKVxuICAgICAgLnNlbGVjdCgnaWQsIHN0cmlwZV9jdXN0b21lcl9pZCcpXG4gICAgICAuZXEoJ2J1c2luZXNzX2lkJywgYnVzaW5lc3MuaWQpXG4gICAgICAuZXEoJ2VtYWlsJywgY3VzdG9tZXIuZW1haWwudG9Mb3dlckNhc2UoKS50cmltKCkpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoZXhpc3RpbmdDdXN0b21lcikge1xuICAgICAgY3VzdG9tZXJJZCA9IGV4aXN0aW5nQ3VzdG9tZXIuaWQ7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBjdXN0b21lciBpbmZvIGlmIG5lZWRlZFxuICAgICAgY29uc3QgdXBkYXRlRGF0YTogYW55ID0ge1xuICAgICAgICBuYW1lOiBjdXN0b21lci5uYW1lLFxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuICAgICAgaWYgKGN1c3RvbWVyLnBob25lKSB7XG4gICAgICAgIHVwZGF0ZURhdGEucGhvbmUgPSBjdXN0b21lci5waG9uZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2N1c3RvbWVycycpXG4gICAgICAgIC51cGRhdGUodXBkYXRlRGF0YSlcbiAgICAgICAgLmVxKCdpZCcsIGN1c3RvbWVySWQpO1xuXG4gICAgICAvLyBHZXQgb3IgY3JlYXRlIFN0cmlwZSBDdXN0b21lciBJRFxuICAgICAgaWYgKGV4aXN0aW5nQ3VzdG9tZXIuc3RyaXBlX2N1c3RvbWVyX2lkKSB7XG4gICAgICAgIHN0cmlwZUN1c3RvbWVySWQgPSBleGlzdGluZ0N1c3RvbWVyLnN0cmlwZV9jdXN0b21lcl9pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmlwZUN1c3RvbWVySWQgPSBhd2FpdCBjcmVhdGVPckdldEN1c3RvbWVyKGN1c3RvbWVyLmVtYWlsLnRvTG93ZXJDYXNlKCkudHJpbSgpLCBjdXN0b21lci5uYW1lLCB7XG4gICAgICAgICAgYnVzaW5lc3NfaWQ6IGJ1c2luZXNzLmlkLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnY3VzdG9tZXJzJylcbiAgICAgICAgICAudXBkYXRlKHsgc3RyaXBlX2N1c3RvbWVyX2lkOiBzdHJpcGVDdXN0b21lcklkIH0pXG4gICAgICAgICAgLmVxKCdpZCcsIGN1c3RvbWVySWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgU3RyaXBlIEN1c3RvbWVyIGZpcnN0XG4gICAgICBzdHJpcGVDdXN0b21lcklkID0gYXdhaXQgY3JlYXRlT3JHZXRDdXN0b21lcihjdXN0b21lci5lbWFpbC50b0xvd2VyQ2FzZSgpLnRyaW0oKSwgY3VzdG9tZXIubmFtZSwge1xuICAgICAgICBidXNpbmVzc19pZDogYnVzaW5lc3MuaWQsXG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIGN1c3RvbWVyIHJlY29yZFxuICAgICAgY29uc3QgeyBkYXRhOiBuZXdDdXN0b21lciwgZXJyb3I6IGN1c3RvbWVyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdjdXN0b21lcnMnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICB1c2VyX2lkOiBidXNpbmVzcy51c2VyX2lkLFxuICAgICAgICAgIGJ1c2luZXNzX2lkOiBidXNpbmVzcy5pZCxcbiAgICAgICAgICBuYW1lOiBjdXN0b21lci5uYW1lLFxuICAgICAgICAgIGVtYWlsOiBjdXN0b21lci5lbWFpbC50b0xvd2VyQ2FzZSgpLnRyaW0oKSxcbiAgICAgICAgICBwaG9uZTogY3VzdG9tZXIucGhvbmUgfHwgbnVsbCxcbiAgICAgICAgICBzdHJpcGVfY3VzdG9tZXJfaWQ6IHN0cmlwZUN1c3RvbWVySWQsXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdCgnaWQnKVxuICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgIGlmIChjdXN0b21lckVycm9yIHx8ICFuZXdDdXN0b21lcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBjdXN0b21lcjonLCBjdXN0b21lckVycm9yKTtcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICAgIHsgZXJyb3I6ICdGYWlsZWQgdG8gY3JlYXRlIGN1c3RvbWVyJywgZGV0YWlsczogY3VzdG9tZXJFcnJvcj8ubWVzc2FnZSB9LFxuICAgICAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjdXN0b21lcklkID0gbmV3Q3VzdG9tZXIuaWQ7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGJvb2tpbmdcbiAgICBjb25zdCB7IGRhdGE6IGJvb2tpbmcsIGVycm9yOiBib29raW5nRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYm9va2luZ3MnKVxuICAgICAgLmluc2VydCh7XG4gICAgICAgIHVzZXJfaWQ6IGJ1c2luZXNzLnVzZXJfaWQsXG4gICAgICAgIGJ1c2luZXNzX2lkOiBidXNpbmVzcy5pZCxcbiAgICAgICAgY3VzdG9tZXJfaWQ6IGN1c3RvbWVySWQsXG4gICAgICAgIHNlcnZpY2VfaWQsXG4gICAgICAgIHN0YWZmX2lkLFxuICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgc3RhcnRfYXQ6IHN0YXJ0X2F0LFxuICAgICAgICBlbmRfYXQ6IGVuZEF0RGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgICBkdXJhdGlvbl9taW46IHNlcnZpY2UuZHVyYXRpb25fbWluLFxuICAgICAgICBwcmljZV9jZW50czogc2VydmljZS5wcmljZV9jZW50cyxcbiAgICAgICAgZmluYWxfcHJpY2VfY2VudHMsXG4gICAgICAgIGdpZnRfY2FyZF9pZCxcbiAgICAgICAgZ2lmdF9jYXJkX2Ftb3VudF9hcHBsaWVkX2NlbnRzLFxuICAgICAgICBzb3VyY2U6ICdwdWJsaWMnLFxuICAgICAgICBwb2xpY3lfc25hcHNob3Q6IHBvbGljeVNuYXBzaG90LFxuICAgICAgICAvLyBwb2xpY3lfaGFzaDogcG9saWN5SGFzaCwgLy8gQ29sdW1uIGRvZXNuJ3QgZXhpc3QgaW4gc2NoZW1hIC0gcmVtb3ZlZFxuICAgICAgICBjb25zZW50X2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGNvbnNlbnRfaXA6IGNvbnNlbnRfaXAgfHwgbnVsbCxcbiAgICAgICAgY29uc2VudF91c2VyX2FnZW50OiBjb25zZW50X3VzZXJfYWdlbnQgfHwgbnVsbCxcbiAgICAgICAgcGF5bWVudF9zdGF0dXM6ICdub25lJywgLy8gV2lsbCBiZSB1cGRhdGVkIGFmdGVyIFNldHVwSW50ZW50IHN1Y2NlZWRzXG4gICAgICAgIGxhc3RfbW9uZXlfYWN0aW9uOiAnbm9uZScsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfSlcbiAgICAgIC5zZWxlY3QoJ2lkJylcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmIChib29raW5nRXJyb3IgfHwgIWJvb2tpbmcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGJvb2tpbmc6JywgYm9va2luZ0Vycm9yKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0ZhaWxlZCB0byBjcmVhdGUgYm9va2luZycsIGRldGFpbHM6IGJvb2tpbmdFcnJvcj8ubWVzc2FnZSB9LFxuICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIFNldHVwSW50ZW50IHRvIHNhdmUgY2FyZCAobXVzdCB1c2UgU3RyaXBlIEN1c3RvbWVyIElELCBub3QgZW1haWwpXG4gICAgaWYgKCFzdHJpcGVDdXN0b21lcklkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdObyBTdHJpcGUgY3VzdG9tZXIgSUQgYXZhaWxhYmxlIGZvciBTZXR1cEludGVudCcpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnRmFpbGVkIHRvIHNldCB1cCBwYXltZW50IG1ldGhvZCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHNldHVwSW50ZW50ID0gYXdhaXQgY3JlYXRlU2V0dXBJbnRlbnQoXG4gICAgICBzdHJpcGVDdXN0b21lcklkLFxuICAgICAge1xuICAgICAgICBib29raW5nX2lkOiBib29raW5nLmlkLFxuICAgICAgICBidXNpbmVzc19pZDogYnVzaW5lc3MuaWQsXG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIENyZWF0ZSBib29raW5nIHBheW1lbnQgcmVjb3JkIChzdGF0dXMgd2lsbCBiZSB1cGRhdGVkIHRvICdjYXJkX3NhdmVkJyBieSB3ZWJob29rIHdoZW4gU2V0dXBJbnRlbnQgc3VjY2VlZHMpXG4gICAgY29uc3QgeyBlcnJvcjogcGF5bWVudEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2Jvb2tpbmdfcGF5bWVudHMnKVxuICAgICAgLmluc2VydCh7XG4gICAgICAgIHVzZXJfaWQ6IGJ1c2luZXNzLnVzZXJfaWQsXG4gICAgICAgIGJ1c2luZXNzX2lkOiBidXNpbmVzcy5pZCxcbiAgICAgICAgYm9va2luZ19pZDogYm9va2luZy5pZCxcbiAgICAgICAgc3RyaXBlX3NldHVwX2ludGVudF9pZDogc2V0dXBJbnRlbnQuc2V0dXBJbnRlbnRJZCxcbiAgICAgICAgYW1vdW50X2NlbnRzOiBmaW5hbF9wcmljZV9jZW50cyxcbiAgICAgICAgbW9uZXlfYWN0aW9uOiAnbm9uZScsXG4gICAgICAgIHN0YXR1czogJ25vbmUnLCAvLyBXaWxsIGJlIHVwZGF0ZWQgdG8gJ2NhcmRfc2F2ZWQnIGJ5IHdlYmhvb2sgd2hlbiBTZXR1cEludGVudCBzdWNjZWVkc1xuICAgICAgICBjdXJyZW5jeTogJ3VzZCcsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfSk7XG5cbiAgICBpZiAocGF5bWVudEVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBib29raW5nIHBheW1lbnQ6JywgcGF5bWVudEVycm9yKTtcbiAgICAgIC8vIENvbnRpbnVlIGFueXdheSAtIHBheW1lbnQgY2FuIGJlIHVwZGF0ZWQgbGF0ZXJcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBib29raW5nIGNvZGUgKGUuZy4sIFRJVEhJLTEyMzQpXG4gICAgY29uc3QgYm9va2luZ0NvZGUgPSBgVElUSEktJHtib29raW5nLmlkLnNsaWNlKDAsIDgpLnRvVXBwZXJDYXNlKCl9YDtcblxuICAgIC8vIEVtaXQgYm9va2luZ19jcmVhdGVkIG5vdGlmaWNhdGlvbiAoYXN5bmMsIGRvbid0IHdhaXQpXG4gICAgZW1pdE5vdGlmaWNhdGlvbihidXNpbmVzcy5pZCwgJ2Jvb2tpbmdfY3JlYXRlZCcsIGJvb2tpbmcuaWQsIHN1cGFiYXNlKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbWl0dGluZyBib29raW5nX2NyZWF0ZWQgbm90aWZpY2F0aW9uOicsIGVycik7XG4gICAgICAvLyBEb24ndCBmYWlsIHRoZSByZXF1ZXN0IGlmIG5vdGlmaWNhdGlvbiBmYWlsc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgIGJvb2tpbmdfaWQ6IGJvb2tpbmcuaWQsXG4gICAgICBib29raW5nX2NvZGU6IGJvb2tpbmdDb2RlLFxuICAgICAgY2xpZW50X3NlY3JldDogc2V0dXBJbnRlbnQuY2xpZW50U2VjcmV0LFxuICAgICAgc2V0dXBfaW50ZW50X2lkOiBzZXR1cEludGVudC5zZXR1cEludGVudElkLFxuICAgICAgZmluYWxfcHJpY2VfY2VudHMsXG4gICAgICBtZXNzYWdlOiAnQm9va2luZyBjcmVhdGVkIHN1Y2Nlc3NmdWxseS4gUGxlYXNlIGNvbXBsZXRlIHBheW1lbnQgc2V0dXAuJyxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBwdWJsaWMgYm9va2luZzonLCBlcnJvcik7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBlcnJvcjogJ0ludGVybmFsIHNlcnZlciBlcnJvcicsIGRldGFpbHM6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InIH0sXG4gICAgICB7IHN0YXR1czogNTAwIH1cbiAgICApO1xuICB9XG59XG5cblxuIl0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsImNyZWF0ZUFkbWluQ2xpZW50IiwiY3JlYXRlT3JHZXRDdXN0b21lciIsImNyZWF0ZVNldHVwSW50ZW50IiwiZW1pdE5vdGlmaWNhdGlvbiIsImNyZWF0ZUhhc2giLCJQT1NUIiwicmVxdWVzdCIsInBhcmFtcyIsInNsdWciLCJib2R5IiwianNvbiIsInNlcnZpY2VfaWQiLCJzdGFmZl9pZCIsInN0YXJ0X2F0IiwiY3VzdG9tZXIiLCJnaWZ0X2NhcmRfY29kZSIsImNvbnNlbnRfaXAiLCJoZWFkZXJzIiwiZ2V0Iiwic3BsaXQiLCJ0cmltIiwiY29uc2VudF91c2VyX2FnZW50IiwiZXJyb3IiLCJzdGF0dXMiLCJuYW1lIiwiZW1haWwiLCJzdXBhYmFzZSIsImRhdGEiLCJidXNpbmVzcyIsImJ1c2luZXNzRXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJ0b0xvd2VyQ2FzZSIsImluIiwiaXMiLCJzaW5nbGUiLCJzZXJ2aWNlIiwic2VydmljZUVycm9yIiwiaWQiLCJzdGFydEF0RGF0ZSIsIkRhdGUiLCJlbmRBdERhdGUiLCJnZXRUaW1lIiwiZHVyYXRpb25fbWluIiwiZXhpc3RpbmdCb29raW5ncyIsImJvb2tpbmdDaGVja0Vycm9yIiwiY29uc29sZSIsImhhc092ZXJsYXAiLCJzb21lIiwiYm9va2luZyIsImJvb2tpbmdTdGFydCIsImJvb2tpbmdFbmQiLCJlbmRfYXQiLCJmaW5hbF9wcmljZV9jZW50cyIsInByaWNlX2NlbnRzIiwiZ2lmdF9jYXJkX2lkIiwiZ2lmdF9jYXJkX2Ftb3VudF9hcHBsaWVkX2NlbnRzIiwiZ2lmdENhcmQiLCJnaWZ0Q2FyZEVycm9yIiwidXNlcl9pZCIsInRvVXBwZXJDYXNlIiwiZXhwaXJlc19hdCIsImRpc2NvdW50X3R5cGUiLCJhbHJlYWR5QXBwbGllZENlbnRzIiwicmVkdWNlIiwic3VtIiwicmVtYWluaW5nQmFsYW5jZUNlbnRzIiwiTWF0aCIsIm1heCIsImN1cnJlbnRfYmFsYW5jZV9jZW50cyIsIm1pbiIsInBlcmNlbnRPZmYiLCJwZXJjZW50X29mZiIsInJvdW5kIiwicG9saWN5IiwicG9saWN5RXJyb3IiLCJvcmRlciIsImFzY2VuZGluZyIsImxpbWl0IiwibWF5YmVTaW5nbGUiLCJkZXRhaWxzIiwibWVzc2FnZSIsInBvbGljeVNuYXBzaG90IiwiY2FuY2VsbGF0aW9uX3BvbGljeV90ZXh0Iiwibm9fc2hvd19wb2xpY3lfdGV4dCIsInJlZnVuZF9wb2xpY3lfdGV4dCIsImNhc2hfcG9saWN5X3RleHQiLCJub19zaG93X2ZlZV90eXBlIiwibm9fc2hvd19mZWVfYW1vdW50X2NlbnRzIiwibm9fc2hvd19mZWVfcGVyY2VudCIsImNhbmNlbF9mZWVfdHlwZSIsImNhbmNlbF9mZWVfYW1vdW50X2NlbnRzIiwiY2FuY2VsX2ZlZV9wZXJjZW50IiwidmVyc2lvbiIsInNuYXBzaG90X2F0IiwidG9JU09TdHJpbmciLCJwb2xpY3lIYXNoIiwidXBkYXRlIiwiSlNPTiIsInN0cmluZ2lmeSIsImRpZ2VzdCIsImN1c3RvbWVySWQiLCJzdHJpcGVDdXN0b21lcklkIiwiZXhpc3RpbmdDdXN0b21lciIsInVwZGF0ZURhdGEiLCJ1cGRhdGVkX2F0IiwicGhvbmUiLCJzdHJpcGVfY3VzdG9tZXJfaWQiLCJidXNpbmVzc19pZCIsIm5ld0N1c3RvbWVyIiwiY3VzdG9tZXJFcnJvciIsImluc2VydCIsImNyZWF0ZWRfYXQiLCJib29raW5nRXJyb3IiLCJjdXN0b21lcl9pZCIsInNvdXJjZSIsInBvbGljeV9zbmFwc2hvdCIsImNvbnNlbnRfYXQiLCJwYXltZW50X3N0YXR1cyIsImxhc3RfbW9uZXlfYWN0aW9uIiwic2V0dXBJbnRlbnQiLCJib29raW5nX2lkIiwicGF5bWVudEVycm9yIiwic3RyaXBlX3NldHVwX2ludGVudF9pZCIsInNldHVwSW50ZW50SWQiLCJhbW91bnRfY2VudHMiLCJtb25leV9hY3Rpb24iLCJjdXJyZW5jeSIsImJvb2tpbmdDb2RlIiwic2xpY2UiLCJjYXRjaCIsImVyciIsImJvb2tpbmdfY29kZSIsImNsaWVudF9zZWNyZXQiLCJjbGllbnRTZWNyZXQiLCJzZXR1cF9pbnRlbnRfaWQiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/public/[slug]/bookings/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/db.ts":
/*!***********************!*\
  !*** ./src/lib/db.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAdminClient: () => (/* binding */ createAdminClient),\n/* harmony export */   createClientClient: () => (/* binding */ createClientClient),\n/* harmony export */   createServerClient: () => (/* binding */ createServerClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/../../node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var next_headers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/headers */ \"(rsc)/./node_modules/next/dist/api/headers.js\");\n\n\n/**\n * Get Supabase client for server-side operations\n * \n * This function returns different clients based on context:\n * - If called from an authenticated API route, uses the user's JWT from Authorization header (respects RLS)\n * - If called from a public route or background job, uses service role (bypasses RLS)\n * \n * Usage in API routes:\n * ```ts\n * const supabase = await createServerClient();\n * const { data } = await supabase.from('businesses').select('*');\n * ```\n */ async function createServerClient() {\n    const supabaseUrl = \"https://rgwooqakdvrchfwrdnyx.supabase.co\";\n    const supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJnd29vcWFrZHZyY2hmd3Jkbnl4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMzOTQyNDEsImV4cCI6MjA3ODk3MDI0MX0.YpX0dYf_iueJVR1oK5SvREnO765JAKxriy2csdAEZlI\";\n    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n    if (!supabaseUrl) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_URL environment variable\");\n    }\n    if (!supabaseAnonKey && !supabaseServiceKey) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_ANON_KEY or SUPABASE_SERVICE_ROLE_KEY environment variable\");\n    }\n    // Try to get the user's JWT from Authorization header (for API routes)\n    let accessToken;\n    try {\n        const headersList = await (0,next_headers__WEBPACK_IMPORTED_MODULE_0__.headers)();\n        const authHeader = headersList.get(\"authorization\");\n        if (authHeader?.startsWith(\"Bearer \")) {\n            accessToken = authHeader.substring(7);\n        }\n    } catch  {\n    // Not in a headers context\n    }\n    // If we have a user token from header, use anon key with that token (respects RLS)\n    if (accessToken && supabaseAnonKey) {\n        return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${accessToken}`\n                }\n            }\n        });\n    }\n    // Try to get session from cookies (Supabase stores session in cookies)\n    try {\n        const cookieStore = await (0,next_headers__WEBPACK_IMPORTED_MODULE_0__.cookies)();\n        const allCookies = cookieStore.getAll();\n        // Try to extract access token from cookies first\n        const supabaseUrlObj = new URL(supabaseUrl);\n        const projectRef = supabaseUrlObj.hostname.split(\".\")[0];\n        // Look for Supabase auth token cookie\n        // Try sb-api-auth-token first as it's the most common\n        const authCookieNames = [\n            `sb-api-auth-token`,\n            `sb-${projectRef}-auth-token`\n        ];\n        let accessToken;\n        for (const cookieName of authCookieNames){\n            const cookie = cookieStore.get(cookieName);\n            if (cookie?.value) {\n                // Log first 100 chars to see format (without exposing full token)\n                const preview = cookie.value.substring(0, 100);\n                console.log(`[createServerClient] Checking cookie: ${cookieName}, length: ${cookie.value.length}, preview: ${preview}...`);\n                try {\n                    // Try URL decoding first\n                    let decodedValue = cookie.value;\n                    try {\n                        decodedValue = decodeURIComponent(cookie.value);\n                    } catch  {\n                    // Not URL encoded\n                    }\n                    // Try parsing as JSON\n                    try {\n                        const session = JSON.parse(decodedValue);\n                        console.log(`[createServerClient] Parsed ${cookieName} as JSON, type:`, Array.isArray(session) ? \"array\" : typeof session, \"keys:\", Object.keys(session || {}));\n                        // Check if it's an array (Supabase sometimes stores tokens as array)\n                        if (Array.isArray(session) && session.length > 0) {\n                            console.log(`[createServerClient] Array has ${session.length} elements, checking each...`);\n                            // Try each element to find a valid JWT\n                            for(let i = 0; i < session.length; i++){\n                                const element = session[i];\n                                if (typeof element === \"string\") {\n                                    // Remove any quotes or extra characters\n                                    let cleanToken = element.trim();\n                                    if (cleanToken.startsWith('\"') && cleanToken.endsWith('\"') || cleanToken.startsWith(\"'\") && cleanToken.endsWith(\"'\")) {\n                                        cleanToken = cleanToken.slice(1, -1);\n                                    }\n                                    // Check if it looks like a JWT (has 3 parts separated by dots)\n                                    const parts = cleanToken.split(\".\");\n                                    if (parts.length === 3 && cleanToken.length > 100) {\n                                        console.log(`[createServerClient] Found valid JWT structure in element ${i}, using it as access token`);\n                                        // Use this token - even if signature validation fails later, \n                                        // Supabase might still accept it for RLS if the payload is valid\n                                        accessToken = cleanToken;\n                                        break;\n                                    }\n                                }\n                                // If element is an object, check for access_token\n                                if (element && typeof element === \"object\" && element.access_token) {\n                                    console.log(`[createServerClient] Found access_token in element ${i}: ${cookieName}`);\n                                    accessToken = element.access_token;\n                                    break;\n                                }\n                            }\n                            if (accessToken) {\n                                break;\n                            }\n                            // If no single element works, try joining all string elements\n                            const allStrings = session.filter((e)=>typeof e === \"string\");\n                            if (allStrings.length > 0) {\n                                const joined = allStrings.join(\"\");\n                                const parts = joined.split(\".\");\n                                if (parts.length === 3 && joined.length > 100) {\n                                    console.log(\"[createServerClient] Found JWT by joining array elements\");\n                                    accessToken = joined;\n                                    break;\n                                }\n                            }\n                        }\n                        if (session?.access_token) {\n                            console.log(`[createServerClient] Found access_token in ${cookieName}`);\n                            accessToken = session.access_token;\n                            break;\n                        }\n                        // Check for nested session object\n                        if (session?.session?.access_token) {\n                            console.log(`[createServerClient] Found access_token in nested session: ${cookieName}`);\n                            accessToken = session.session.access_token;\n                            break;\n                        }\n                    } catch (parseError) {\n                        // Not JSON, might be direct JWT token\n                        console.log(`[createServerClient] ${cookieName} is not JSON, checking if JWT`);\n                        if (decodedValue.length > 100 && decodedValue.includes(\".\")) {\n                            console.log(`[createServerClient] Using ${cookieName} as direct JWT token`);\n                            accessToken = decodedValue;\n                            break;\n                        }\n                    }\n                } catch (error) {\n                    console.error(`[createServerClient] Error processing ${cookieName}:`, error);\n                }\n            }\n        }\n        // If we found an access token, use it directly\n        if (accessToken && supabaseAnonKey) {\n            return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey, {\n                global: {\n                    headers: {\n                        Authorization: `Bearer ${accessToken}`\n                    }\n                },\n                auth: {\n                    persistSession: false,\n                    autoRefreshToken: false\n                }\n            });\n        }\n        // Fallback: Build cookie header for Supabase to read\n        const cookieHeader = allCookies.map((c)=>`${c.name}=${c.value}`).join(\"; \");\n        if (cookieHeader && supabaseAnonKey) {\n            // Create client with cookies - Supabase will extract session from cookies\n            return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey, {\n                global: {\n                    headers: {\n                        Cookie: cookieHeader\n                    }\n                },\n                auth: {\n                    persistSession: false,\n                    autoRefreshToken: false\n                }\n            });\n        }\n    } catch (error) {\n        console.error(\"Error reading cookies in createServerClient:\", error);\n    // Not in a cookies context, continue\n    }\n    // For public routes or background jobs, use service role key\n    // WARNING: This bypasses RLS - only use when necessary\n    if (supabaseServiceKey) {\n        return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseServiceKey, {\n            auth: {\n                autoRefreshToken: false,\n                persistSession: false\n            }\n        });\n    }\n    // Fallback to anon key (for public read operations)\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey);\n}\n/**\n * Get Supabase client with service role (bypasses RLS)\n * \n * Use this ONLY for:\n * - Background jobs\n * - Webhook handlers\n * - Admin operations that need to bypass RLS\n * \n * Usage:\n * ```ts\n * const supabase = createAdminClient();\n * const { data } = await supabase.from('businesses').select('*');\n * ```\n */ function createAdminClient() {\n    const supabaseUrl = \"https://rgwooqakdvrchfwrdnyx.supabase.co\";\n    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\n    if (!supabaseUrl) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_URL environment variable\");\n    }\n    if (!supabaseServiceKey) {\n        throw new Error(\"Missing SUPABASE_SERVICE_ROLE_KEY environment variable\");\n    }\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseServiceKey, {\n        auth: {\n            autoRefreshToken: false,\n            persistSession: false\n        }\n    });\n}\n/**\n * Get Supabase client for client-side operations\n * \n * This should be used in React components or client-side code.\n * It uses the anon key and relies on Supabase Auth for authentication.\n * \n * Usage in client components:\n * ```ts\n * 'use client';\n * const supabase = createClientClient();\n * ```\n */ function createClientClient() {\n    const supabaseUrl = \"https://rgwooqakdvrchfwrdnyx.supabase.co\";\n    const supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJnd29vcWFrZHZyY2hmd3Jkbnl4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMzOTQyNDEsImV4cCI6MjA3ODk3MDI0MX0.YpX0dYf_iueJVR1oK5SvREnO765JAKxriy2csdAEZlI\";\n    if (!supabaseUrl) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_URL environment variable\");\n    }\n    if (!supabaseAnonKey) {\n        throw new Error(\"Missing NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable\");\n    }\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseAnonKey);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDRjtBQUVBOzs7Ozs7Ozs7OztDQVdDLEdBQ00sU0FBU1E7SUFDZCxNQUFNbkUsY0FBY0MsMENBQW9DO0lBQ3hELE1BQU1HLGtCQUFrQkgsa05BQXlDO0lBRWpFLElBQUksQ0FBQ0QsYUFBYTtRQUNoQixNQUFNLElBQUlRLE1BQU07SUFDbEI7SUFFQSxJQUFJLENBQUNKLGlCQUFpQjtRQUNwQixNQUFNLElBQUlJLE1BQU07SUFDbEI7SUFFQSxPQUFPWixtRUFBWUEsQ0FBQ0ksYUFBYUk7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9zcmMvbGliL2RiLnRzPzllNGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50LCBTdXBhYmFzZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5pbXBvcnQgeyBjb29raWVzLCBoZWFkZXJzIH0gZnJvbSAnbmV4dC9oZWFkZXJzJztcblxuLyoqXG4gKiBHZXQgU3VwYWJhc2UgY2xpZW50IGZvciBzZXJ2ZXItc2lkZSBvcGVyYXRpb25zXG4gKiBcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBkaWZmZXJlbnQgY2xpZW50cyBiYXNlZCBvbiBjb250ZXh0OlxuICogLSBJZiBjYWxsZWQgZnJvbSBhbiBhdXRoZW50aWNhdGVkIEFQSSByb3V0ZSwgdXNlcyB0aGUgdXNlcidzIEpXVCBmcm9tIEF1dGhvcml6YXRpb24gaGVhZGVyIChyZXNwZWN0cyBSTFMpXG4gKiAtIElmIGNhbGxlZCBmcm9tIGEgcHVibGljIHJvdXRlIG9yIGJhY2tncm91bmQgam9iLCB1c2VzIHNlcnZpY2Ugcm9sZSAoYnlwYXNzZXMgUkxTKVxuICogXG4gKiBVc2FnZSBpbiBBUEkgcm91dGVzOlxuICogYGBgdHNcbiAqIGNvbnN0IHN1cGFiYXNlID0gYXdhaXQgY3JlYXRlU2VydmVyQ2xpZW50KCk7XG4gKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2J1c2luZXNzZXMnKS5zZWxlY3QoJyonKTtcbiAqIGBgYFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlU2VydmVyQ2xpZW50KCk6IFByb21pc2U8U3VwYWJhc2VDbGllbnQ+IHtcbiAgY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkw7XG4gIGNvbnN0IHN1cGFiYXNlQW5vbktleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZO1xuICBjb25zdCBzdXBhYmFzZVNlcnZpY2VLZXkgPSBwcm9jZXNzLmVudi5TVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZO1xuXG4gIGlmICghc3VwYWJhc2VVcmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIGVudmlyb25tZW50IHZhcmlhYmxlJyk7XG4gIH1cblxuICBpZiAoIXN1cGFiYXNlQW5vbktleSAmJiAhc3VwYWJhc2VTZXJ2aWNlS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ01pc3NpbmcgTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgb3IgU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSdcbiAgICApO1xuICB9XG5cbiAgLy8gVHJ5IHRvIGdldCB0aGUgdXNlcidzIEpXVCBmcm9tIEF1dGhvcml6YXRpb24gaGVhZGVyIChmb3IgQVBJIHJvdXRlcylcbiAgbGV0IGFjY2Vzc1Rva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IGhlYWRlcnNMaXN0ID0gYXdhaXQgaGVhZGVycygpO1xuICAgIGNvbnN0IGF1dGhIZWFkZXIgPSBoZWFkZXJzTGlzdC5nZXQoJ2F1dGhvcml6YXRpb24nKTtcbiAgICBpZiAoYXV0aEhlYWRlcj8uc3RhcnRzV2l0aCgnQmVhcmVyICcpKSB7XG4gICAgICBhY2Nlc3NUb2tlbiA9IGF1dGhIZWFkZXIuc3Vic3RyaW5nKDcpO1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgLy8gTm90IGluIGEgaGVhZGVycyBjb250ZXh0XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlIGEgdXNlciB0b2tlbiBmcm9tIGhlYWRlciwgdXNlIGFub24ga2V5IHdpdGggdGhhdCB0b2tlbiAocmVzcGVjdHMgUkxTKVxuICBpZiAoYWNjZXNzVG9rZW4gJiYgc3VwYWJhc2VBbm9uS2V5KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5LCB7XG4gICAgICBnbG9iYWw6IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRyeSB0byBnZXQgc2Vzc2lvbiBmcm9tIGNvb2tpZXMgKFN1cGFiYXNlIHN0b3JlcyBzZXNzaW9uIGluIGNvb2tpZXMpXG4gIHRyeSB7XG4gICAgY29uc3QgY29va2llU3RvcmUgPSBhd2FpdCBjb29raWVzKCk7XG4gICAgY29uc3QgYWxsQ29va2llcyA9IGNvb2tpZVN0b3JlLmdldEFsbCgpO1xuICAgIFxuICAgIC8vIFRyeSB0byBleHRyYWN0IGFjY2VzcyB0b2tlbiBmcm9tIGNvb2tpZXMgZmlyc3RcbiAgICBjb25zdCBzdXBhYmFzZVVybE9iaiA9IG5ldyBVUkwoc3VwYWJhc2VVcmwpO1xuICAgIGNvbnN0IHByb2plY3RSZWYgPSBzdXBhYmFzZVVybE9iai5ob3N0bmFtZS5zcGxpdCgnLicpWzBdO1xuICAgIFxuICAgIC8vIExvb2sgZm9yIFN1cGFiYXNlIGF1dGggdG9rZW4gY29va2llXG4gICAgLy8gVHJ5IHNiLWFwaS1hdXRoLXRva2VuIGZpcnN0IGFzIGl0J3MgdGhlIG1vc3QgY29tbW9uXG4gICAgY29uc3QgYXV0aENvb2tpZU5hbWVzID0gW1xuICAgICAgYHNiLWFwaS1hdXRoLXRva2VuYCxcbiAgICAgIGBzYi0ke3Byb2plY3RSZWZ9LWF1dGgtdG9rZW5gLFxuICAgIF07XG4gICAgXG4gICAgbGV0IGFjY2Vzc1Rva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCBjb29raWVOYW1lIG9mIGF1dGhDb29raWVOYW1lcykge1xuICAgICAgY29uc3QgY29va2llID0gY29va2llU3RvcmUuZ2V0KGNvb2tpZU5hbWUpO1xuICAgICAgaWYgKGNvb2tpZT8udmFsdWUpIHtcbiAgICAgICAgLy8gTG9nIGZpcnN0IDEwMCBjaGFycyB0byBzZWUgZm9ybWF0ICh3aXRob3V0IGV4cG9zaW5nIGZ1bGwgdG9rZW4pXG4gICAgICAgIGNvbnN0IHByZXZpZXcgPSBjb29raWUudmFsdWUuc3Vic3RyaW5nKDAsIDEwMCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbY3JlYXRlU2VydmVyQ2xpZW50XSBDaGVja2luZyBjb29raWU6ICR7Y29va2llTmFtZX0sIGxlbmd0aDogJHtjb29raWUudmFsdWUubGVuZ3RofSwgcHJldmlldzogJHtwcmV2aWV3fS4uLmApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRyeSBVUkwgZGVjb2RpbmcgZmlyc3RcbiAgICAgICAgICBsZXQgZGVjb2RlZFZhbHVlID0gY29va2llLnZhbHVlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWNvZGVkVmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoY29va2llLnZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIC8vIE5vdCBVUkwgZW5jb2RlZFxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgcGFyc2luZyBhcyBKU09OXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBKU09OLnBhcnNlKGRlY29kZWRWYWx1ZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NyZWF0ZVNlcnZlckNsaWVudF0gUGFyc2VkICR7Y29va2llTmFtZX0gYXMgSlNPTiwgdHlwZTpgLCBBcnJheS5pc0FycmF5KHNlc3Npb24pID8gJ2FycmF5JyA6IHR5cGVvZiBzZXNzaW9uLCAna2V5czonLCBPYmplY3Qua2V5cyhzZXNzaW9uIHx8IHt9KSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gYXJyYXkgKFN1cGFiYXNlIHNvbWV0aW1lcyBzdG9yZXMgdG9rZW5zIGFzIGFycmF5KVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2Vzc2lvbikgJiYgc2Vzc2lvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbY3JlYXRlU2VydmVyQ2xpZW50XSBBcnJheSBoYXMgJHtzZXNzaW9uLmxlbmd0aH0gZWxlbWVudHMsIGNoZWNraW5nIGVhY2guLi5gKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFRyeSBlYWNoIGVsZW1lbnQgdG8gZmluZCBhIHZhbGlkIEpXVFxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gc2Vzc2lvbltpXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW55IHF1b3RlcyBvciBleHRyYSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICBsZXQgY2xlYW5Ub2tlbiA9IGVsZW1lbnQudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgaWYgKChjbGVhblRva2VuLnN0YXJ0c1dpdGgoJ1wiJykgJiYgY2xlYW5Ub2tlbi5lbmRzV2l0aCgnXCInKSkgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgKGNsZWFuVG9rZW4uc3RhcnRzV2l0aChcIidcIikgJiYgY2xlYW5Ub2tlbi5lbmRzV2l0aChcIidcIikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuVG9rZW4gPSBjbGVhblRva2VuLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgbG9va3MgbGlrZSBhIEpXVCAoaGFzIDMgcGFydHMgc2VwYXJhdGVkIGJ5IGRvdHMpXG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGNsZWFuVG9rZW4uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDMgJiYgY2xlYW5Ub2tlbi5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtjcmVhdGVTZXJ2ZXJDbGllbnRdIEZvdW5kIHZhbGlkIEpXVCBzdHJ1Y3R1cmUgaW4gZWxlbWVudCAke2l9LCB1c2luZyBpdCBhcyBhY2Nlc3MgdG9rZW5gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoaXMgdG9rZW4gLSBldmVuIGlmIHNpZ25hdHVyZSB2YWxpZGF0aW9uIGZhaWxzIGxhdGVyLCBcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwYWJhc2UgbWlnaHQgc3RpbGwgYWNjZXB0IGl0IGZvciBSTFMgaWYgdGhlIHBheWxvYWQgaXMgdmFsaWRcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBjbGVhblRva2VuO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gSWYgZWxlbWVudCBpcyBhbiBvYmplY3QsIGNoZWNrIGZvciBhY2Nlc3NfdG9rZW5cbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudC5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbY3JlYXRlU2VydmVyQ2xpZW50XSBGb3VuZCBhY2Nlc3NfdG9rZW4gaW4gZWxlbWVudCAke2l9OiAke2Nvb2tpZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbiA9IGVsZW1lbnQuYWNjZXNzX3Rva2VuO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gSWYgbm8gc2luZ2xlIGVsZW1lbnQgd29ya3MsIHRyeSBqb2luaW5nIGFsbCBzdHJpbmcgZWxlbWVudHNcbiAgICAgICAgICAgICAgY29uc3QgYWxsU3RyaW5ncyA9IHNlc3Npb24uZmlsdGVyKGUgPT4gdHlwZW9mIGUgPT09ICdzdHJpbmcnKTtcbiAgICAgICAgICAgICAgaWYgKGFsbFN0cmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGpvaW5lZCA9IGFsbFN0cmluZ3Muam9pbignJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBqb2luZWQuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAzICYmIGpvaW5lZC5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbY3JlYXRlU2VydmVyQ2xpZW50XSBGb3VuZCBKV1QgYnkgam9pbmluZyBhcnJheSBlbGVtZW50cycpO1xuICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBqb2luZWQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHNlc3Npb24/LmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NyZWF0ZVNlcnZlckNsaWVudF0gRm91bmQgYWNjZXNzX3Rva2VuIGluICR7Y29va2llTmFtZX1gKTtcbiAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBzZXNzaW9uLmFjY2Vzc190b2tlbjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBuZXN0ZWQgc2Vzc2lvbiBvYmplY3RcbiAgICAgICAgICAgIGlmIChzZXNzaW9uPy5zZXNzaW9uPy5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtjcmVhdGVTZXJ2ZXJDbGllbnRdIEZvdW5kIGFjY2Vzc190b2tlbiBpbiBuZXN0ZWQgc2Vzc2lvbjogJHtjb29raWVOYW1lfWApO1xuICAgICAgICAgICAgICBhY2Nlc3NUb2tlbiA9IHNlc3Npb24uc2Vzc2lvbi5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIE5vdCBKU09OLCBtaWdodCBiZSBkaXJlY3QgSldUIHRva2VuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NyZWF0ZVNlcnZlckNsaWVudF0gJHtjb29raWVOYW1lfSBpcyBub3QgSlNPTiwgY2hlY2tpbmcgaWYgSldUYCk7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZFZhbHVlLmxlbmd0aCA+IDEwMCAmJiBkZWNvZGVkVmFsdWUuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NyZWF0ZVNlcnZlckNsaWVudF0gVXNpbmcgJHtjb29raWVOYW1lfSBhcyBkaXJlY3QgSldUIHRva2VuYCk7XG4gICAgICAgICAgICAgIGFjY2Vzc1Rva2VuID0gZGVjb2RlZFZhbHVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgW2NyZWF0ZVNlcnZlckNsaWVudF0gRXJyb3IgcHJvY2Vzc2luZyAke2Nvb2tpZU5hbWV9OmAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSBmb3VuZCBhbiBhY2Nlc3MgdG9rZW4sIHVzZSBpdCBkaXJlY3RseVxuICAgIGlmIChhY2Nlc3NUb2tlbiAmJiBzdXBhYmFzZUFub25LZXkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgICBnbG9iYWw6IHtcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgcGVyc2lzdFNlc3Npb246IGZhbHNlLFxuICAgICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrOiBCdWlsZCBjb29raWUgaGVhZGVyIGZvciBTdXBhYmFzZSB0byByZWFkXG4gICAgY29uc3QgY29va2llSGVhZGVyID0gYWxsQ29va2llcy5tYXAoYyA9PiBgJHtjLm5hbWV9PSR7Yy52YWx1ZX1gKS5qb2luKCc7ICcpO1xuICAgIFxuICAgIGlmIChjb29raWVIZWFkZXIgJiYgc3VwYWJhc2VBbm9uS2V5KSB7XG4gICAgICAvLyBDcmVhdGUgY2xpZW50IHdpdGggY29va2llcyAtIFN1cGFiYXNlIHdpbGwgZXh0cmFjdCBzZXNzaW9uIGZyb20gY29va2llc1xuICAgICAgcmV0dXJuIGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5LCB7XG4gICAgICAgIGdsb2JhbDoge1xuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIENvb2tpZTogY29va2llSGVhZGVyLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsIC8vIFdlJ3JlIGhhbmRsaW5nIGNvb2tpZXMgbWFudWFsbHlcbiAgICAgICAgICBhdXRvUmVmcmVzaFRva2VuOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWFkaW5nIGNvb2tpZXMgaW4gY3JlYXRlU2VydmVyQ2xpZW50OicsIGVycm9yKTtcbiAgICAvLyBOb3QgaW4gYSBjb29raWVzIGNvbnRleHQsIGNvbnRpbnVlXG4gIH1cblxuICAvLyBGb3IgcHVibGljIHJvdXRlcyBvciBiYWNrZ3JvdW5kIGpvYnMsIHVzZSBzZXJ2aWNlIHJvbGUga2V5XG4gIC8vIFdBUk5JTkc6IFRoaXMgYnlwYXNzZXMgUkxTIC0gb25seSB1c2Ugd2hlbiBuZWNlc3NhcnlcbiAgaWYgKHN1cGFiYXNlU2VydmljZUtleSkge1xuICAgIHJldHVybiBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlU2VydmljZUtleSwge1xuICAgICAgYXV0aDoge1xuICAgICAgICBhdXRvUmVmcmVzaFRva2VuOiBmYWxzZSxcbiAgICAgICAgcGVyc2lzdFNlc3Npb246IGZhbHNlLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEZhbGxiYWNrIHRvIGFub24ga2V5IChmb3IgcHVibGljIHJlYWQgb3BlcmF0aW9ucylcbiAgcmV0dXJuIGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5ISk7XG59XG5cbi8qKlxuICogR2V0IFN1cGFiYXNlIGNsaWVudCB3aXRoIHNlcnZpY2Ugcm9sZSAoYnlwYXNzZXMgUkxTKVxuICogXG4gKiBVc2UgdGhpcyBPTkxZIGZvcjpcbiAqIC0gQmFja2dyb3VuZCBqb2JzXG4gKiAtIFdlYmhvb2sgaGFuZGxlcnNcbiAqIC0gQWRtaW4gb3BlcmF0aW9ucyB0aGF0IG5lZWQgdG8gYnlwYXNzIFJMU1xuICogXG4gKiBVc2FnZTpcbiAqIGBgYHRzXG4gKiBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUFkbWluQ2xpZW50KCk7XG4gKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2J1c2luZXNzZXMnKS5zZWxlY3QoJyonKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWRtaW5DbGllbnQoKTogU3VwYWJhc2VDbGllbnQge1xuICBjb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTDtcbiAgY29uc3Qgc3VwYWJhc2VTZXJ2aWNlS2V5ID0gcHJvY2Vzcy5lbnYuU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWTtcblxuICBpZiAoIXN1cGFiYXNlVXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIE5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCBlbnZpcm9ubWVudCB2YXJpYWJsZScpO1xuICB9XG5cbiAgaWYgKCFzdXBhYmFzZVNlcnZpY2VLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZScpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VTZXJ2aWNlS2V5LCB7XG4gICAgYXV0aDoge1xuICAgICAgYXV0b1JlZnJlc2hUb2tlbjogZmFsc2UsXG4gICAgICBwZXJzaXN0U2Vzc2lvbjogZmFsc2UsXG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IFN1cGFiYXNlIGNsaWVudCBmb3IgY2xpZW50LXNpZGUgb3BlcmF0aW9uc1xuICogXG4gKiBUaGlzIHNob3VsZCBiZSB1c2VkIGluIFJlYWN0IGNvbXBvbmVudHMgb3IgY2xpZW50LXNpZGUgY29kZS5cbiAqIEl0IHVzZXMgdGhlIGFub24ga2V5IGFuZCByZWxpZXMgb24gU3VwYWJhc2UgQXV0aCBmb3IgYXV0aGVudGljYXRpb24uXG4gKiBcbiAqIFVzYWdlIGluIGNsaWVudCBjb21wb25lbnRzOlxuICogYGBgdHNcbiAqICd1c2UgY2xpZW50JztcbiAqIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50Q2xpZW50KCk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNsaWVudENsaWVudCgpOiBTdXBhYmFzZUNsaWVudCB7XG4gIGNvbnN0IHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMO1xuICBjb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWTtcblxuICBpZiAoIXN1cGFiYXNlVXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIE5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCBlbnZpcm9ubWVudCB2YXJpYWJsZScpO1xuICB9XG5cbiAgaWYgKCFzdXBhYmFzZUFub25LZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGUnKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSk7XG59XG5cbiJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJjb29raWVzIiwiaGVhZGVycyIsImNyZWF0ZVNlcnZlckNsaWVudCIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlQW5vbktleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwic3VwYWJhc2VTZXJ2aWNlS2V5IiwiU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSIsIkVycm9yIiwiYWNjZXNzVG9rZW4iLCJoZWFkZXJzTGlzdCIsImF1dGhIZWFkZXIiLCJnZXQiLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwiZ2xvYmFsIiwiQXV0aG9yaXphdGlvbiIsImNvb2tpZVN0b3JlIiwiYWxsQ29va2llcyIsImdldEFsbCIsInN1cGFiYXNlVXJsT2JqIiwiVVJMIiwicHJvamVjdFJlZiIsImhvc3RuYW1lIiwic3BsaXQiLCJhdXRoQ29va2llTmFtZXMiLCJjb29raWVOYW1lIiwiY29va2llIiwidmFsdWUiLCJwcmV2aWV3IiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsImRlY29kZWRWYWx1ZSIsImRlY29kZVVSSUNvbXBvbmVudCIsInNlc3Npb24iLCJKU09OIiwicGFyc2UiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJrZXlzIiwiaSIsImVsZW1lbnQiLCJjbGVhblRva2VuIiwidHJpbSIsImVuZHNXaXRoIiwic2xpY2UiLCJwYXJ0cyIsImFjY2Vzc190b2tlbiIsImFsbFN0cmluZ3MiLCJmaWx0ZXIiLCJlIiwiam9pbmVkIiwiam9pbiIsInBhcnNlRXJyb3IiLCJpbmNsdWRlcyIsImVycm9yIiwiYXV0aCIsInBlcnNpc3RTZXNzaW9uIiwiYXV0b1JlZnJlc2hUb2tlbiIsImNvb2tpZUhlYWRlciIsIm1hcCIsImMiLCJuYW1lIiwiQ29va2llIiwiY3JlYXRlQWRtaW5DbGllbnQiLCJjcmVhdGVDbGllbnRDbGllbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/db.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/notifications.ts":
/*!**********************************!*\
  !*** ./src/lib/notifications.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALLOWED_PLACEHOLDERS: () => (/* binding */ ALLOWED_PLACEHOLDERS),\n/* harmony export */   createNotificationFromTemplate: () => (/* binding */ createNotificationFromTemplate),\n/* harmony export */   emitNotification: () => (/* binding */ emitNotification),\n/* harmony export */   enqueueNotification: () => (/* binding */ enqueueNotification),\n/* harmony export */   loadTemplateForTrigger: () => (/* binding */ loadTemplateForTrigger),\n/* harmony export */   renderTemplate: () => (/* binding */ renderTemplate),\n/* harmony export */   validatePlaceholders: () => (/* binding */ validatePlaceholders)\n/* harmony export */ });\n/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./db */ \"(rsc)/./src/lib/db.ts\");\n/* harmony import */ var _timezone__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./timezone */ \"(rsc)/./src/lib/timezone.ts\");\n\n\n// Allowed placeholders per the spec\nconst ALLOWED_PLACEHOLDERS = [\n    \"customer.name\",\n    \"customer.email\",\n    \"customer.phone\",\n    \"service.name\",\n    \"service.duration\",\n    \"service.price\",\n    \"staff.name\",\n    \"booking.code\",\n    \"booking.date\",\n    \"booking.time\",\n    \"booking.amount\",\n    \"business.name\",\n    \"business.phone\",\n    \"business.support_email\",\n    \"booking.url\"\n];\n/**\n * Validate that template only contains allowed placeholders\n */ function validatePlaceholders(template) {\n    const placeholderRegex = /\\$\\{([^}]+)\\}/g;\n    const matches = Array.from(template.matchAll(placeholderRegex));\n    const foundPlaceholders = matches.map((m)=>m[1]);\n    const invalid = foundPlaceholders.filter((p)=>!ALLOWED_PLACEHOLDERS.includes(p));\n    return {\n        valid: invalid.length === 0,\n        invalid\n    };\n}\n/**\n * Render a notification template by substituting placeholders\n * Supports timezone-aware date/time formatting\n */ function renderTemplate(template, data, timezone) {\n    let rendered = template;\n    const tz = timezone || data.business?.timezone || \"America/New_York\";\n    // Replace placeholders with actual values\n    if (data.customer) {\n        rendered = rendered.replace(/\\$\\{customer\\.name\\}/g, data.customer.name || \"\");\n        rendered = rendered.replace(/\\$\\{customer\\.email\\}/g, data.customer.email || \"\");\n        rendered = rendered.replace(/\\$\\{customer\\.phone\\}/g, data.customer.phone || \"\");\n    }\n    if (data.service) {\n        rendered = rendered.replace(/\\$\\{service\\.name\\}/g, data.service.name || \"\");\n        rendered = rendered.replace(/\\$\\{service\\.duration\\}/g, String(data.service.duration_min || 0));\n        rendered = rendered.replace(/\\$\\{service\\.price\\}/g, formatPrice(data.service.price_cents || 0));\n    }\n    if (data.staff) {\n        rendered = rendered.replace(/\\$\\{staff\\.name\\}/g, data.staff.name || \"\");\n    }\n    if (data.booking) {\n        const startDate = new Date(data.booking.start_at);\n        rendered = rendered.replace(/\\$\\{booking\\.date\\}/g, formatDate(startDate, tz));\n        rendered = rendered.replace(/\\$\\{booking\\.time\\}/g, formatTime(startDate, tz));\n        rendered = rendered.replace(/\\$\\{booking\\.code\\}/g, `TITHI-${data.booking.id?.slice(0, 8).toUpperCase() || \"\"}`);\n        // booking.amount uses final_price_cents if available, otherwise price_cents\n        const amount = data.booking.final_price_cents ?? data.booking.price_cents ?? 0;\n        rendered = rendered.replace(/\\$\\{booking\\.amount\\}/g, formatPrice(amount));\n    }\n    if (data.business) {\n        rendered = rendered.replace(/\\$\\{business\\.name\\}/g, data.business.name || \"\");\n        rendered = rendered.replace(/\\$\\{business\\.support_email\\}/g, data.business.support_email || \"\");\n        rendered = rendered.replace(/\\$\\{business\\.phone\\}/g, data.business.phone || \"\");\n    }\n    if (data.booking_url) {\n        rendered = rendered.replace(/\\$\\{booking\\.url\\}/g, data.booking_url);\n    } else if (data.business?.subdomain) {\n        // Generate booking URL if not provided\n        const bookingCode = data.booking?.id ? `TITHI-${data.booking.id.slice(0, 8).toUpperCase()}` : \"\";\n        const url = `https://${data.business.subdomain}.tithi.com/confirm/${bookingCode}`;\n        rendered = rendered.replace(/\\$\\{booking\\.url\\}/g, url);\n    }\n    // Handle amount placeholder for fee_charged and refunded\n    if (data.amount !== undefined) {\n        rendered = rendered.replace(/\\$\\{amount\\}/g, formatPrice(data.amount));\n    }\n    return rendered;\n}\n/**\n * Enqueue a notification job\n * Uses unique constraint to prevent duplicate sends\n */ async function enqueueNotification(params) {\n    const supabase = (0,_db__WEBPACK_IMPORTED_MODULE_0__.createAdminClient)(); // Use admin client to bypass RLS for job insertion\n    // Check for existing job with same booking_id, trigger, and channel (idempotency)\n    if (params.bookingId) {\n        const { data: existing } = await supabase.from(\"notification_jobs\").select(\"id\").eq(\"booking_id\", params.bookingId).eq(\"trigger\", params.trigger).eq(\"channel\", params.channel).limit(1).single();\n        if (existing) {\n            // Job already exists, skip\n            return;\n        }\n    }\n    const now = new Date().toISOString();\n    const { error } = await supabase.from(\"notification_jobs\").insert({\n        user_id: params.userId,\n        business_id: params.businessId,\n        booking_id: params.bookingId || null,\n        template_id: params.templateId || null,\n        recipient_email: params.recipientEmail || null,\n        recipient_phone: params.recipientPhone || null,\n        subject: params.subject || null,\n        body: params.body,\n        channel: params.channel,\n        trigger: params.trigger,\n        status: \"pending\",\n        attempt_count: 0,\n        scheduled_at: now,\n        next_retry_at: null,\n        created_at: now\n    });\n    if (error) {\n        // If unique constraint violation, that's okay (idempotency)\n        if (error.code === \"23505\") {\n            return;\n        }\n        console.error(\"Error enqueueing notification:\", error);\n        throw error;\n    }\n}\n/**\n * Load notification template for a trigger\n */ async function loadTemplateForTrigger(businessId, userId, trigger, channel, supabase) {\n    const client = supabase || (0,_db__WEBPACK_IMPORTED_MODULE_0__.createAdminClient)();\n    const { data: template, error } = await client.from(\"notification_templates\").select(\"*\").eq(\"business_id\", businessId).eq(\"user_id\", userId).eq(\"trigger\", trigger).eq(\"channel\", channel).eq(\"is_enabled\", true).is(\"deleted_at\", null).order(\"created_at\", {\n        ascending: false\n    }).limit(1).maybeSingle();\n    if (error && error.code !== \"PGRST116\") {\n        console.error(\"Error loading template:\", error);\n        return null;\n    }\n    return template;\n}\n/**\n * Main function to emit a notification event\n * This loads booking data, resolves templates, and enqueues jobs\n * \n * @param amount Optional amount in cents for fee_charged and refunded triggers\n */ async function emitNotification(businessId, trigger, bookingId, supabase, amount) {\n    const client = supabase || (0,_db__WEBPACK_IMPORTED_MODULE_0__.createAdminClient)();\n    // Check if notifications are enabled for this business\n    const { data: business } = await client.from(\"businesses\").select(\"id, user_id, name, support_email, phone, subdomain, timezone, notifications_enabled\").eq(\"id\", businessId).single();\n    if (!business) {\n        console.error(`Business ${businessId} not found`);\n        return;\n    }\n    // If notifications are disabled (Basic Plan), skip sending notifications\n    // Basic Plan accounts only show booking confirmations, no SMS/email notifications\n    if (business.notifications_enabled === false) {\n        console.log(`Skipping notification for business ${businessId} - Basic Plan (notifications disabled)`);\n        return;\n    }\n    const userId = business.user_id;\n    // Load complete booking data with all relations\n    const { data: booking, error: bookingError } = await client.from(\"bookings\").select(`\n      *,\n      customers:customer_id (\n        id,\n        name,\n        email,\n        phone\n      ),\n      services:service_id (\n        id,\n        name,\n        duration_min,\n        price_cents\n      ),\n      staff:staff_id (\n        id,\n        name\n      )\n    `).eq(\"id\", bookingId).eq(\"business_id\", businessId).is(\"deleted_at\", null).single();\n    if (bookingError || !booking) {\n        console.error(`Booking ${bookingId} not found:`, bookingError);\n        return;\n    }\n    // For fee_charged and refunded, load the latest payment amount if not provided\n    let feeAmount = amount;\n    if ((trigger === \"fee_charged\" || trigger === \"refunded\") && feeAmount === undefined) {\n        const { data: latestPayment } = await client.from(\"booking_payments\").select(\"amount_cents\").eq(\"booking_id\", bookingId).in(\"money_action\", trigger === \"fee_charged\" ? [\n            \"no_show_fee\",\n            \"cancel_fee\"\n        ] : [\n            \"refund\"\n        ]).order(\"created_at\", {\n            ascending: false\n        }).limit(1).maybeSingle();\n        if (latestPayment) {\n            feeAmount = latestPayment.amount_cents;\n        }\n    }\n    // Build notification data\n    const notificationData = {\n        booking: {\n            id: booking.id,\n            start_at: booking.start_at,\n            end_at: booking.end_at,\n            final_price_cents: booking.final_price_cents,\n            price_cents: booking.price_cents,\n            staff_id: booking.staff_id,\n            status: booking.status\n        },\n        customer: booking.customers ? {\n            name: booking.customers.name,\n            email: booking.customers.email,\n            phone: booking.customers.phone || undefined\n        } : undefined,\n        service: booking.services ? {\n            name: booking.services.name,\n            duration_min: booking.services.duration_min,\n            price_cents: booking.services.price_cents\n        } : undefined,\n        staff: booking.staff ? {\n            name: booking.staff.name\n        } : undefined,\n        business: {\n            name: business.name,\n            support_email: business.support_email || undefined,\n            phone: business.phone || undefined,\n            subdomain: business.subdomain || undefined,\n            timezone: business.timezone || \"America/New_York\"\n        },\n        booking_url: business.subdomain ? `https://${business.subdomain}.tithi.com/confirm/TITHI-${booking.id.slice(0, 8).toUpperCase()}` : undefined,\n        amount: feeAmount\n    };\n    // Load templates for this trigger\n    const emailTemplate = await loadTemplateForTrigger(businessId, userId, trigger, \"email\", client);\n    const smsTemplate = await loadTemplateForTrigger(businessId, userId, trigger, \"sms\", client);\n    const timezone = business.timezone || \"America/New_York\";\n    // Enqueue email notification if template exists and customer has email\n    if (emailTemplate && notificationData.customer?.email) {\n        const renderedBody = renderTemplate(emailTemplate.body_markdown, notificationData, timezone);\n        const renderedSubject = emailTemplate.subject ? renderTemplate(emailTemplate.subject, notificationData, timezone) : undefined;\n        await enqueueNotification({\n            businessId,\n            userId,\n            bookingId,\n            trigger,\n            recipientEmail: notificationData.customer.email,\n            templateId: emailTemplate.id,\n            subject: renderedSubject,\n            body: renderedBody,\n            channel: \"email\"\n        });\n    }\n    // Enqueue SMS notification if template exists and customer has phone\n    if (smsTemplate && notificationData.customer?.phone) {\n        const renderedBody = renderTemplate(smsTemplate.body_markdown, notificationData, timezone);\n        await enqueueNotification({\n            businessId,\n            userId,\n            bookingId,\n            trigger,\n            recipientPhone: notificationData.customer.phone,\n            templateId: smsTemplate.id,\n            body: renderedBody,\n            channel: \"sms\"\n        });\n    }\n}\n/**\n * Create notification job from template and data (legacy function, use emitNotification)\n */ async function createNotificationFromTemplate(params) {\n    const { businessId, userId, bookingId, trigger, data } = params;\n    if (!bookingId) {\n        console.error(\"createNotificationFromTemplate requires bookingId\");\n        return;\n    }\n    // Use the main emitNotification function\n    await emitNotification(businessId, trigger, bookingId);\n}\n// Helper functions\nfunction formatDate(date, timezone) {\n    return (0,_timezone__WEBPACK_IMPORTED_MODULE_1__.formatInTimeZone)(date.toISOString(), timezone, {\n        weekday: \"long\",\n        year: \"numeric\",\n        month: \"long\",\n        day: \"numeric\"\n    });\n}\nfunction formatTime(date, timezone) {\n    return (0,_timezone__WEBPACK_IMPORTED_MODULE_1__.formatInTimeZone)(date.toISOString(), timezone, {\n        hour: \"numeric\",\n        minute: \"2-digit\",\n        hour12: true\n    });\n}\nfunction formatPrice(cents) {\n    return `$${(cents / 100).toFixed(2)}`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q1A7QUFDRjtBQUVBLFNBQVM1RSxXQUFXd0UsSUFBVSxFQUFFNUYsUUFBZ0I7SUFDOUMsT0FBT3BCLDJEQUFnQkEsQ0FBQ2dILEtBQUtoRCxXQUFXLElBQUk1QyxVQUFVO1FBQ3BEaUcsTUFBTTtRQUNOQyxRQUFRO1FBQ1JDLFFBQVE7SUFDVjtBQUNGO0FBRUEsU0FBU3ZGLFlBQVl3RixLQUFhO0lBQ2hDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQ0EsUUFBUSxHQUFFLEVBQUdDLE9BQU8sQ0FBQyxHQUFHLENBQUM7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9zcmMvbGliL25vdGlmaWNhdGlvbnMudHM/ODJlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVTZXJ2ZXJDbGllbnQsIGNyZWF0ZUFkbWluQ2xpZW50IH0gZnJvbSAnLi9kYic7XG5pbXBvcnQgeyBmb3JtYXRJblRpbWVab25lIH0gZnJvbSAnLi90aW1lem9uZSc7XG5pbXBvcnQgdHlwZSB7IFN1cGFiYXNlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcblxuZXhwb3J0IHR5cGUgTm90aWZpY2F0aW9uVHJpZ2dlciA9IFxuICB8ICdib29raW5nX2NyZWF0ZWQnXG4gIHwgJ2Jvb2tpbmdfY29uZmlybWVkJ1xuICB8ICdyZW1pbmRlcl8yNGgnXG4gIHwgJ3JlbWluZGVyXzFoJ1xuICB8ICdib29raW5nX2NhbmNlbGxlZCdcbiAgfCAnYm9va2luZ19yZXNjaGVkdWxlZCdcbiAgfCAnYm9va2luZ19jb21wbGV0ZWQnXG4gIHwgJ2ZlZV9jaGFyZ2VkJ1xuICB8ICdyZWZ1bmRlZCdcbiAgfCAncGF5bWVudF9pc3N1ZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWZpY2F0aW9uRGF0YSB7XG4gIGJvb2tpbmc/OiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBzdGFydF9hdDogc3RyaW5nO1xuICAgIGVuZF9hdD86IHN0cmluZztcbiAgICBmaW5hbF9wcmljZV9jZW50cz86IG51bWJlcjtcbiAgICBwcmljZV9jZW50cz86IG51bWJlcjtcbiAgICBzdGFmZl9pZD86IHN0cmluZztcbiAgICBzdGF0dXM/OiBzdHJpbmc7XG4gIH07XG4gIGN1c3RvbWVyPzoge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBlbWFpbDogc3RyaW5nO1xuICAgIHBob25lPzogc3RyaW5nO1xuICB9O1xuICBzZXJ2aWNlPzoge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBkdXJhdGlvbl9taW46IG51bWJlcjtcbiAgICBwcmljZV9jZW50czogbnVtYmVyO1xuICB9O1xuICBzdGFmZj86IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gIH07XG4gIGJ1c2luZXNzPzoge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBzdXBwb3J0X2VtYWlsPzogc3RyaW5nO1xuICAgIHBob25lPzogc3RyaW5nO1xuICAgIHN1YmRvbWFpbj86IHN0cmluZztcbiAgICB0aW1lem9uZT86IHN0cmluZztcbiAgfTtcbiAgYm9va2luZ191cmw/OiBzdHJpbmc7XG4gIGFtb3VudD86IG51bWJlcjsgLy8gRm9yIGZlZV9jaGFyZ2VkIGFuZCByZWZ1bmRlZCB0cmlnZ2Vyc1xufVxuXG4vLyBBbGxvd2VkIHBsYWNlaG9sZGVycyBwZXIgdGhlIHNwZWNcbmV4cG9ydCBjb25zdCBBTExPV0VEX1BMQUNFSE9MREVSUyA9IFtcbiAgJ2N1c3RvbWVyLm5hbWUnLFxuICAnY3VzdG9tZXIuZW1haWwnLFxuICAnY3VzdG9tZXIucGhvbmUnLFxuICAnc2VydmljZS5uYW1lJyxcbiAgJ3NlcnZpY2UuZHVyYXRpb24nLFxuICAnc2VydmljZS5wcmljZScsXG4gICdzdGFmZi5uYW1lJyxcbiAgJ2Jvb2tpbmcuY29kZScsXG4gICdib29raW5nLmRhdGUnLFxuICAnYm9va2luZy50aW1lJyxcbiAgJ2Jvb2tpbmcuYW1vdW50JyxcbiAgJ2J1c2luZXNzLm5hbWUnLFxuICAnYnVzaW5lc3MucGhvbmUnLFxuICAnYnVzaW5lc3Muc3VwcG9ydF9lbWFpbCcsXG4gICdib29raW5nLnVybCcsXG5dO1xuXG4vKipcbiAqIFZhbGlkYXRlIHRoYXQgdGVtcGxhdGUgb25seSBjb250YWlucyBhbGxvd2VkIHBsYWNlaG9sZGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQbGFjZWhvbGRlcnModGVtcGxhdGU6IHN0cmluZyk6IHsgdmFsaWQ6IGJvb2xlYW47IGludmFsaWQ6IHN0cmluZ1tdIH0ge1xuICBjb25zdCBwbGFjZWhvbGRlclJlZ2V4ID0gL1xcJFxceyhbXn1dKylcXH0vZztcbiAgY29uc3QgbWF0Y2hlcyA9IEFycmF5LmZyb20odGVtcGxhdGUubWF0Y2hBbGwocGxhY2Vob2xkZXJSZWdleCkpO1xuICBjb25zdCBmb3VuZFBsYWNlaG9sZGVycyA9IG1hdGNoZXMubWFwKG0gPT4gbVsxXSk7XG4gIGNvbnN0IGludmFsaWQgPSBmb3VuZFBsYWNlaG9sZGVycy5maWx0ZXIocCA9PiAhQUxMT1dFRF9QTEFDRUhPTERFUlMuaW5jbHVkZXMocCkpO1xuICBcbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogaW52YWxpZC5sZW5ndGggPT09IDAsXG4gICAgaW52YWxpZCxcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgYSBub3RpZmljYXRpb24gdGVtcGxhdGUgYnkgc3Vic3RpdHV0aW5nIHBsYWNlaG9sZGVyc1xuICogU3VwcG9ydHMgdGltZXpvbmUtYXdhcmUgZGF0ZS90aW1lIGZvcm1hdHRpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclRlbXBsYXRlKHRlbXBsYXRlOiBzdHJpbmcsIGRhdGE6IE5vdGlmaWNhdGlvbkRhdGEsIHRpbWV6b25lPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IHJlbmRlcmVkID0gdGVtcGxhdGU7XG4gIGNvbnN0IHR6ID0gdGltZXpvbmUgfHwgZGF0YS5idXNpbmVzcz8udGltZXpvbmUgfHwgJ0FtZXJpY2EvTmV3X1lvcmsnO1xuXG4gIC8vIFJlcGxhY2UgcGxhY2Vob2xkZXJzIHdpdGggYWN0dWFsIHZhbHVlc1xuICBpZiAoZGF0YS5jdXN0b21lcikge1xuICAgIHJlbmRlcmVkID0gcmVuZGVyZWQucmVwbGFjZSgvXFwkXFx7Y3VzdG9tZXJcXC5uYW1lXFx9L2csIGRhdGEuY3VzdG9tZXIubmFtZSB8fCAnJyk7XG4gICAgcmVuZGVyZWQgPSByZW5kZXJlZC5yZXBsYWNlKC9cXCRcXHtjdXN0b21lclxcLmVtYWlsXFx9L2csIGRhdGEuY3VzdG9tZXIuZW1haWwgfHwgJycpO1xuICAgIHJlbmRlcmVkID0gcmVuZGVyZWQucmVwbGFjZSgvXFwkXFx7Y3VzdG9tZXJcXC5waG9uZVxcfS9nLCBkYXRhLmN1c3RvbWVyLnBob25lIHx8ICcnKTtcbiAgfVxuXG4gIGlmIChkYXRhLnNlcnZpY2UpIHtcbiAgICByZW5kZXJlZCA9IHJlbmRlcmVkLnJlcGxhY2UoL1xcJFxce3NlcnZpY2VcXC5uYW1lXFx9L2csIGRhdGEuc2VydmljZS5uYW1lIHx8ICcnKTtcbiAgICByZW5kZXJlZCA9IHJlbmRlcmVkLnJlcGxhY2UoL1xcJFxce3NlcnZpY2VcXC5kdXJhdGlvblxcfS9nLCBTdHJpbmcoZGF0YS5zZXJ2aWNlLmR1cmF0aW9uX21pbiB8fCAwKSk7XG4gICAgcmVuZGVyZWQgPSByZW5kZXJlZC5yZXBsYWNlKC9cXCRcXHtzZXJ2aWNlXFwucHJpY2VcXH0vZywgZm9ybWF0UHJpY2UoZGF0YS5zZXJ2aWNlLnByaWNlX2NlbnRzIHx8IDApKTtcbiAgfVxuXG4gIGlmIChkYXRhLnN0YWZmKSB7XG4gICAgcmVuZGVyZWQgPSByZW5kZXJlZC5yZXBsYWNlKC9cXCRcXHtzdGFmZlxcLm5hbWVcXH0vZywgZGF0YS5zdGFmZi5uYW1lIHx8ICcnKTtcbiAgfVxuXG4gIGlmIChkYXRhLmJvb2tpbmcpIHtcbiAgICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZShkYXRhLmJvb2tpbmcuc3RhcnRfYXQpO1xuICAgIHJlbmRlcmVkID0gcmVuZGVyZWQucmVwbGFjZSgvXFwkXFx7Ym9va2luZ1xcLmRhdGVcXH0vZywgZm9ybWF0RGF0ZShzdGFydERhdGUsIHR6KSk7XG4gICAgcmVuZGVyZWQgPSByZW5kZXJlZC5yZXBsYWNlKC9cXCRcXHtib29raW5nXFwudGltZVxcfS9nLCBmb3JtYXRUaW1lKHN0YXJ0RGF0ZSwgdHopKTtcbiAgICByZW5kZXJlZCA9IHJlbmRlcmVkLnJlcGxhY2UoL1xcJFxce2Jvb2tpbmdcXC5jb2RlXFx9L2csIGBUSVRISS0ke2RhdGEuYm9va2luZy5pZD8uc2xpY2UoMCwgOCkudG9VcHBlckNhc2UoKSB8fCAnJ31gKTtcbiAgICBcbiAgICAvLyBib29raW5nLmFtb3VudCB1c2VzIGZpbmFsX3ByaWNlX2NlbnRzIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHByaWNlX2NlbnRzXG4gICAgY29uc3QgYW1vdW50ID0gZGF0YS5ib29raW5nLmZpbmFsX3ByaWNlX2NlbnRzID8/IGRhdGEuYm9va2luZy5wcmljZV9jZW50cyA/PyAwO1xuICAgIHJlbmRlcmVkID0gcmVuZGVyZWQucmVwbGFjZSgvXFwkXFx7Ym9va2luZ1xcLmFtb3VudFxcfS9nLCBmb3JtYXRQcmljZShhbW91bnQpKTtcbiAgfVxuXG4gIGlmIChkYXRhLmJ1c2luZXNzKSB7XG4gICAgcmVuZGVyZWQgPSByZW5kZXJlZC5yZXBsYWNlKC9cXCRcXHtidXNpbmVzc1xcLm5hbWVcXH0vZywgZGF0YS5idXNpbmVzcy5uYW1lIHx8ICcnKTtcbiAgICByZW5kZXJlZCA9IHJlbmRlcmVkLnJlcGxhY2UoL1xcJFxce2J1c2luZXNzXFwuc3VwcG9ydF9lbWFpbFxcfS9nLCBkYXRhLmJ1c2luZXNzLnN1cHBvcnRfZW1haWwgfHwgJycpO1xuICAgIHJlbmRlcmVkID0gcmVuZGVyZWQucmVwbGFjZSgvXFwkXFx7YnVzaW5lc3NcXC5waG9uZVxcfS9nLCBkYXRhLmJ1c2luZXNzLnBob25lIHx8ICcnKTtcbiAgfVxuXG4gIGlmIChkYXRhLmJvb2tpbmdfdXJsKSB7XG4gICAgcmVuZGVyZWQgPSByZW5kZXJlZC5yZXBsYWNlKC9cXCRcXHtib29raW5nXFwudXJsXFx9L2csIGRhdGEuYm9va2luZ191cmwpO1xuICB9IGVsc2UgaWYgKGRhdGEuYnVzaW5lc3M/LnN1YmRvbWFpbikge1xuICAgIC8vIEdlbmVyYXRlIGJvb2tpbmcgVVJMIGlmIG5vdCBwcm92aWRlZFxuICAgIGNvbnN0IGJvb2tpbmdDb2RlID0gZGF0YS5ib29raW5nPy5pZCBcbiAgICAgID8gYFRJVEhJLSR7ZGF0YS5ib29raW5nLmlkLnNsaWNlKDAsIDgpLnRvVXBwZXJDYXNlKCl9YFxuICAgICAgOiAnJztcbiAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly8ke2RhdGEuYnVzaW5lc3Muc3ViZG9tYWlufS50aXRoaS5jb20vY29uZmlybS8ke2Jvb2tpbmdDb2RlfWA7XG4gICAgcmVuZGVyZWQgPSByZW5kZXJlZC5yZXBsYWNlKC9cXCRcXHtib29raW5nXFwudXJsXFx9L2csIHVybCk7XG4gIH1cblxuICAvLyBIYW5kbGUgYW1vdW50IHBsYWNlaG9sZGVyIGZvciBmZWVfY2hhcmdlZCBhbmQgcmVmdW5kZWRcbiAgaWYgKGRhdGEuYW1vdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZW5kZXJlZCA9IHJlbmRlcmVkLnJlcGxhY2UoL1xcJFxce2Ftb3VudFxcfS9nLCBmb3JtYXRQcmljZShkYXRhLmFtb3VudCkpO1xuICB9XG5cbiAgcmV0dXJuIHJlbmRlcmVkO1xufVxuXG4vKipcbiAqIEVucXVldWUgYSBub3RpZmljYXRpb24gam9iXG4gKiBVc2VzIHVuaXF1ZSBjb25zdHJhaW50IHRvIHByZXZlbnQgZHVwbGljYXRlIHNlbmRzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbnF1ZXVlTm90aWZpY2F0aW9uKHBhcmFtczoge1xuICBidXNpbmVzc0lkOiBzdHJpbmc7XG4gIHVzZXJJZDogc3RyaW5nO1xuICBib29raW5nSWQ/OiBzdHJpbmc7XG4gIHRyaWdnZXI6IHN0cmluZztcbiAgcmVjaXBpZW50RW1haWw/OiBzdHJpbmc7XG4gIHJlY2lwaWVudFBob25lPzogc3RyaW5nO1xuICB0ZW1wbGF0ZUlkPzogc3RyaW5nO1xuICBzdWJqZWN0Pzogc3RyaW5nO1xuICBib2R5OiBzdHJpbmc7XG4gIGNoYW5uZWw6ICdlbWFpbCcgfCAnc21zJztcbn0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVBZG1pbkNsaWVudCgpOyAvLyBVc2UgYWRtaW4gY2xpZW50IHRvIGJ5cGFzcyBSTFMgZm9yIGpvYiBpbnNlcnRpb25cblxuICAvLyBDaGVjayBmb3IgZXhpc3Rpbmcgam9iIHdpdGggc2FtZSBib29raW5nX2lkLCB0cmlnZ2VyLCBhbmQgY2hhbm5lbCAoaWRlbXBvdGVuY3kpXG4gIGlmIChwYXJhbXMuYm9va2luZ0lkKSB7XG4gICAgY29uc3QgeyBkYXRhOiBleGlzdGluZyB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdub3RpZmljYXRpb25fam9icycpXG4gICAgICAuc2VsZWN0KCdpZCcpXG4gICAgICAuZXEoJ2Jvb2tpbmdfaWQnLCBwYXJhbXMuYm9va2luZ0lkKVxuICAgICAgLmVxKCd0cmlnZ2VyJywgcGFyYW1zLnRyaWdnZXIpXG4gICAgICAuZXEoJ2NoYW5uZWwnLCBwYXJhbXMuY2hhbm5lbClcbiAgICAgIC5saW1pdCgxKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAvLyBKb2IgYWxyZWFkeSBleGlzdHMsIHNraXBcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ25vdGlmaWNhdGlvbl9qb2JzJylcbiAgICAuaW5zZXJ0KHtcbiAgICAgIHVzZXJfaWQ6IHBhcmFtcy51c2VySWQsXG4gICAgICBidXNpbmVzc19pZDogcGFyYW1zLmJ1c2luZXNzSWQsXG4gICAgICBib29raW5nX2lkOiBwYXJhbXMuYm9va2luZ0lkIHx8IG51bGwsXG4gICAgICB0ZW1wbGF0ZV9pZDogcGFyYW1zLnRlbXBsYXRlSWQgfHwgbnVsbCxcbiAgICAgIHJlY2lwaWVudF9lbWFpbDogcGFyYW1zLnJlY2lwaWVudEVtYWlsIHx8IG51bGwsXG4gICAgICByZWNpcGllbnRfcGhvbmU6IHBhcmFtcy5yZWNpcGllbnRQaG9uZSB8fCBudWxsLFxuICAgICAgc3ViamVjdDogcGFyYW1zLnN1YmplY3QgfHwgbnVsbCxcbiAgICAgIGJvZHk6IHBhcmFtcy5ib2R5LFxuICAgICAgY2hhbm5lbDogcGFyYW1zLmNoYW5uZWwsXG4gICAgICB0cmlnZ2VyOiBwYXJhbXMudHJpZ2dlciBhcyBhbnksXG4gICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgIGF0dGVtcHRfY291bnQ6IDAsXG4gICAgICBzY2hlZHVsZWRfYXQ6IG5vdyxcbiAgICAgIG5leHRfcmV0cnlfYXQ6IG51bGwsIC8vIFdpbGwgYmUgc2V0IG9uIGZpcnN0IGZhaWx1cmVcbiAgICAgIGNyZWF0ZWRfYXQ6IG5vdyxcbiAgICB9KTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICAvLyBJZiB1bmlxdWUgY29uc3RyYWludCB2aW9sYXRpb24sIHRoYXQncyBva2F5IChpZGVtcG90ZW5jeSlcbiAgICBpZiAoZXJyb3IuY29kZSA9PT0gJzIzNTA1Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbnF1ZXVlaW5nIG5vdGlmaWNhdGlvbjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBMb2FkIG5vdGlmaWNhdGlvbiB0ZW1wbGF0ZSBmb3IgYSB0cmlnZ2VyXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkVGVtcGxhdGVGb3JUcmlnZ2VyKFxuICBidXNpbmVzc0lkOiBzdHJpbmcsXG4gIHVzZXJJZDogc3RyaW5nLFxuICB0cmlnZ2VyOiBOb3RpZmljYXRpb25UcmlnZ2VyLFxuICBjaGFubmVsOiAnZW1haWwnIHwgJ3NtcycsXG4gIHN1cGFiYXNlPzogU3VwYWJhc2VDbGllbnRcbik6IFByb21pc2U8YW55IHwgbnVsbD4ge1xuICBjb25zdCBjbGllbnQgPSBzdXBhYmFzZSB8fCBjcmVhdGVBZG1pbkNsaWVudCgpO1xuXG4gIGNvbnN0IHsgZGF0YTogdGVtcGxhdGUsIGVycm9yIH0gPSBhd2FpdCBjbGllbnRcbiAgICAuZnJvbSgnbm90aWZpY2F0aW9uX3RlbXBsYXRlcycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLmVxKCdidXNpbmVzc19pZCcsIGJ1c2luZXNzSWQpXG4gICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgIC5lcSgndHJpZ2dlcicsIHRyaWdnZXIpXG4gICAgLmVxKCdjaGFubmVsJywgY2hhbm5lbClcbiAgICAuZXEoJ2lzX2VuYWJsZWQnLCB0cnVlKVxuICAgIC5pcygnZGVsZXRlZF9hdCcsIG51bGwpXG4gICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgLmxpbWl0KDEpXG4gICAgLm1heWJlU2luZ2xlKCk7XG5cbiAgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgIT09ICdQR1JTVDExNicpIHsgLy8gUEdSU1QxMTYgPSBubyByb3dzIHJldHVybmVkXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyB0ZW1wbGF0ZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gdGVtcGxhdGU7XG59XG5cbi8qKlxuICogTWFpbiBmdW5jdGlvbiB0byBlbWl0IGEgbm90aWZpY2F0aW9uIGV2ZW50XG4gKiBUaGlzIGxvYWRzIGJvb2tpbmcgZGF0YSwgcmVzb2x2ZXMgdGVtcGxhdGVzLCBhbmQgZW5xdWV1ZXMgam9ic1xuICogXG4gKiBAcGFyYW0gYW1vdW50IE9wdGlvbmFsIGFtb3VudCBpbiBjZW50cyBmb3IgZmVlX2NoYXJnZWQgYW5kIHJlZnVuZGVkIHRyaWdnZXJzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbWl0Tm90aWZpY2F0aW9uKFxuICBidXNpbmVzc0lkOiBzdHJpbmcsXG4gIHRyaWdnZXI6IE5vdGlmaWNhdGlvblRyaWdnZXIsXG4gIGJvb2tpbmdJZDogc3RyaW5nLFxuICBzdXBhYmFzZT86IFN1cGFiYXNlQ2xpZW50LFxuICBhbW91bnQ/OiBudW1iZXJcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBjbGllbnQgPSBzdXBhYmFzZSB8fCBjcmVhdGVBZG1pbkNsaWVudCgpO1xuXG4gIC8vIENoZWNrIGlmIG5vdGlmaWNhdGlvbnMgYXJlIGVuYWJsZWQgZm9yIHRoaXMgYnVzaW5lc3NcbiAgY29uc3QgeyBkYXRhOiBidXNpbmVzcyB9ID0gYXdhaXQgY2xpZW50XG4gICAgLmZyb20oJ2J1c2luZXNzZXMnKVxuICAgIC5zZWxlY3QoJ2lkLCB1c2VyX2lkLCBuYW1lLCBzdXBwb3J0X2VtYWlsLCBwaG9uZSwgc3ViZG9tYWluLCB0aW1lem9uZSwgbm90aWZpY2F0aW9uc19lbmFibGVkJylcbiAgICAuZXEoJ2lkJywgYnVzaW5lc3NJZClcbiAgICAuc2luZ2xlKCk7XG5cbiAgaWYgKCFidXNpbmVzcykge1xuICAgIGNvbnNvbGUuZXJyb3IoYEJ1c2luZXNzICR7YnVzaW5lc3NJZH0gbm90IGZvdW5kYCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgbm90aWZpY2F0aW9ucyBhcmUgZGlzYWJsZWQgKEJhc2ljIFBsYW4pLCBza2lwIHNlbmRpbmcgbm90aWZpY2F0aW9uc1xuICAvLyBCYXNpYyBQbGFuIGFjY291bnRzIG9ubHkgc2hvdyBib29raW5nIGNvbmZpcm1hdGlvbnMsIG5vIFNNUy9lbWFpbCBub3RpZmljYXRpb25zXG4gIGlmIChidXNpbmVzcy5ub3RpZmljYXRpb25zX2VuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgY29uc29sZS5sb2coYFNraXBwaW5nIG5vdGlmaWNhdGlvbiBmb3IgYnVzaW5lc3MgJHtidXNpbmVzc0lkfSAtIEJhc2ljIFBsYW4gKG5vdGlmaWNhdGlvbnMgZGlzYWJsZWQpYCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdXNlcklkID0gYnVzaW5lc3MudXNlcl9pZDtcblxuICAvLyBMb2FkIGNvbXBsZXRlIGJvb2tpbmcgZGF0YSB3aXRoIGFsbCByZWxhdGlvbnNcbiAgY29uc3QgeyBkYXRhOiBib29raW5nLCBlcnJvcjogYm9va2luZ0Vycm9yIH0gPSBhd2FpdCBjbGllbnRcbiAgICAuZnJvbSgnYm9va2luZ3MnKVxuICAgIC5zZWxlY3QoYFxuICAgICAgKixcbiAgICAgIGN1c3RvbWVyczpjdXN0b21lcl9pZCAoXG4gICAgICAgIGlkLFxuICAgICAgICBuYW1lLFxuICAgICAgICBlbWFpbCxcbiAgICAgICAgcGhvbmVcbiAgICAgICksXG4gICAgICBzZXJ2aWNlczpzZXJ2aWNlX2lkIChcbiAgICAgICAgaWQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGR1cmF0aW9uX21pbixcbiAgICAgICAgcHJpY2VfY2VudHNcbiAgICAgICksXG4gICAgICBzdGFmZjpzdGFmZl9pZCAoXG4gICAgICAgIGlkLFxuICAgICAgICBuYW1lXG4gICAgICApXG4gICAgYClcbiAgICAuZXEoJ2lkJywgYm9va2luZ0lkKVxuICAgIC5lcSgnYnVzaW5lc3NfaWQnLCBidXNpbmVzc0lkKVxuICAgIC5pcygnZGVsZXRlZF9hdCcsIG51bGwpXG4gICAgLnNpbmdsZSgpO1xuXG4gIGlmIChib29raW5nRXJyb3IgfHwgIWJvb2tpbmcpIHtcbiAgICBjb25zb2xlLmVycm9yKGBCb29raW5nICR7Ym9va2luZ0lkfSBub3QgZm91bmQ6YCwgYm9va2luZ0Vycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3IgZmVlX2NoYXJnZWQgYW5kIHJlZnVuZGVkLCBsb2FkIHRoZSBsYXRlc3QgcGF5bWVudCBhbW91bnQgaWYgbm90IHByb3ZpZGVkXG4gIGxldCBmZWVBbW91bnQgPSBhbW91bnQ7XG4gIGlmICgodHJpZ2dlciA9PT0gJ2ZlZV9jaGFyZ2VkJyB8fCB0cmlnZ2VyID09PSAncmVmdW5kZWQnKSAmJiBmZWVBbW91bnQgPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHsgZGF0YTogbGF0ZXN0UGF5bWVudCB9ID0gYXdhaXQgY2xpZW50XG4gICAgICAuZnJvbSgnYm9va2luZ19wYXltZW50cycpXG4gICAgICAuc2VsZWN0KCdhbW91bnRfY2VudHMnKVxuICAgICAgLmVxKCdib29raW5nX2lkJywgYm9va2luZ0lkKVxuICAgICAgLmluKCdtb25leV9hY3Rpb24nLCB0cmlnZ2VyID09PSAnZmVlX2NoYXJnZWQnID8gWydub19zaG93X2ZlZScsICdjYW5jZWxfZmVlJ10gOiBbJ3JlZnVuZCddKVxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgICAubGltaXQoMSlcbiAgICAgIC5tYXliZVNpbmdsZSgpO1xuICAgIFxuICAgIGlmIChsYXRlc3RQYXltZW50KSB7XG4gICAgICBmZWVBbW91bnQgPSBsYXRlc3RQYXltZW50LmFtb3VudF9jZW50cztcbiAgICB9XG4gIH1cblxuICAvLyBCdWlsZCBub3RpZmljYXRpb24gZGF0YVxuICBjb25zdCBub3RpZmljYXRpb25EYXRhOiBOb3RpZmljYXRpb25EYXRhID0ge1xuICAgIGJvb2tpbmc6IHtcbiAgICAgIGlkOiBib29raW5nLmlkLFxuICAgICAgc3RhcnRfYXQ6IGJvb2tpbmcuc3RhcnRfYXQsXG4gICAgICBlbmRfYXQ6IGJvb2tpbmcuZW5kX2F0LFxuICAgICAgZmluYWxfcHJpY2VfY2VudHM6IGJvb2tpbmcuZmluYWxfcHJpY2VfY2VudHMsXG4gICAgICBwcmljZV9jZW50czogYm9va2luZy5wcmljZV9jZW50cyxcbiAgICAgIHN0YWZmX2lkOiBib29raW5nLnN0YWZmX2lkLFxuICAgICAgc3RhdHVzOiBib29raW5nLnN0YXR1cyxcbiAgICB9LFxuICAgIGN1c3RvbWVyOiBib29raW5nLmN1c3RvbWVycyA/IHtcbiAgICAgIG5hbWU6IGJvb2tpbmcuY3VzdG9tZXJzLm5hbWUsXG4gICAgICBlbWFpbDogYm9va2luZy5jdXN0b21lcnMuZW1haWwsXG4gICAgICBwaG9uZTogYm9va2luZy5jdXN0b21lcnMucGhvbmUgfHwgdW5kZWZpbmVkLFxuICAgIH0gOiB1bmRlZmluZWQsXG4gICAgc2VydmljZTogYm9va2luZy5zZXJ2aWNlcyA/IHtcbiAgICAgIG5hbWU6IGJvb2tpbmcuc2VydmljZXMubmFtZSxcbiAgICAgIGR1cmF0aW9uX21pbjogYm9va2luZy5zZXJ2aWNlcy5kdXJhdGlvbl9taW4sXG4gICAgICBwcmljZV9jZW50czogYm9va2luZy5zZXJ2aWNlcy5wcmljZV9jZW50cyxcbiAgICB9IDogdW5kZWZpbmVkLFxuICAgIHN0YWZmOiBib29raW5nLnN0YWZmID8ge1xuICAgICAgbmFtZTogYm9va2luZy5zdGFmZi5uYW1lLFxuICAgIH0gOiB1bmRlZmluZWQsXG4gICAgYnVzaW5lc3M6IHtcbiAgICAgIG5hbWU6IGJ1c2luZXNzLm5hbWUsXG4gICAgICBzdXBwb3J0X2VtYWlsOiBidXNpbmVzcy5zdXBwb3J0X2VtYWlsIHx8IHVuZGVmaW5lZCxcbiAgICAgIHBob25lOiBidXNpbmVzcy5waG9uZSB8fCB1bmRlZmluZWQsXG4gICAgICBzdWJkb21haW46IGJ1c2luZXNzLnN1YmRvbWFpbiB8fCB1bmRlZmluZWQsXG4gICAgICB0aW1lem9uZTogYnVzaW5lc3MudGltZXpvbmUgfHwgJ0FtZXJpY2EvTmV3X1lvcmsnLFxuICAgIH0sXG4gICAgYm9va2luZ191cmw6IGJ1c2luZXNzLnN1YmRvbWFpbiBcbiAgICAgID8gYGh0dHBzOi8vJHtidXNpbmVzcy5zdWJkb21haW59LnRpdGhpLmNvbS9jb25maXJtL1RJVEhJLSR7Ym9va2luZy5pZC5zbGljZSgwLCA4KS50b1VwcGVyQ2FzZSgpfWBcbiAgICAgIDogdW5kZWZpbmVkLFxuICAgIGFtb3VudDogZmVlQW1vdW50LCAvLyBGb3IgZmVlX2NoYXJnZWQgYW5kIHJlZnVuZGVkIHRyaWdnZXJzXG4gIH07XG5cbiAgLy8gTG9hZCB0ZW1wbGF0ZXMgZm9yIHRoaXMgdHJpZ2dlclxuICBjb25zdCBlbWFpbFRlbXBsYXRlID0gYXdhaXQgbG9hZFRlbXBsYXRlRm9yVHJpZ2dlcihidXNpbmVzc0lkLCB1c2VySWQsIHRyaWdnZXIsICdlbWFpbCcsIGNsaWVudCk7XG4gIGNvbnN0IHNtc1RlbXBsYXRlID0gYXdhaXQgbG9hZFRlbXBsYXRlRm9yVHJpZ2dlcihidXNpbmVzc0lkLCB1c2VySWQsIHRyaWdnZXIsICdzbXMnLCBjbGllbnQpO1xuXG4gIGNvbnN0IHRpbWV6b25lID0gYnVzaW5lc3MudGltZXpvbmUgfHwgJ0FtZXJpY2EvTmV3X1lvcmsnO1xuXG4gIC8vIEVucXVldWUgZW1haWwgbm90aWZpY2F0aW9uIGlmIHRlbXBsYXRlIGV4aXN0cyBhbmQgY3VzdG9tZXIgaGFzIGVtYWlsXG4gIGlmIChlbWFpbFRlbXBsYXRlICYmIG5vdGlmaWNhdGlvbkRhdGEuY3VzdG9tZXI/LmVtYWlsKSB7XG4gICAgY29uc3QgcmVuZGVyZWRCb2R5ID0gcmVuZGVyVGVtcGxhdGUoZW1haWxUZW1wbGF0ZS5ib2R5X21hcmtkb3duLCBub3RpZmljYXRpb25EYXRhLCB0aW1lem9uZSk7XG4gICAgY29uc3QgcmVuZGVyZWRTdWJqZWN0ID0gZW1haWxUZW1wbGF0ZS5zdWJqZWN0XG4gICAgICA/IHJlbmRlclRlbXBsYXRlKGVtYWlsVGVtcGxhdGUuc3ViamVjdCwgbm90aWZpY2F0aW9uRGF0YSwgdGltZXpvbmUpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGF3YWl0IGVucXVldWVOb3RpZmljYXRpb24oe1xuICAgICAgYnVzaW5lc3NJZCxcbiAgICAgIHVzZXJJZCxcbiAgICAgIGJvb2tpbmdJZCxcbiAgICAgIHRyaWdnZXIsXG4gICAgICByZWNpcGllbnRFbWFpbDogbm90aWZpY2F0aW9uRGF0YS5jdXN0b21lci5lbWFpbCxcbiAgICAgIHRlbXBsYXRlSWQ6IGVtYWlsVGVtcGxhdGUuaWQsXG4gICAgICBzdWJqZWN0OiByZW5kZXJlZFN1YmplY3QsXG4gICAgICBib2R5OiByZW5kZXJlZEJvZHksXG4gICAgICBjaGFubmVsOiAnZW1haWwnLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gRW5xdWV1ZSBTTVMgbm90aWZpY2F0aW9uIGlmIHRlbXBsYXRlIGV4aXN0cyBhbmQgY3VzdG9tZXIgaGFzIHBob25lXG4gIGlmIChzbXNUZW1wbGF0ZSAmJiBub3RpZmljYXRpb25EYXRhLmN1c3RvbWVyPy5waG9uZSkge1xuICAgIGNvbnN0IHJlbmRlcmVkQm9keSA9IHJlbmRlclRlbXBsYXRlKHNtc1RlbXBsYXRlLmJvZHlfbWFya2Rvd24sIG5vdGlmaWNhdGlvbkRhdGEsIHRpbWV6b25lKTtcblxuICAgIGF3YWl0IGVucXVldWVOb3RpZmljYXRpb24oe1xuICAgICAgYnVzaW5lc3NJZCxcbiAgICAgIHVzZXJJZCxcbiAgICAgIGJvb2tpbmdJZCxcbiAgICAgIHRyaWdnZXIsXG4gICAgICByZWNpcGllbnRQaG9uZTogbm90aWZpY2F0aW9uRGF0YS5jdXN0b21lci5waG9uZSxcbiAgICAgIHRlbXBsYXRlSWQ6IHNtc1RlbXBsYXRlLmlkLFxuICAgICAgYm9keTogcmVuZGVyZWRCb2R5LFxuICAgICAgY2hhbm5lbDogJ3NtcycsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgbm90aWZpY2F0aW9uIGpvYiBmcm9tIHRlbXBsYXRlIGFuZCBkYXRhIChsZWdhY3kgZnVuY3Rpb24sIHVzZSBlbWl0Tm90aWZpY2F0aW9uKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlTm90aWZpY2F0aW9uRnJvbVRlbXBsYXRlKHBhcmFtczoge1xuICBidXNpbmVzc0lkOiBzdHJpbmc7XG4gIHVzZXJJZDogc3RyaW5nO1xuICBib29raW5nSWQ/OiBzdHJpbmc7XG4gIHRyaWdnZXI6IE5vdGlmaWNhdGlvblRyaWdnZXI7XG4gIGRhdGE6IE5vdGlmaWNhdGlvbkRhdGE7XG59KTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHsgYnVzaW5lc3NJZCwgdXNlcklkLCBib29raW5nSWQsIHRyaWdnZXIsIGRhdGEgfSA9IHBhcmFtcztcblxuICBpZiAoIWJvb2tpbmdJZCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ2NyZWF0ZU5vdGlmaWNhdGlvbkZyb21UZW1wbGF0ZSByZXF1aXJlcyBib29raW5nSWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBVc2UgdGhlIG1haW4gZW1pdE5vdGlmaWNhdGlvbiBmdW5jdGlvblxuICBhd2FpdCBlbWl0Tm90aWZpY2F0aW9uKGJ1c2luZXNzSWQsIHRyaWdnZXIsIGJvb2tpbmdJZCk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnNcbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZTogRGF0ZSwgdGltZXpvbmU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBmb3JtYXRJblRpbWVab25lKGRhdGUudG9JU09TdHJpbmcoKSwgdGltZXpvbmUsIHtcbiAgICB3ZWVrZGF5OiAnbG9uZycsXG4gICAgeWVhcjogJ251bWVyaWMnLFxuICAgIG1vbnRoOiAnbG9uZycsXG4gICAgZGF5OiAnbnVtZXJpYycsXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUaW1lKGRhdGU6IERhdGUsIHRpbWV6b25lOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gZm9ybWF0SW5UaW1lWm9uZShkYXRlLnRvSVNPU3RyaW5nKCksIHRpbWV6b25lLCB7XG4gICAgaG91cjogJ251bWVyaWMnLFxuICAgIG1pbnV0ZTogJzItZGlnaXQnLFxuICAgIGhvdXIxMjogdHJ1ZSxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFByaWNlKGNlbnRzOiBudW1iZXIpOiBzdHJpbmcge1xuICByZXR1cm4gYCQkeyhjZW50cyAvIDEwMCkudG9GaXhlZCgyKX1gO1xufVxuXG5cbiJdLCJuYW1lcyI6WyJjcmVhdGVBZG1pbkNsaWVudCIsImZvcm1hdEluVGltZVpvbmUiLCJBTExPV0VEX1BMQUNFSE9MREVSUyIsInZhbGlkYXRlUGxhY2Vob2xkZXJzIiwidGVtcGxhdGUiLCJwbGFjZWhvbGRlclJlZ2V4IiwibWF0Y2hlcyIsIkFycmF5IiwiZnJvbSIsIm1hdGNoQWxsIiwiZm91bmRQbGFjZWhvbGRlcnMiLCJtYXAiLCJtIiwiaW52YWxpZCIsImZpbHRlciIsInAiLCJpbmNsdWRlcyIsInZhbGlkIiwibGVuZ3RoIiwicmVuZGVyVGVtcGxhdGUiLCJkYXRhIiwidGltZXpvbmUiLCJyZW5kZXJlZCIsInR6IiwiYnVzaW5lc3MiLCJjdXN0b21lciIsInJlcGxhY2UiLCJuYW1lIiwiZW1haWwiLCJwaG9uZSIsInNlcnZpY2UiLCJTdHJpbmciLCJkdXJhdGlvbl9taW4iLCJmb3JtYXRQcmljZSIsInByaWNlX2NlbnRzIiwic3RhZmYiLCJib29raW5nIiwic3RhcnREYXRlIiwiRGF0ZSIsInN0YXJ0X2F0IiwiZm9ybWF0RGF0ZSIsImZvcm1hdFRpbWUiLCJpZCIsInNsaWNlIiwidG9VcHBlckNhc2UiLCJhbW91bnQiLCJmaW5hbF9wcmljZV9jZW50cyIsInN1cHBvcnRfZW1haWwiLCJib29raW5nX3VybCIsInN1YmRvbWFpbiIsImJvb2tpbmdDb2RlIiwidXJsIiwidW5kZWZpbmVkIiwiZW5xdWV1ZU5vdGlmaWNhdGlvbiIsInBhcmFtcyIsInN1cGFiYXNlIiwiYm9va2luZ0lkIiwiZXhpc3RpbmciLCJzZWxlY3QiLCJlcSIsInRyaWdnZXIiLCJjaGFubmVsIiwibGltaXQiLCJzaW5nbGUiLCJub3ciLCJ0b0lTT1N0cmluZyIsImVycm9yIiwiaW5zZXJ0IiwidXNlcl9pZCIsInVzZXJJZCIsImJ1c2luZXNzX2lkIiwiYnVzaW5lc3NJZCIsImJvb2tpbmdfaWQiLCJ0ZW1wbGF0ZV9pZCIsInRlbXBsYXRlSWQiLCJyZWNpcGllbnRfZW1haWwiLCJyZWNpcGllbnRFbWFpbCIsInJlY2lwaWVudF9waG9uZSIsInJlY2lwaWVudFBob25lIiwic3ViamVjdCIsImJvZHkiLCJzdGF0dXMiLCJhdHRlbXB0X2NvdW50Iiwic2NoZWR1bGVkX2F0IiwibmV4dF9yZXRyeV9hdCIsImNyZWF0ZWRfYXQiLCJjb2RlIiwiY29uc29sZSIsImxvYWRUZW1wbGF0ZUZvclRyaWdnZXIiLCJjbGllbnQiLCJpcyIsIm9yZGVyIiwiYXNjZW5kaW5nIiwibWF5YmVTaW5nbGUiLCJlbWl0Tm90aWZpY2F0aW9uIiwibm90aWZpY2F0aW9uc19lbmFibGVkIiwibG9nIiwiYm9va2luZ0Vycm9yIiwiZmVlQW1vdW50IiwibGF0ZXN0UGF5bWVudCIsImluIiwiYW1vdW50X2NlbnRzIiwibm90aWZpY2F0aW9uRGF0YSIsImVuZF9hdCIsInN0YWZmX2lkIiwiY3VzdG9tZXJzIiwic2VydmljZXMiLCJlbWFpbFRlbXBsYXRlIiwic21zVGVtcGxhdGUiLCJyZW5kZXJlZEJvZHkiLCJib2R5X21hcmtkb3duIiwicmVuZGVyZWRTdWJqZWN0IiwiY3JlYXRlTm90aWZpY2F0aW9uRnJvbVRlbXBsYXRlIiwiZGF0ZSIsIndlZWtkYXkiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJob3VyIiwibWludXRlIiwiaG91cjEyIiwiY2VudHMiLCJ0b0ZpeGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/notifications.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/stripe.ts":
/*!***************************!*\
  !*** ./src/lib/stripe.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAccountLink: () => (/* binding */ createAccountLink),\n/* harmony export */   createConnectAccount: () => (/* binding */ createConnectAccount),\n/* harmony export */   createOrGetCustomer: () => (/* binding */ createOrGetCustomer),\n/* harmony export */   createPaymentIntent: () => (/* binding */ createPaymentIntent),\n/* harmony export */   createRefund: () => (/* binding */ createRefund),\n/* harmony export */   createSetupIntent: () => (/* binding */ createSetupIntent),\n/* harmony export */   createSubscription: () => (/* binding */ createSubscription),\n/* harmony export */   getPaymentMethodFromSetupIntent: () => (/* binding */ getPaymentMethodFromSetupIntent),\n/* harmony export */   getStripeClient: () => (/* binding */ getStripeClient),\n/* harmony export */   verifyConnectAccount: () => (/* binding */ verifyConnectAccount)\n/* harmony export */ });\n/* harmony import */ var stripe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stripe */ \"(rsc)/../../node_modules/stripe/esm/stripe.esm.node.js\");\n\nconst stripeSecretKey = process.env.STRIPE_SECRET_KEY;\nif (!stripeSecretKey) {\n    console.warn(\"STRIPE_SECRET_KEY not set - Stripe features will not work\");\n}\n/**\n * Get Stripe client instance\n */ function getStripeClient() {\n    if (!stripeSecretKey) {\n        throw new Error(\"STRIPE_SECRET_KEY environment variable is not set\");\n    }\n    return new stripe__WEBPACK_IMPORTED_MODULE_0__[\"default\"](stripeSecretKey, {\n        apiVersion: \"2024-11-20.acacia\"\n    });\n}\n/**\n * Create a Stripe Connect Express account\n * Returns the account ID\n */ async function createConnectAccount(userId, email) {\n    const stripe = getStripeClient();\n    const account = await stripe.accounts.create({\n        type: \"express\",\n        email,\n        capabilities: {\n            card_payments: {\n                requested: true\n            },\n            transfers: {\n                requested: true\n            }\n        },\n        metadata: {\n            user_id: userId\n        }\n    });\n    return account.id;\n}\n/**\n * Create an Account Link for Stripe Connect onboarding\n * Returns the URL to redirect the user to\n */ async function createAccountLink(accountId, returnUrl, refreshUrl) {\n    const stripe = getStripeClient();\n    const accountLink = await stripe.accountLinks.create({\n        account: accountId,\n        type: \"account_onboarding\",\n        return_url: returnUrl,\n        refresh_url: refreshUrl\n    });\n    return accountLink.url;\n}\n/**\n * Create or retrieve a Stripe Customer\n */ async function createOrGetCustomer(email, name, metadata) {\n    const stripe = getStripeClient();\n    // Search for existing customer by email\n    const existingCustomers = await stripe.customers.list({\n        email,\n        limit: 1\n    });\n    if (existingCustomers.data.length > 0) {\n        return existingCustomers.data[0].id;\n    }\n    // Create new customer\n    const customer = await stripe.customers.create({\n        email,\n        name,\n        metadata: metadata || {}\n    });\n    return customer.id;\n}\n/**\n * Create a SetupIntent to save a card without charging\n */ async function createSetupIntent(customerId, metadata) {\n    const stripe = getStripeClient();\n    const setupIntent = await stripe.setupIntents.create({\n        customer: customerId,\n        payment_method_types: [\n            \"card\"\n        ],\n        metadata: metadata || {}\n    });\n    return {\n        setupIntentId: setupIntent.id,\n        clientSecret: setupIntent.client_secret\n    };\n}\n/**\n * Create a subscription for the business owner ($11.99/mo)\n * Includes 7-day trial period as per app design\n */ async function createSubscription(customerId, priceId, metadata, paymentMethodId // Optional: if owner already has payment method ready\n) {\n    const stripe = getStripeClient();\n    const subscriptionParams = {\n        customer: customerId,\n        items: [\n            {\n                price: priceId\n            }\n        ],\n        payment_settings: {\n            save_default_payment_method: \"on_subscription\"\n        },\n        expand: [\n            \"latest_invoice.payment_intent\"\n        ],\n        metadata: metadata || {},\n        // 7-day trial period as per app design\n        trial_period_days: 7\n    };\n    // If payment method is provided, attach it; otherwise subscription will be incomplete\n    if (paymentMethodId) {\n        subscriptionParams.default_payment_method = paymentMethodId;\n        subscriptionParams.payment_behavior = \"default_incomplete\";\n    } else {\n        // Subscription will be incomplete until payment method is added\n        subscriptionParams.payment_behavior = \"default_incomplete\";\n    }\n    const subscription = await stripe.subscriptions.create(subscriptionParams);\n    return {\n        subscriptionId: subscription.id,\n        status: subscription.status,\n        current_period_end: subscription.current_period_end,\n        trial_end: subscription.trial_end\n    };\n}\n/**\n * Create a PaymentIntent with Connect destination charge\n * This charges the customer and sends funds to the connected account\n * Supports off-session charges for saved payment methods\n * \n * Returns the PaymentIntent with status information\n */ async function createPaymentIntent(params) {\n    const stripe = getStripeClient();\n    const { amount, customerId, paymentMethodId, connectAccountId, applicationFee, metadata, offSession = false } = params;\n    // Create PaymentIntent on platform account with Connect destination\n    const paymentIntentParams = {\n        amount,\n        currency: \"usd\",\n        customer: customerId,\n        payment_method: paymentMethodId,\n        on_behalf_of: connectAccountId,\n        transfer_data: {\n            destination: connectAccountId\n        },\n        application_fee_amount: applicationFee,\n        metadata: metadata || {}\n    };\n    // For off-session charges, set confirmation method and off_session flag\n    if (offSession) {\n        paymentIntentParams.confirmation_method = \"automatic\";\n        paymentIntentParams.confirm = true;\n        paymentIntentParams.off_session = true;\n        paymentIntentParams.payment_method_options = {\n            card: {\n                request_three_d_secure: \"automatic\"\n            }\n        };\n    } else {\n        paymentIntentParams.confirmation_method = \"manual\";\n        paymentIntentParams.confirm = true;\n    }\n    const paymentIntent = await stripe.paymentIntents.create(paymentIntentParams);\n    return {\n        paymentIntentId: paymentIntent.id,\n        clientSecret: paymentIntent.client_secret || \"\",\n        status: paymentIntent.status,\n        requiresAction: paymentIntent.status === \"requires_action\" || paymentIntent.status === \"requires_payment_method\"\n    };\n}\n/**\n * Create a refund for a PaymentIntent\n */ async function createRefund(paymentIntentId, amount // optional amount to refund (partial refund), if not provided, full refund\n) {\n    const stripe = getStripeClient();\n    const refundParams = {\n        payment_intent: paymentIntentId\n    };\n    if (amount !== undefined) {\n        refundParams.amount = amount;\n    }\n    const refund = await stripe.refunds.create(refundParams);\n    return {\n        refundId: refund.id,\n        amount: refund.amount\n    };\n}\n/**\n * Get payment method from a SetupIntent\n */ async function getPaymentMethodFromSetupIntent(setupIntentId) {\n    const stripe = getStripeClient();\n    const setupIntent = await stripe.setupIntents.retrieve(setupIntentId);\n    if (typeof setupIntent.payment_method === \"string\") {\n        return setupIntent.payment_method;\n    }\n    if (setupIntent.payment_method) {\n        return setupIntent.payment_method.id;\n    }\n    return null;\n}\n/**\n * Verify a Connect account is active\n */ async function verifyConnectAccount(accountId) {\n    try {\n        const stripe = getStripeClient();\n        const account = await stripe.accounts.retrieve(accountId);\n        return account.details_submitted && account.charges_enabled;\n    } catch (error) {\n        console.error(\"Error verifying Connect account:\", error);\n        return false;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RCxFQUFFLE9BQU9DLE9BQU87UUFDZG5HLFFBQVFtRyxLQUFLLENBQUMsb0NBQW9DQTtRQUNsRCxPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL3NyYy9saWIvc3RyaXBlLnRzPzc5OGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFN0cmlwZSBmcm9tICdzdHJpcGUnO1xuXG5jb25zdCBzdHJpcGVTZWNyZXRLZXkgPSBwcm9jZXNzLmVudi5TVFJJUEVfU0VDUkVUX0tFWTtcblxuaWYgKCFzdHJpcGVTZWNyZXRLZXkpIHtcbiAgY29uc29sZS53YXJuKCdTVFJJUEVfU0VDUkVUX0tFWSBub3Qgc2V0IC0gU3RyaXBlIGZlYXR1cmVzIHdpbGwgbm90IHdvcmsnKTtcbn1cblxuLyoqXG4gKiBHZXQgU3RyaXBlIGNsaWVudCBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RyaXBlQ2xpZW50KCk6IFN0cmlwZSB7XG4gIGlmICghc3RyaXBlU2VjcmV0S2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTVFJJUEVfU0VDUkVUX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3Qgc2V0Jyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBTdHJpcGUoc3RyaXBlU2VjcmV0S2V5LCB7XG4gICAgYXBpVmVyc2lvbjogJzIwMjQtMTEtMjAuYWNhY2lhJyxcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgU3RyaXBlIENvbm5lY3QgRXhwcmVzcyBhY2NvdW50XG4gKiBSZXR1cm5zIHRoZSBhY2NvdW50IElEXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb25uZWN0QWNjb3VudCh1c2VySWQ6IHN0cmluZywgZW1haWw6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IHN0cmlwZSA9IGdldFN0cmlwZUNsaWVudCgpO1xuXG4gIGNvbnN0IGFjY291bnQgPSBhd2FpdCBzdHJpcGUuYWNjb3VudHMuY3JlYXRlKHtcbiAgICB0eXBlOiAnZXhwcmVzcycsXG4gICAgZW1haWwsXG4gICAgY2FwYWJpbGl0aWVzOiB7XG4gICAgICBjYXJkX3BheW1lbnRzOiB7IHJlcXVlc3RlZDogdHJ1ZSB9LFxuICAgICAgdHJhbnNmZXJzOiB7IHJlcXVlc3RlZDogdHJ1ZSB9LFxuICAgIH0sXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICB9LFxuICB9KTtcblxuICByZXR1cm4gYWNjb3VudC5pZDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gQWNjb3VudCBMaW5rIGZvciBTdHJpcGUgQ29ubmVjdCBvbmJvYXJkaW5nXG4gKiBSZXR1cm5zIHRoZSBVUkwgdG8gcmVkaXJlY3QgdGhlIHVzZXIgdG9cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUFjY291bnRMaW5rKFxuICBhY2NvdW50SWQ6IHN0cmluZyxcbiAgcmV0dXJuVXJsOiBzdHJpbmcsXG4gIHJlZnJlc2hVcmw6IHN0cmluZ1xuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3Qgc3RyaXBlID0gZ2V0U3RyaXBlQ2xpZW50KCk7XG5cbiAgY29uc3QgYWNjb3VudExpbmsgPSBhd2FpdCBzdHJpcGUuYWNjb3VudExpbmtzLmNyZWF0ZSh7XG4gICAgYWNjb3VudDogYWNjb3VudElkLFxuICAgIHR5cGU6ICdhY2NvdW50X29uYm9hcmRpbmcnLFxuICAgIHJldHVybl91cmw6IHJldHVyblVybCxcbiAgICByZWZyZXNoX3VybDogcmVmcmVzaFVybCxcbiAgfSk7XG5cbiAgcmV0dXJuIGFjY291bnRMaW5rLnVybDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgb3IgcmV0cmlldmUgYSBTdHJpcGUgQ3VzdG9tZXJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU9yR2V0Q3VzdG9tZXIoXG4gIGVtYWlsOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBzdHJpcGUgPSBnZXRTdHJpcGVDbGllbnQoKTtcblxuICAvLyBTZWFyY2ggZm9yIGV4aXN0aW5nIGN1c3RvbWVyIGJ5IGVtYWlsXG4gIGNvbnN0IGV4aXN0aW5nQ3VzdG9tZXJzID0gYXdhaXQgc3RyaXBlLmN1c3RvbWVycy5saXN0KHtcbiAgICBlbWFpbCxcbiAgICBsaW1pdDogMSxcbiAgfSk7XG5cbiAgaWYgKGV4aXN0aW5nQ3VzdG9tZXJzLmRhdGEubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBleGlzdGluZ0N1c3RvbWVycy5kYXRhWzBdLmlkO1xuICB9XG5cbiAgLy8gQ3JlYXRlIG5ldyBjdXN0b21lclxuICBjb25zdCBjdXN0b21lciA9IGF3YWl0IHN0cmlwZS5jdXN0b21lcnMuY3JlYXRlKHtcbiAgICBlbWFpbCxcbiAgICBuYW1lLFxuICAgIG1ldGFkYXRhOiBtZXRhZGF0YSB8fCB7fSxcbiAgfSk7XG5cbiAgcmV0dXJuIGN1c3RvbWVyLmlkO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIFNldHVwSW50ZW50IHRvIHNhdmUgYSBjYXJkIHdpdGhvdXQgY2hhcmdpbmdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNldHVwSW50ZW50KFxuICBjdXN0b21lcklkOiBzdHJpbmcsXG4gIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuKTogUHJvbWlzZTx7IHNldHVwSW50ZW50SWQ6IHN0cmluZzsgY2xpZW50U2VjcmV0OiBzdHJpbmcgfT4ge1xuICBjb25zdCBzdHJpcGUgPSBnZXRTdHJpcGVDbGllbnQoKTtcblxuICBjb25zdCBzZXR1cEludGVudCA9IGF3YWl0IHN0cmlwZS5zZXR1cEludGVudHMuY3JlYXRlKHtcbiAgICBjdXN0b21lcjogY3VzdG9tZXJJZCxcbiAgICBwYXltZW50X21ldGhvZF90eXBlczogWydjYXJkJ10sXG4gICAgbWV0YWRhdGE6IG1ldGFkYXRhIHx8IHt9LFxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHNldHVwSW50ZW50SWQ6IHNldHVwSW50ZW50LmlkLFxuICAgIGNsaWVudFNlY3JldDogc2V0dXBJbnRlbnQuY2xpZW50X3NlY3JldCEsXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc3Vic2NyaXB0aW9uIGZvciB0aGUgYnVzaW5lc3Mgb3duZXIgKCQxMS45OS9tbylcbiAqIEluY2x1ZGVzIDctZGF5IHRyaWFsIHBlcmlvZCBhcyBwZXIgYXBwIGRlc2lnblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlU3Vic2NyaXB0aW9uKFxuICBjdXN0b21lcklkOiBzdHJpbmcsXG4gIHByaWNlSWQ6IHN0cmluZyxcbiAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICBwYXltZW50TWV0aG9kSWQ/OiBzdHJpbmcgLy8gT3B0aW9uYWw6IGlmIG93bmVyIGFscmVhZHkgaGFzIHBheW1lbnQgbWV0aG9kIHJlYWR5XG4pOiBQcm9taXNlPHsgc3Vic2NyaXB0aW9uSWQ6IHN0cmluZzsgc3RhdHVzOiBzdHJpbmc7IGN1cnJlbnRfcGVyaW9kX2VuZD86IG51bWJlcjsgdHJpYWxfZW5kPzogbnVtYmVyIH0+IHtcbiAgY29uc3Qgc3RyaXBlID0gZ2V0U3RyaXBlQ2xpZW50KCk7XG5cbiAgY29uc3Qgc3Vic2NyaXB0aW9uUGFyYW1zOiBTdHJpcGUuU3Vic2NyaXB0aW9uQ3JlYXRlUGFyYW1zID0ge1xuICAgIGN1c3RvbWVyOiBjdXN0b21lcklkLFxuICAgIGl0ZW1zOiBbeyBwcmljZTogcHJpY2VJZCB9XSxcbiAgICBwYXltZW50X3NldHRpbmdzOiB7IHNhdmVfZGVmYXVsdF9wYXltZW50X21ldGhvZDogJ29uX3N1YnNjcmlwdGlvbicgfSxcbiAgICBleHBhbmQ6IFsnbGF0ZXN0X2ludm9pY2UucGF5bWVudF9pbnRlbnQnXSxcbiAgICBtZXRhZGF0YTogbWV0YWRhdGEgfHwge30sXG4gICAgLy8gNy1kYXkgdHJpYWwgcGVyaW9kIGFzIHBlciBhcHAgZGVzaWduXG4gICAgdHJpYWxfcGVyaW9kX2RheXM6IDcsXG4gIH07XG5cbiAgLy8gSWYgcGF5bWVudCBtZXRob2QgaXMgcHJvdmlkZWQsIGF0dGFjaCBpdDsgb3RoZXJ3aXNlIHN1YnNjcmlwdGlvbiB3aWxsIGJlIGluY29tcGxldGVcbiAgaWYgKHBheW1lbnRNZXRob2RJZCkge1xuICAgIHN1YnNjcmlwdGlvblBhcmFtcy5kZWZhdWx0X3BheW1lbnRfbWV0aG9kID0gcGF5bWVudE1ldGhvZElkO1xuICAgIHN1YnNjcmlwdGlvblBhcmFtcy5wYXltZW50X2JlaGF2aW9yID0gJ2RlZmF1bHRfaW5jb21wbGV0ZSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3Vic2NyaXB0aW9uIHdpbGwgYmUgaW5jb21wbGV0ZSB1bnRpbCBwYXltZW50IG1ldGhvZCBpcyBhZGRlZFxuICAgIHN1YnNjcmlwdGlvblBhcmFtcy5wYXltZW50X2JlaGF2aW9yID0gJ2RlZmF1bHRfaW5jb21wbGV0ZSc7XG4gIH1cblxuICBjb25zdCBzdWJzY3JpcHRpb24gPSBhd2FpdCBzdHJpcGUuc3Vic2NyaXB0aW9ucy5jcmVhdGUoc3Vic2NyaXB0aW9uUGFyYW1zKTtcblxuICByZXR1cm4ge1xuICAgIHN1YnNjcmlwdGlvbklkOiBzdWJzY3JpcHRpb24uaWQsXG4gICAgc3RhdHVzOiBzdWJzY3JpcHRpb24uc3RhdHVzLFxuICAgIGN1cnJlbnRfcGVyaW9kX2VuZDogc3Vic2NyaXB0aW9uLmN1cnJlbnRfcGVyaW9kX2VuZCxcbiAgICB0cmlhbF9lbmQ6IHN1YnNjcmlwdGlvbi50cmlhbF9lbmQsXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgUGF5bWVudEludGVudCB3aXRoIENvbm5lY3QgZGVzdGluYXRpb24gY2hhcmdlXG4gKiBUaGlzIGNoYXJnZXMgdGhlIGN1c3RvbWVyIGFuZCBzZW5kcyBmdW5kcyB0byB0aGUgY29ubmVjdGVkIGFjY291bnRcbiAqIFN1cHBvcnRzIG9mZi1zZXNzaW9uIGNoYXJnZXMgZm9yIHNhdmVkIHBheW1lbnQgbWV0aG9kc1xuICogXG4gKiBSZXR1cm5zIHRoZSBQYXltZW50SW50ZW50IHdpdGggc3RhdHVzIGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVQYXltZW50SW50ZW50KHBhcmFtczoge1xuICBhbW91bnQ6IG51bWJlcjsgLy8gaW4gY2VudHNcbiAgY3VzdG9tZXJJZDogc3RyaW5nO1xuICBwYXltZW50TWV0aG9kSWQ6IHN0cmluZztcbiAgY29ubmVjdEFjY291bnRJZDogc3RyaW5nO1xuICBhcHBsaWNhdGlvbkZlZTogbnVtYmVyOyAvLyBwbGF0Zm9ybSBmZWUgaW4gY2VudHMgKDElIG9mIGFtb3VudClcbiAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICBvZmZTZXNzaW9uPzogYm9vbGVhbjsgLy8gSWYgdHJ1ZSwgYXR0ZW1wdHMgb2ZmLXNlc3Npb24gY2hhcmdlIChmb3Igc2F2ZWQgY2FyZHMpXG59KTogUHJvbWlzZTx7IFxuICBwYXltZW50SW50ZW50SWQ6IHN0cmluZzsgXG4gIGNsaWVudFNlY3JldDogc3RyaW5nO1xuICBzdGF0dXM6IHN0cmluZztcbiAgcmVxdWlyZXNBY3Rpb24/OiBib29sZWFuO1xufT4ge1xuICBjb25zdCBzdHJpcGUgPSBnZXRTdHJpcGVDbGllbnQoKTtcbiAgY29uc3QgeyBhbW91bnQsIGN1c3RvbWVySWQsIHBheW1lbnRNZXRob2RJZCwgY29ubmVjdEFjY291bnRJZCwgYXBwbGljYXRpb25GZWUsIG1ldGFkYXRhLCBvZmZTZXNzaW9uID0gZmFsc2UgfSA9IHBhcmFtcztcblxuICAvLyBDcmVhdGUgUGF5bWVudEludGVudCBvbiBwbGF0Zm9ybSBhY2NvdW50IHdpdGggQ29ubmVjdCBkZXN0aW5hdGlvblxuICBjb25zdCBwYXltZW50SW50ZW50UGFyYW1zOiBTdHJpcGUuUGF5bWVudEludGVudENyZWF0ZVBhcmFtcyA9IHtcbiAgICBhbW91bnQsXG4gICAgY3VycmVuY3k6ICd1c2QnLFxuICAgIGN1c3RvbWVyOiBjdXN0b21lcklkLFxuICAgIHBheW1lbnRfbWV0aG9kOiBwYXltZW50TWV0aG9kSWQsXG4gICAgb25fYmVoYWxmX29mOiBjb25uZWN0QWNjb3VudElkLFxuICAgIHRyYW5zZmVyX2RhdGE6IHtcbiAgICAgIGRlc3RpbmF0aW9uOiBjb25uZWN0QWNjb3VudElkLFxuICAgIH0sXG4gICAgYXBwbGljYXRpb25fZmVlX2Ftb3VudDogYXBwbGljYXRpb25GZWUsXG4gICAgbWV0YWRhdGE6IG1ldGFkYXRhIHx8IHt9LFxuICB9O1xuXG4gIC8vIEZvciBvZmYtc2Vzc2lvbiBjaGFyZ2VzLCBzZXQgY29uZmlybWF0aW9uIG1ldGhvZCBhbmQgb2ZmX3Nlc3Npb24gZmxhZ1xuICBpZiAob2ZmU2Vzc2lvbikge1xuICAgIHBheW1lbnRJbnRlbnRQYXJhbXMuY29uZmlybWF0aW9uX21ldGhvZCA9ICdhdXRvbWF0aWMnO1xuICAgIHBheW1lbnRJbnRlbnRQYXJhbXMuY29uZmlybSA9IHRydWU7XG4gICAgcGF5bWVudEludGVudFBhcmFtcy5vZmZfc2Vzc2lvbiA9IHRydWU7XG4gICAgcGF5bWVudEludGVudFBhcmFtcy5wYXltZW50X21ldGhvZF9vcHRpb25zID0ge1xuICAgICAgY2FyZDoge1xuICAgICAgICByZXF1ZXN0X3RocmVlX2Rfc2VjdXJlOiAnYXV0b21hdGljJyxcbiAgICAgIH0sXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBwYXltZW50SW50ZW50UGFyYW1zLmNvbmZpcm1hdGlvbl9tZXRob2QgPSAnbWFudWFsJztcbiAgICBwYXltZW50SW50ZW50UGFyYW1zLmNvbmZpcm0gPSB0cnVlO1xuICB9XG5cbiAgY29uc3QgcGF5bWVudEludGVudCA9IGF3YWl0IHN0cmlwZS5wYXltZW50SW50ZW50cy5jcmVhdGUocGF5bWVudEludGVudFBhcmFtcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXltZW50SW50ZW50SWQ6IHBheW1lbnRJbnRlbnQuaWQsXG4gICAgY2xpZW50U2VjcmV0OiBwYXltZW50SW50ZW50LmNsaWVudF9zZWNyZXQgfHwgJycsXG4gICAgc3RhdHVzOiBwYXltZW50SW50ZW50LnN0YXR1cyxcbiAgICByZXF1aXJlc0FjdGlvbjogcGF5bWVudEludGVudC5zdGF0dXMgPT09ICdyZXF1aXJlc19hY3Rpb24nIHx8IHBheW1lbnRJbnRlbnQuc3RhdHVzID09PSAncmVxdWlyZXNfcGF5bWVudF9tZXRob2QnLFxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJlZnVuZCBmb3IgYSBQYXltZW50SW50ZW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVSZWZ1bmQoXG4gIHBheW1lbnRJbnRlbnRJZDogc3RyaW5nLFxuICBhbW91bnQ/OiBudW1iZXIgLy8gb3B0aW9uYWwgYW1vdW50IHRvIHJlZnVuZCAocGFydGlhbCByZWZ1bmQpLCBpZiBub3QgcHJvdmlkZWQsIGZ1bGwgcmVmdW5kXG4pOiBQcm9taXNlPHsgcmVmdW5kSWQ6IHN0cmluZzsgYW1vdW50OiBudW1iZXIgfT4ge1xuICBjb25zdCBzdHJpcGUgPSBnZXRTdHJpcGVDbGllbnQoKTtcblxuICBjb25zdCByZWZ1bmRQYXJhbXM6IFN0cmlwZS5SZWZ1bmRDcmVhdGVQYXJhbXMgPSB7XG4gICAgcGF5bWVudF9pbnRlbnQ6IHBheW1lbnRJbnRlbnRJZCxcbiAgfTtcblxuICBpZiAoYW1vdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZWZ1bmRQYXJhbXMuYW1vdW50ID0gYW1vdW50O1xuICB9XG5cbiAgY29uc3QgcmVmdW5kID0gYXdhaXQgc3RyaXBlLnJlZnVuZHMuY3JlYXRlKHJlZnVuZFBhcmFtcyk7XG5cbiAgcmV0dXJuIHtcbiAgICByZWZ1bmRJZDogcmVmdW5kLmlkLFxuICAgIGFtb3VudDogcmVmdW5kLmFtb3VudCxcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgcGF5bWVudCBtZXRob2QgZnJvbSBhIFNldHVwSW50ZW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQYXltZW50TWV0aG9kRnJvbVNldHVwSW50ZW50KFxuICBzZXR1cEludGVudElkOiBzdHJpbmdcbik6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICBjb25zdCBzdHJpcGUgPSBnZXRTdHJpcGVDbGllbnQoKTtcblxuICBjb25zdCBzZXR1cEludGVudCA9IGF3YWl0IHN0cmlwZS5zZXR1cEludGVudHMucmV0cmlldmUoc2V0dXBJbnRlbnRJZCk7XG5cbiAgaWYgKHR5cGVvZiBzZXR1cEludGVudC5wYXltZW50X21ldGhvZCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc2V0dXBJbnRlbnQucGF5bWVudF9tZXRob2Q7XG4gIH1cblxuICBpZiAoc2V0dXBJbnRlbnQucGF5bWVudF9tZXRob2QpIHtcbiAgICByZXR1cm4gc2V0dXBJbnRlbnQucGF5bWVudF9tZXRob2QuaWQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBWZXJpZnkgYSBDb25uZWN0IGFjY291bnQgaXMgYWN0aXZlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlDb25uZWN0QWNjb3VudChhY2NvdW50SWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHN0cmlwZSA9IGdldFN0cmlwZUNsaWVudCgpO1xuICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCBzdHJpcGUuYWNjb3VudHMucmV0cmlldmUoYWNjb3VudElkKTtcblxuICAgIHJldHVybiBhY2NvdW50LmRldGFpbHNfc3VibWl0dGVkICYmIGFjY291bnQuY2hhcmdlc19lbmFibGVkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyBDb25uZWN0IGFjY291bnQ6JywgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4iXSwibmFtZXMiOlsiU3RyaXBlIiwic3RyaXBlU2VjcmV0S2V5IiwicHJvY2VzcyIsImVudiIsIlNUUklQRV9TRUNSRVRfS0VZIiwiY29uc29sZSIsIndhcm4iLCJnZXRTdHJpcGVDbGllbnQiLCJFcnJvciIsImFwaVZlcnNpb24iLCJjcmVhdGVDb25uZWN0QWNjb3VudCIsInVzZXJJZCIsImVtYWlsIiwic3RyaXBlIiwiYWNjb3VudCIsImFjY291bnRzIiwiY3JlYXRlIiwidHlwZSIsImNhcGFiaWxpdGllcyIsImNhcmRfcGF5bWVudHMiLCJyZXF1ZXN0ZWQiLCJ0cmFuc2ZlcnMiLCJtZXRhZGF0YSIsInVzZXJfaWQiLCJpZCIsImNyZWF0ZUFjY291bnRMaW5rIiwiYWNjb3VudElkIiwicmV0dXJuVXJsIiwicmVmcmVzaFVybCIsImFjY291bnRMaW5rIiwiYWNjb3VudExpbmtzIiwicmV0dXJuX3VybCIsInJlZnJlc2hfdXJsIiwidXJsIiwiY3JlYXRlT3JHZXRDdXN0b21lciIsIm5hbWUiLCJleGlzdGluZ0N1c3RvbWVycyIsImN1c3RvbWVycyIsImxpc3QiLCJsaW1pdCIsImRhdGEiLCJsZW5ndGgiLCJjdXN0b21lciIsImNyZWF0ZVNldHVwSW50ZW50IiwiY3VzdG9tZXJJZCIsInNldHVwSW50ZW50Iiwic2V0dXBJbnRlbnRzIiwicGF5bWVudF9tZXRob2RfdHlwZXMiLCJzZXR1cEludGVudElkIiwiY2xpZW50U2VjcmV0IiwiY2xpZW50X3NlY3JldCIsImNyZWF0ZVN1YnNjcmlwdGlvbiIsInByaWNlSWQiLCJwYXltZW50TWV0aG9kSWQiLCJzdWJzY3JpcHRpb25QYXJhbXMiLCJpdGVtcyIsInByaWNlIiwicGF5bWVudF9zZXR0aW5ncyIsInNhdmVfZGVmYXVsdF9wYXltZW50X21ldGhvZCIsImV4cGFuZCIsInRyaWFsX3BlcmlvZF9kYXlzIiwiZGVmYXVsdF9wYXltZW50X21ldGhvZCIsInBheW1lbnRfYmVoYXZpb3IiLCJzdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb25zIiwic3Vic2NyaXB0aW9uSWQiLCJzdGF0dXMiLCJjdXJyZW50X3BlcmlvZF9lbmQiLCJ0cmlhbF9lbmQiLCJjcmVhdGVQYXltZW50SW50ZW50IiwicGFyYW1zIiwiYW1vdW50IiwiY29ubmVjdEFjY291bnRJZCIsImFwcGxpY2F0aW9uRmVlIiwib2ZmU2Vzc2lvbiIsInBheW1lbnRJbnRlbnRQYXJhbXMiLCJjdXJyZW5jeSIsInBheW1lbnRfbWV0aG9kIiwib25fYmVoYWxmX29mIiwidHJhbnNmZXJfZGF0YSIsImRlc3RpbmF0aW9uIiwiYXBwbGljYXRpb25fZmVlX2Ftb3VudCIsImNvbmZpcm1hdGlvbl9tZXRob2QiLCJjb25maXJtIiwib2ZmX3Nlc3Npb24iLCJwYXltZW50X21ldGhvZF9vcHRpb25zIiwiY2FyZCIsInJlcXVlc3RfdGhyZWVfZF9zZWN1cmUiLCJwYXltZW50SW50ZW50IiwicGF5bWVudEludGVudHMiLCJwYXltZW50SW50ZW50SWQiLCJyZXF1aXJlc0FjdGlvbiIsImNyZWF0ZVJlZnVuZCIsInJlZnVuZFBhcmFtcyIsInBheW1lbnRfaW50ZW50IiwidW5kZWZpbmVkIiwicmVmdW5kIiwicmVmdW5kcyIsInJlZnVuZElkIiwiZ2V0UGF5bWVudE1ldGhvZEZyb21TZXR1cEludGVudCIsInJldHJpZXZlIiwidmVyaWZ5Q29ubmVjdEFjY291bnQiLCJkZXRhaWxzX3N1Ym1pdHRlZCIsImNoYXJnZXNfZW5hYmxlZCIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/stripe.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/timezone.ts":
/*!*****************************!*\
  !*** ./src/lib/timezone.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatInTimeZone: () => (/* binding */ formatInTimeZone),\n/* harmony export */   timeStringToMinutes: () => (/* binding */ timeStringToMinutes),\n/* harmony export */   zonedMinutesToDate: () => (/* binding */ zonedMinutesToDate)\n/* harmony export */ });\nfunction timeStringToMinutes(time) {\n    const [hours = \"0\", minutes = \"0\"] = time.split(\":\");\n    return parseInt(hours, 10) * 60 + parseInt(minutes, 10);\n}\nfunction zonedMinutesToDate(date, minutes, timeZone) {\n    const baseParts = getDateParts(date, timeZone);\n    const hours = Math.floor(minutes / 60);\n    const mins = minutes % 60;\n    const utcDate = new Date(Date.UTC(baseParts.year, baseParts.month - 1, baseParts.day, hours, mins));\n    const offset = getOffsetMinutes(utcDate, timeZone);\n    return new Date(utcDate.getTime() - offset * 60000);\n}\nfunction formatInTimeZone(isoString, timeZone, options) {\n    // Handle both string and Date inputs\n    let date;\n    if (isoString instanceof Date) {\n        date = isoString;\n    } else if (typeof isoString === \"string\") {\n        // Validate string is not empty\n        if (!isoString || isoString.trim() === \"\") {\n            console.error(`[formatInTimeZone] Empty date string provided`);\n            return \"Invalid Date\";\n        }\n        date = new Date(isoString);\n    } else {\n        console.error(`[formatInTimeZone] Invalid input type:`, typeof isoString, isoString);\n        return \"Invalid Date\";\n    }\n    // Validate the date\n    if (isNaN(date.getTime())) {\n        console.error(`[formatInTimeZone] Invalid date value:`, isoString);\n        return \"Invalid Date\";\n    }\n    // Handle string format option (like \"yyyy-MM-dd\")\n    if (typeof options === \"string\") {\n        // For simple date format strings, use a basic formatter\n        const formatter = new Intl.DateTimeFormat(\"en-US\", {\n            timeZone,\n            year: \"numeric\",\n            month: \"2-digit\",\n            day: \"2-digit\"\n        });\n        const parts = formatter.formatToParts(date);\n        const year = parts.find((p)=>p.type === \"year\")?.value || \"\";\n        const month = parts.find((p)=>p.type === \"month\")?.value || \"\";\n        const day = parts.find((p)=>p.type === \"day\")?.value || \"\";\n        // Replace format string placeholders\n        return options.replace(\"yyyy\", year).replace(\"MM\", month).replace(\"dd\", day);\n    }\n    // Handle Intl.DateTimeFormatOptions\n    const formatter = new Intl.DateTimeFormat(\"en-US\", {\n        timeZone,\n        ...options\n    });\n    return formatter.format(date);\n}\nfunction getDateParts(date, timeZone) {\n    const formatter = new Intl.DateTimeFormat(\"en-US\", {\n        timeZone,\n        year: \"numeric\",\n        month: \"2-digit\",\n        day: \"2-digit\"\n    });\n    const parts = formatter.formatToParts(date);\n    return {\n        year: Number(parts.find((part)=>part.type === \"year\")?.value ?? date.getUTCFullYear()),\n        month: Number(parts.find((part)=>part.type === \"month\")?.value ?? date.getUTCMonth() + 1),\n        day: Number(parts.find((part)=>part.type === \"day\")?.value ?? date.getUTCDate())\n    };\n}\nfunction getOffsetMinutes(date, timeZone) {\n    const formatter = new Intl.DateTimeFormat(\"en-US\", {\n        timeZone,\n        year: \"numeric\",\n        month: \"2-digit\",\n        day: \"2-digit\",\n        hour: \"2-digit\",\n        minute: \"2-digit\",\n        hourCycle: \"h23\"\n    });\n    const parts = formatter.formatToParts(date);\n    const year = Number(parts.find((part)=>part.type === \"year\")?.value ?? date.getUTCFullYear());\n    const month = Number(parts.find((part)=>part.type === \"month\")?.value ?? date.getUTCMonth() + 1);\n    const day = Number(parts.find((part)=>part.type === \"day\")?.value ?? date.getUTCDate());\n    const hour = Number(parts.find((part)=>part.type === \"hour\")?.value ?? date.getUTCHours());\n    const minute = Number(parts.find((part)=>part.type === \"minute\")?.value ?? date.getUTCMinutes());\n    const asUTC = Date.UTC(year, month - 1, day, hour, minute);\n    return (asUTC - date.getTime()) / 60000;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBT1IsTUFBTUUsSUFBSSxDQUFDLENBQUNPLE9BQVNBLEtBQUtMLElBQUksS0FBSyxXQUFXQyxTQUFTL0IsS0FBSzJDLGFBQWE7SUFDL0YsTUFBTUMsUUFBUXBDLEtBQUtDLEdBQUcsQ0FBQ0MsTUFBTUMsUUFBUSxHQUFHQyxLQUFLMkIsTUFBTUM7SUFDbkQsT0FBTyxDQUFDSSxRQUFRNUMsS0FBS2UsT0FBTyxFQUFDLElBQUs7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9zcmMvbGliL3RpbWV6b25lLnRzP2ZkYjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIHRpbWVTdHJpbmdUb01pbnV0ZXModGltZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgW2hvdXJzID0gXCIwXCIsIG1pbnV0ZXMgPSBcIjBcIl0gPSB0aW1lLnNwbGl0KFwiOlwiKTtcbiAgcmV0dXJuIHBhcnNlSW50KGhvdXJzLCAxMCkgKiA2MCArIHBhcnNlSW50KG1pbnV0ZXMsIDEwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHpvbmVkTWludXRlc1RvRGF0ZShkYXRlOiBEYXRlLCBtaW51dGVzOiBudW1iZXIsIHRpbWVab25lOiBzdHJpbmcpOiBEYXRlIHtcbiAgY29uc3QgYmFzZVBhcnRzID0gZ2V0RGF0ZVBhcnRzKGRhdGUsIHRpbWVab25lKTtcbiAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKG1pbnV0ZXMgLyA2MCk7XG4gIGNvbnN0IG1pbnMgPSBtaW51dGVzICUgNjA7XG4gIGNvbnN0IHV0Y0RhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyhiYXNlUGFydHMueWVhciwgYmFzZVBhcnRzLm1vbnRoIC0gMSwgYmFzZVBhcnRzLmRheSwgaG91cnMsIG1pbnMpKTtcbiAgY29uc3Qgb2Zmc2V0ID0gZ2V0T2Zmc2V0TWludXRlcyh1dGNEYXRlLCB0aW1lWm9uZSk7XG4gIHJldHVybiBuZXcgRGF0ZSh1dGNEYXRlLmdldFRpbWUoKSAtIG9mZnNldCAqIDYwXzAwMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRJblRpbWVab25lKFxuICBpc29TdHJpbmc6IHN0cmluZyB8IERhdGUsXG4gIHRpbWVab25lOiBzdHJpbmcsXG4gIG9wdGlvbnM6IEludGwuRGF0ZVRpbWVGb3JtYXRPcHRpb25zIHwgc3RyaW5nXG4pOiBzdHJpbmcge1xuICAvLyBIYW5kbGUgYm90aCBzdHJpbmcgYW5kIERhdGUgaW5wdXRzXG4gIGxldCBkYXRlOiBEYXRlO1xuICBpZiAoaXNvU3RyaW5nIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIGRhdGUgPSBpc29TdHJpbmc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGlzb1N0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBWYWxpZGF0ZSBzdHJpbmcgaXMgbm90IGVtcHR5XG4gICAgaWYgKCFpc29TdHJpbmcgfHwgaXNvU3RyaW5nLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFtmb3JtYXRJblRpbWVab25lXSBFbXB0eSBkYXRlIHN0cmluZyBwcm92aWRlZGApO1xuICAgICAgcmV0dXJuICdJbnZhbGlkIERhdGUnO1xuICAgIH1cbiAgICBkYXRlID0gbmV3IERhdGUoaXNvU3RyaW5nKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKGBbZm9ybWF0SW5UaW1lWm9uZV0gSW52YWxpZCBpbnB1dCB0eXBlOmAsIHR5cGVvZiBpc29TdHJpbmcsIGlzb1N0cmluZyk7XG4gICAgcmV0dXJuICdJbnZhbGlkIERhdGUnO1xuICB9XG4gIFxuICAvLyBWYWxpZGF0ZSB0aGUgZGF0ZVxuICBpZiAoaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgY29uc29sZS5lcnJvcihgW2Zvcm1hdEluVGltZVpvbmVdIEludmFsaWQgZGF0ZSB2YWx1ZTpgLCBpc29TdHJpbmcpO1xuICAgIHJldHVybiAnSW52YWxpZCBEYXRlJztcbiAgfVxuICBcbiAgLy8gSGFuZGxlIHN0cmluZyBmb3JtYXQgb3B0aW9uIChsaWtlIFwieXl5eS1NTS1kZFwiKVxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gRm9yIHNpbXBsZSBkYXRlIGZvcm1hdCBzdHJpbmdzLCB1c2UgYSBiYXNpYyBmb3JtYXR0ZXJcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHsgXG4gICAgICB0aW1lWm9uZSxcbiAgICAgIHllYXI6ICdudW1lcmljJyxcbiAgICAgIG1vbnRoOiAnMi1kaWdpdCcsXG4gICAgICBkYXk6ICcyLWRpZ2l0J1xuICAgIH0pO1xuICAgIGNvbnN0IHBhcnRzID0gZm9ybWF0dGVyLmZvcm1hdFRvUGFydHMoZGF0ZSk7XG4gICAgY29uc3QgeWVhciA9IHBhcnRzLmZpbmQocCA9PiBwLnR5cGUgPT09ICd5ZWFyJyk/LnZhbHVlIHx8ICcnO1xuICAgIGNvbnN0IG1vbnRoID0gcGFydHMuZmluZChwID0+IHAudHlwZSA9PT0gJ21vbnRoJyk/LnZhbHVlIHx8ICcnO1xuICAgIGNvbnN0IGRheSA9IHBhcnRzLmZpbmQocCA9PiBwLnR5cGUgPT09ICdkYXknKT8udmFsdWUgfHwgJyc7XG4gICAgXG4gICAgLy8gUmVwbGFjZSBmb3JtYXQgc3RyaW5nIHBsYWNlaG9sZGVyc1xuICAgIHJldHVybiBvcHRpb25zXG4gICAgICAucmVwbGFjZSgneXl5eScsIHllYXIpXG4gICAgICAucmVwbGFjZSgnTU0nLCBtb250aClcbiAgICAgIC5yZXBsYWNlKCdkZCcsIGRheSk7XG4gIH1cbiAgXG4gIC8vIEhhbmRsZSBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9uc1xuICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHsgdGltZVpvbmUsIC4uLm9wdGlvbnMgfSk7XG4gIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KGRhdGUpO1xufVxuXG5mdW5jdGlvbiBnZXREYXRlUGFydHMoZGF0ZTogRGF0ZSwgdGltZVpvbmU6IHN0cmluZykge1xuICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHtcbiAgICB0aW1lWm9uZSxcbiAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICBtb250aDogXCIyLWRpZ2l0XCIsXG4gICAgZGF5OiBcIjItZGlnaXRcIlxuICB9KTtcbiAgY29uc3QgcGFydHMgPSBmb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhkYXRlKTtcbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiBOdW1iZXIocGFydHMuZmluZCgocGFydCkgPT4gcGFydC50eXBlID09PSBcInllYXJcIik/LnZhbHVlID8/IGRhdGUuZ2V0VVRDRnVsbFllYXIoKSksXG4gICAgbW9udGg6IE51bWJlcihwYXJ0cy5maW5kKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwibW9udGhcIik/LnZhbHVlID8/IGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLFxuICAgIGRheTogTnVtYmVyKHBhcnRzLmZpbmQoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJkYXlcIik/LnZhbHVlID8/IGRhdGUuZ2V0VVRDRGF0ZSgpKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXRNaW51dGVzKGRhdGU6IERhdGUsIHRpbWVab25lOiBzdHJpbmcpOiBudW1iZXIge1xuICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHtcbiAgICB0aW1lWm9uZSxcbiAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICBtb250aDogXCIyLWRpZ2l0XCIsXG4gICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICBob3VyOiBcIjItZGlnaXRcIixcbiAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgIGhvdXJDeWNsZTogXCJoMjNcIlxuICB9KTtcbiAgY29uc3QgcGFydHMgPSBmb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhkYXRlKTtcbiAgY29uc3QgeWVhciA9IE51bWJlcihwYXJ0cy5maW5kKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwieWVhclwiKT8udmFsdWUgPz8gZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgY29uc3QgbW9udGggPSBOdW1iZXIocGFydHMuZmluZCgocGFydCkgPT4gcGFydC50eXBlID09PSBcIm1vbnRoXCIpPy52YWx1ZSA/PyBkYXRlLmdldFVUQ01vbnRoKCkgKyAxKTtcbiAgY29uc3QgZGF5ID0gTnVtYmVyKHBhcnRzLmZpbmQoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJkYXlcIik/LnZhbHVlID8/IGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgY29uc3QgaG91ciA9IE51bWJlcihwYXJ0cy5maW5kKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwiaG91clwiKT8udmFsdWUgPz8gZGF0ZS5nZXRVVENIb3VycygpKTtcbiAgY29uc3QgbWludXRlID0gTnVtYmVyKHBhcnRzLmZpbmQoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJtaW51dGVcIik/LnZhbHVlID8/IGRhdGUuZ2V0VVRDTWludXRlcygpKTtcbiAgY29uc3QgYXNVVEMgPSBEYXRlLlVUQyh5ZWFyLCBtb250aCAtIDEsIGRheSwgaG91ciwgbWludXRlKTtcbiAgcmV0dXJuIChhc1VUQyAtIGRhdGUuZ2V0VGltZSgpKSAvIDYwXzAwMDtcbn1cblxuXG4iXSwibmFtZXMiOlsidGltZVN0cmluZ1RvTWludXRlcyIsInRpbWUiLCJob3VycyIsIm1pbnV0ZXMiLCJzcGxpdCIsInBhcnNlSW50Iiwiem9uZWRNaW51dGVzVG9EYXRlIiwiZGF0ZSIsInRpbWVab25lIiwiYmFzZVBhcnRzIiwiZ2V0RGF0ZVBhcnRzIiwiTWF0aCIsImZsb29yIiwibWlucyIsInV0Y0RhdGUiLCJEYXRlIiwiVVRDIiwieWVhciIsIm1vbnRoIiwiZGF5Iiwib2Zmc2V0IiwiZ2V0T2Zmc2V0TWludXRlcyIsImdldFRpbWUiLCJmb3JtYXRJblRpbWVab25lIiwiaXNvU3RyaW5nIiwib3B0aW9ucyIsInRyaW0iLCJjb25zb2xlIiwiZXJyb3IiLCJpc05hTiIsImZvcm1hdHRlciIsIkludGwiLCJEYXRlVGltZUZvcm1hdCIsInBhcnRzIiwiZm9ybWF0VG9QYXJ0cyIsImZpbmQiLCJwIiwidHlwZSIsInZhbHVlIiwicmVwbGFjZSIsImZvcm1hdCIsIk51bWJlciIsInBhcnQiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImhvdXIiLCJtaW51dGUiLCJob3VyQ3ljbGUiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJhc1VUQyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/timezone.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@supabase","vendor-chunks/tslib","vendor-chunks/stripe","vendor-chunks/math-intrinsics","vendor-chunks/es-errors","vendor-chunks/qs","vendor-chunks/call-bind-apply-helpers","vendor-chunks/get-proto","vendor-chunks/object-inspect","vendor-chunks/has-symbols","vendor-chunks/gopd","vendor-chunks/function-bind","vendor-chunks/side-channel","vendor-chunks/side-channel-weakmap","vendor-chunks/side-channel-map","vendor-chunks/side-channel-list","vendor-chunks/hasown","vendor-chunks/get-intrinsic","vendor-chunks/es-object-atoms","vendor-chunks/es-define-property","vendor-chunks/dunder-proto","vendor-chunks/call-bound"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute&page=%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fpublic%2F%5Bslug%5D%2Fbookings%2Froute.ts&appDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2F3017387smacbookm%2FDownloads%2FCareer%2FTithi%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();