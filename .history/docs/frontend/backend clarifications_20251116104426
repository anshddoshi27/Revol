Auth and tenancy

Ground rules (your clarified model)

One user = one business.

Only one login per business (the ‚Äúowner‚Äù account).

No staff authentication; in real life, a receptionist would just use the owner‚Äôs credentials.

No dashboard/tenant picker ‚Äì after login, the owner goes straight to their admin view.

Customers never sign in. They just fill name / phone / email when booking; that data is stored on the booking and visible in the owner‚Äôs ‚Äúpast bookings‚Äù view.

With that in mind, here‚Äôs the updated breakdown of what I‚Äôd do for auth & tenancy.

1. Auth style: Sessions vs JWTs
What the app actually needs

A simple, secure way for the owner to log in.

Authenticated API calls from the frontend to:

fetch bookings,

manage services/availability,

see past bookings, etc.

Public booking flow that does not require login (just form submissions).

Options

Option A ‚Äì Traditional server sessions

Browser stores a session cookie.

Backend keeps a session row (user_id, expiry, etc.).

Pros:

Very easy mental model.

Easy to kill all sessions.

Cons:

More awkward if you ever want:

mobile apps,

fully decoupled API,

serverless / edge compute.

Not aligned with Supabase‚Äôs ‚ÄúJWT + RLS‚Äù sweet spot.

Option B ‚Äì JWT-based auth (Supabase style)

On login, Supabase issues:

a short-lived access token (JWT),

a refresh token.

Frontend attaches access token to requests.

DB uses JWT + RLS to only return the current user‚Äôs data.

Pros:

Built-in with Supabase.

Works great for SPAs and APIs.

Plays perfectly with Postgres RLS for isolation.

Cons:

Token/refresh flow is conceptually more complex than just ‚Äúsession cookie.‚Äù

What I‚Äôd choose for Tithi

üëâ JWT-based auth using Supabase Auth.

Why:

You‚Äôre already committing to Supabase and Postgres.

You still want a clean API surface & good security story.

Even though you only have one owner per business, you still have many businesses/users, so per-user isolation matters.

We can keep the mental model simple:

owner logs in ‚Üí frontend gets Supabase session ‚Üí calls APIs as that user.

2. Refresh strategy
Options

Option A ‚Äì Long-lived single token, no refresh

Access token lives for days/weeks.

Easier, but if it leaks, attacker has a lot of time.

Option B ‚Äì Short-lived access token + long-lived refresh token

Access token: 5‚Äì15 minutes.

Refresh token: 30‚Äì90 days.

Frontend silently refreshes in the background.

If you revoke the refresh token, attacker can‚Äôt keep renewing.

What I‚Äôd choose for Tithi

üëâ Short-lived access tokens + longer-lived refresh tokens (Supabase default).

Why:

You get good security with almost no extra work, because Supabase already handles this pattern.

The owner‚Äôs experience is still smooth:

They stay logged in for a long time (thanks to refresh token).

If something looks wrong, we can invalidate refresh tokens (e.g., on password reset).

3. MFA (Multi-Factor Authentication)
Why MFA slows v1

Even a basic MFA setup comes with a lot of extra surface area:

Extra flows:

Enable MFA.

Verify a 6-digit code on login.

Disable MFA.

Reset/recover if user loses their device.

Data to manage:

TOTP secrets or phone numbers.

Backup codes for recovery.

Logs of failed attempts.

Edge cases:

What happens after too many failed codes?

What if user changes their phone number?

How does support help them recover?

That‚Äôs all on top of normal login/password flows you already have to get right.

What I‚Äôd choose for Tithi

üëâ Skip MFA for v1.

Tithi v1 is small-surface: one owner per business, no staff accounts, no client logins.

You can get very decent security from:

strong passwords,

short-lived access tokens,

secure Stripe integration (Stripe stores card data, not you).

In a later phase, when you want ‚Äúserious security hardening,‚Äù we can:

add an mfa_methods table,

implement TOTP/email OTP,

expose it in the admin UI.

For now, it is more important to ship a working product than to build full enterprise-style auth.

4. Tenant isolation: how to separate businesses

Your reality:

Each user owns exactly one business.

No user ever needs to switch businesses.

But there are many users, each with their own data.

So ‚Äúmulti-tenant‚Äù for you basically means ‚Äúeach user must only ever see their own rows.‚Äù

Options

Option A ‚Äì App-level filtering

Every query manually filters by user_id:

SELECT * FROM bookings WHERE user_id = current_user_id.

Pros:

Simple to understand.

Cons:

If you forget WHERE user_id = ... even once, you can leak data.

As features grow, this risk increases.

Option B ‚Äì Postgres RLS (Row-Level Security)

Every table that belongs to an owner has user_id.

You define policies like:

USING (user_id = auth.uid())

Postgres itself refuses to return rows for other users, even if you write a bad query.

Pros:

Very strong safety net.

Designed to work with Supabase (this is their main pattern).

Cons:

Initial policy setup is an extra step.

What I‚Äôd choose for Tithi

üëâ Use Postgres RLS with user_id as the isolation key.

Concrete shape:

users table (Supabase auth users).

businesses table with a user_id column (1‚Äì1).

services, availability_rules, bookings, etc. all have user_id.

RLS policy: user_id = auth.uid() on each of these tables.

This keeps your model extremely simple:

No tenant picker.

No ‚Äúactive tenant‚Äù concept.

Just ‚Äúrows belong to user X, and Postgres will only show user X their own rows.‚Äù

5. Enforcing tenant context in code

Given the above, the ‚Äútenant context‚Äù is basically just:

‚ÄúWhich user is making this request?‚Äù

Since one user = one business, we do not need any extra tension around tenant IDs.

How it works

The frontend uses Supabase Auth ‚Üí requests include a JWT with sub = user_id.

RLS policies use auth.uid() to get that user_id.

Each table that stores private admin data includes user_id.

Examples:

businesses: one row per user.

bookings: each booking has user_id referencing the owner.

Everything you do in code is now:

‚ÄúJust query the table; RLS ensures the rows belong to the logged-in user.‚Äù

No need for:

explicit tenant headers,

active tenant switching,

complicated scoping logic.

6. Roles & staff accounts

Your clarified stance:

No staff logins, full stop.

If a receptionist needs access, they‚Äôll just use the owner‚Äôs credentials.

Staff exist only for defining availability / performing services, not as authenticated users.

Options

Option A ‚Äì Overengineering roles

Create roles, user_tenant_roles, etc. now.

Model owners and staff as separate users in auth, etc.

Pros:

Very flexible later for permissioning.

Cons:

Completely unnecessary for your current, real-world usage model.

Adds conceptual complexity without immediate payoff.

Option B ‚Äì Single owner + ‚Äústaff as data only‚Äù

users table: only owner accounts.

businesses table: one per user.

staff table: contains staff members for that business:

name, color, calendar, etc.

linked via user_id or business_id.

Staff never authenticate; they are just entities for availability and bookings.

What I‚Äôd choose for Tithi

üëâ Option B ‚Äì owner-only auth; staff are just rows, not users.

Why:

Matches exactly how you expect real users to behave.

Avoids a bunch of role/permission complexity.

Still lets you:

assign bookings to a specific staff member,

define availability by staff,

show ‚ÄúStaff A‚Äôs calendar‚Äù in the admin view.

So the only ‚Äúrole‚Äù we really care about is implicit: authenticated user = owner.

7. Session & device management

Your model:

One owner per business.

A receptionist might share the same login.

We don‚Äôt need enterprise ‚Äúsession dashboards‚Äù on day one.

Options

Option A ‚Äì Minimal v1

Use Supabase Auth sessions as-is.

Provide:

login,

logout,

password reset.

No visible UI for ‚Äúactive devices.‚Äù

Option B ‚Äì Fully-fledged device/session management

Table of active refresh tokens/sessions.

UI listing devices, IP, last seen.

‚ÄúLog out of all other devices‚Äù button.

What I‚Äôd choose for Tithi

üëâ Minimal v1, but store enough data for future improvements.

Let Supabase handle session + refresh token storage internally.

You don‚Äôt need a ‚Äúdevices‚Äù screen now.

If you later want to:

tighten security,

show sessions,

or support ‚Äúlog out everywhere,‚Äù
you can layer that on when it becomes a real need.

Final shape for auth & tenancy in Tithi v1

Putting it all together, here‚Äôs the clean, updated plan that matches your clarified app:

Auth style

Use Supabase Auth with JWTs.

One users row per owner.

Login ‚Üí directly to admin view.

Refresh strategy

Short-lived access tokens + long-lived refresh tokens (Supabase default).

Owner enjoys ‚Äústay logged in‚Äù behavior without giving up too much security.

MFA

Not in v1.

Can be added later as a dedicated ‚Äúsecurity upgrade‚Äù phase.

Tenant isolation

Each important table (businesses, services, availability, bookings, etc.) gets a user_id column.

Use Postgres RLS so auth.uid() can only see its own rows.

Tenant context in code

No tenant picker; no multiple businesses per user.

Backend just trusts auth.uid() and RLS guarantees isolation.

Roles & staff

Only owners authenticate.

staff exist only as data tied to the owner‚Äôs business, for availability and bookings.

No extra role tables required.

Sessions/devices

Use Supabase‚Äôs session + refresh system.

Provide basic login/logout/password reset in UI; skip session device listing for v1.

If you want, next we can turn this into:

a short ‚ÄúAuth & Tenancy Spec‚Äù doc you can paste into your repo (like docs/backend/auth_and_tenancy.md), written in super clear non-coder language so you + Cursor + any engineer are all aligned.


------------

Database Modeling
One owner = one account = one business

Only the owner can log into admin (no staff logins)

No dashboard; login ‚Üí straight to admin view

Customers never sign in; they just give name / phone / email at checkout

Card is saved at booking, but no money moves until the owner clicks Completed / No-Show / Cancelled / Refund on the Past Bookings page

frontend logistics

I‚Äôll give you:

The core entities + how they relate

Recommended enums

Table-by-table schema (with relationships, indexes, soft delete / versioning)

How RLS ties it all together

1. Core entities & relationships

With your updated reality, I‚Äôd simplify tenancy like this:

auth.users (Supabase) ‚Äî the owner login.

businesses ‚Äî exactly one row per user.

service_categories ‚Äî group services for the catalog.

services ‚Äî what customers actually book.

staff ‚Äî purely ‚Äúdata staff,‚Äù used for availability & assignment; no auth.

availability_rules ‚Äî ‚Äústaff X can do service Y at these times.‚Äù

customers ‚Äî name/email/phone + Stripe customer link.

bookings ‚Äî the appointment itself (service + staff + time + customer).

booking_payments ‚Äî how/when money moved for that booking.

policies ‚Äî the editable policies for that business (no-show, cancel, refund, cash).

policy_snapshots (embedded on booking) ‚Äî freeze what the customer agreed to.

gift_cards + gift_card_ledger ‚Äî balances & movements.

notification_templates ‚Äî what the owner configures in onboarding/admin.

notification_events ‚Äî log of actual sends.

Key idea: every tenant-owned table has user_id (auth.uid) and business_id, but RLS uses user_id as the isolation key. Business is just the ‚Äúbucket‚Äù under that owner.

2. Recommended enums

You can use Postgres enums or text + CHECK constraints. I‚Äôd do enums for clarity:

CREATE TYPE booking_status AS ENUM (
  'pending',      -- created, card saved, no money moved yet
  'scheduled',    -- same as pending but used if you want semantic diff
  'completed',
  'no_show',
  'cancelled',
  'refunded'
);

CREATE TYPE payment_status AS ENUM (
  'none',             -- no card saved / no payment expected
  'card_saved',       -- SetupIntent succeeded, card on file
  'charge_pending',   -- we are trying to charge
  'charged',          -- money captured
  'refunded',
  'failed'
);

CREATE TYPE money_action AS ENUM (
  'none',
  'completed_charge',   -- Completed button
  'no_show_fee',
  'cancel_fee',
  'refund'
);

CREATE TYPE notification_channel AS ENUM ('email', 'sms');
CREATE TYPE notification_category AS ENUM (
  'confirmation',
  'reminder',
  'follow_up',
  'cancellation',
  'reschedule',
  'completion'
);

CREATE TYPE notification_trigger AS ENUM (
  'booking_created',
  'booking_confirmed',
  'reminder_24h',
  'reminder_1h',
  'booking_cancelled',
  'booking_rescheduled',
  'booking_completed',
  'fee_charged',
  'refunded'
);

CREATE TYPE discount_type AS ENUM ('amount', 'percent');

3. Table-by-table schema

I‚Äôll describe each table with key columns, relationships, indexes, and soft-delete/versioning notes.

3.1 businesses

Purpose: bucket for everything under one owner.

Columns (core)

id uuid pk

user_id uuid not null ‚Äî references auth.users(id)

name text not null

dba_name text ‚Äî DBA

legal_name text

industry text

subdomain text unique not null ‚Äî used for {subdomain}.tithi.com

timezone text not null

phone text

support_email text

website_url text

street text, city text, state text, postal_code text, country text

brand_primary_color text

brand_secondary_color text

logo_url text

stripe_connect_account_id text

stripe_subscription_id text ‚Äî for the $11.99/mo plan

subscription_status text ‚Äî 'trial' | 'active' | 'paused' | 'canceled'

trial_ends_at timestamptz

created_at, updated_at timestamptz

deleted_at timestamptz (nullable; soft delete flag)

Constraints / indices

UNIQUE (user_id) ‚Äî enforce one business per owner.

UNIQUE (subdomain) ‚Äî one booking site per subdomain.

Index on (user_id) for RLS speed.

Soft delete / versioning

Business is soft-deleted by setting deleted_at.

RLS policy should also check deleted_at IS NULL.

3.2 service_categories

Purpose: groups of services (haircuts vs color, etc.).

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

name text not null

description text

color text

sort_order int ‚Äî for UI ordering

is_active boolean default true

created_at, updated_at, deleted_at

Relationships

business_id ‚Üí businesses(id)

user_id must match business.user_id (you can enforce via trigger or rely on app).

Indexes

(user_id, business_id)

(user_id, sort_order) for admin listing.

Soft delete

Use deleted_at + is_active; RLS filters deleted_at IS NULL for normal queries.

3.3 services

Purpose: the actual bookable things.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

category_id uuid not null

name text not null

description text

duration_min int not null

price_cents int not null

pre_appointment_instructions text

is_active boolean default true

created_at, updated_at, deleted_at

Relationships

category_id ‚Üí service_categories(id)

business_id / user_id ‚Üí businesses(id) and auth.users(id).

Indexes

(user_id, business_id, category_id)

(user_id, is_active) for catalog queries.

3.4 staff

Purpose: staff as data only (names, roles, colors). No login.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

name text not null

role text ‚Äî e.g. ‚Äústylist‚Äù, ‚Äútherapist‚Äù

color text ‚Äî for calendar lane color

notes text

is_active boolean default true

created_at, updated_at, deleted_at

Indexes

(user_id, business_id, is_active)

3.5 staff_services

Purpose: which staff can perform which services.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

staff_id uuid not null

service_id uuid not null

created_at

Constraints

UNIQUE (staff_id, service_id) ‚Äî no duplicates.

Foreign keys ‚Üí staff(id), services(id).

Indexes

(user_id, staff_id)

(user_id, service_id)

3.6 availability_rules

I‚Äôd follow your onboarding flow: availability is per service per staff, not generic shifts.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

staff_id uuid not null

service_id uuid not null

rule_type text not null ‚Äî 'weekly' | 'exception' | 'closure'

weekday smallint ‚Äî 0‚Äì6, for weekly rules

start_time time not null ‚Äî time in business timezone

end_time time not null

date date ‚Äî for exceptions/closures

capacity int default 1 ‚Äî if you ever support multiple at once

created_at, updated_at, deleted_at

Usage

Slot engine: for a given service_id and date, load rules for that service & staff, then generate slots.

Indexes

(user_id, service_id, staff_id, weekday)

(user_id, staff_id, date) for exceptions.

3.7 customers

Purpose: people booking appointments; no login.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

name text not null

email text not null

phone text

stripe_customer_id text ‚Äî link to Stripe

created_at, updated_at

Indexes

(user_id, email)

(user_id, phone)

(user_id, name) (for simple LIKE search in admin).

3.8 bookings

Purpose: the core appointment record.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

customer_id uuid not null

service_id uuid not null

staff_id uuid not null

status booking_status not null default 'pending'

start_at timestamptz not null ‚Äî UTC

end_at timestamptz not null

duration_min int not null

price_cents int not null ‚Äî base price at time of booking

final_price_cents int not null ‚Äî after gift cards / discounts

gift_card_id uuid (nullable)

gift_card_amount_applied_cents int default 0

notes text ‚Äî internal notes

source text not null default 'public' ‚Äî 'public' | 'admin'

policy_snapshot jsonb not null ‚Äî text & fee numbers as seen on checkout

consent_at timestamptz ‚Äî when they checked ‚ÄúI agree‚Äù

consent_ip text

consent_user_agent text

payment_status payment_status not null default 'card_saved'

last_money_action money_action not null default 'none'

created_at, updated_at, deleted_at

Relationships

FK to customers, services, staff, businesses.

Indexes

(user_id, business_id, start_at DESC) ‚Äî main ‚Äúcalendar / past bookings‚Äù queries.

(user_id, status, start_at DESC) ‚Äî filter by status quickly.

(user_id, customer_id, start_at DESC) ‚Äî customer history.

Why embed policy_snapshot?

Each booking keeps the exact policy text & fee values that the customer agreed to, so you never have ‚Äúpolicy changed later‚Äù disputes.

3.9 booking_payments

Purpose: track how money moves for each booking and wire it to Stripe.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

booking_id uuid not null

stripe_setup_intent_id text ‚Äî card saved at checkout

stripe_payment_intent_id text ‚Äî for a specific charge (completed/no-show/cancel)

last_payment_intent_id text ‚Äî if you want to track latest

amount_cents int not null ‚Äî amount of this transaction

money_action money_action not null ‚Äî why this was created

status payment_status not null

application_fee_cents int ‚Äî your 1% platform fee

stripe_fee_cents int

net_amount_cents int ‚Äî remainder to the business

currency text default 'usd'

created_at, updated_at

Behavior:

At checkout: create row with status='card_saved', stripe_setup_intent_id set, amount_cents = final_price_cents (for reference).

When owner presses:

Completed ‚Üí create new booking_payments row with money_action='completed_charge', amount_cents = final price (minus gift), status ends at 'charged'.

No-Show ‚Üí new row with money_action='no_show_fee', amount_cents = no-show fee calculated from policy snapshot.

Cancelled ‚Üí new row with money_action='cancel_fee', amount_cents = cancel fee.

Refund ‚Üí new row with money_action='refund', amount_cents = refund amount (positive int), status='refunded'.

bookings.payment_status & bookings.last_money_action are updated as a denormalized summary for quick display.

Indexes

(user_id, booking_id)

(user_id, created_at DESC)

UNIQUE (stripe_payment_intent_id) to avoid duplicates.

Idempotency key table (optional) if you want to be extra safe.

3.10 policies

Purpose: what owners configure in onboarding/admin for cancellation/no-show/refund/cash.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

version int not null ‚Äî bump on change

cancellation_policy_text text

no_show_policy_text text

refund_policy_text text

cash_policy_text text

no_show_fee_type discount_type default 'amount'

no_show_fee_amount_cents int default 0

no_show_fee_percent numeric(5,2) default 0.0

cancel_fee_type discount_type default 'amount'

cancel_fee_amount_cents int default 0

cancel_fee_percent numeric(5,2) default 0.0

is_active boolean default true

created_at, updated_at

Usage

The ‚Äúcurrent‚Äù policy is the row with highest version AND is_active = true.

When a booking is created, you copy text and numeric values into bookings.policy_snapshot.

Indexes

(user_id, business_id, is_active, version DESC)

3.11 gift_cards

Purpose: generate/store cards with balance.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

code text not null

discount_type discount_type not null ‚Äî 'amount' | 'percent'

initial_amount_cents int not null

current_balance_cents int not null ‚Äî only used for amount type

percent_off numeric(5,2) ‚Äî only used for percent type

expires_at timestamptz

is_active boolean default true

created_at, updated_at, deleted_at

Constraints / indexes

UNIQUE (user_id, code) ‚Äî codes unique per business.

Index (user_id, code) for lookup during checkout.

Index (user_id, expires_at) for cleanup.

3.12 gift_card_ledger

Purpose: audit changes to card balances.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

gift_card_id uuid not null

booking_id uuid ‚Äî nullable (purchase / admin adjustment may not have booking)

delta_cents int not null ‚Äî positive = added, negative = consumed

reason text ‚Äî 'purchase' | 'redemption' | 'refund_restore' | 'admin_adjust'

created_at

Indexes

(user_id, gift_card_id, created_at).

3.13 notification_templates

Purpose: onboarding step where owner configures templates + placeholders.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

name text not null ‚Äî internal label

channel notification_channel not null

category notification_category not null

trigger notification_trigger not null

subject text ‚Äî email only

body_markdown text not null ‚Äî with placeholders like ${customer.name}

is_enabled boolean default true

created_at, updated_at, deleted_at

Placeholders

You support placeholders like:

${customer.name}

${service.name}

${service.duration}

${service.price}

${booking.date}

${booking.time}

${business.name}

${booking.url}

At save time, the frontend can lint for unknown ${‚Ä¶} patterns; backend at send time fills them from bookings, customers, services, businesses.

Indexes

(user_id, trigger, is_enabled)

(user_id, category)

3.14 notification_events

Purpose: log sends for debugging/support.

Columns

id uuid pk

user_id uuid not null

business_id uuid not null

booking_id uuid (nullable)

template_id uuid (nullable if you ever send a system message)

channel notification_channel not null

to_address text not null ‚Äî email or phone

status text not null ‚Äî 'queued' | 'sent' | 'failed'

provider_message_id text

error_message text

sent_at timestamptz

created_at

Indexes

(user_id, booking_id)

(user_id, to_address, created_at DESC)

4. RLS, soft delete, and indexes (strategy)
RLS pattern (Supabase)

On every tenant-owned table, do:

Add user_id uuid not null.

Policy:

ALTER TABLE services ENABLE ROW LEVEL SECURITY;

CREATE POLICY "user_owns_row" ON services
USING (
  user_id = auth.uid()
  AND deleted_at IS NULL  -- when applicable
);


Same pattern for businesses, staff, availability_rules, customers, bookings, booking_payments, gift_cards, notification_templates, etc.

This keeps your mental model super simple:

‚ÄúIf auth.uid() doesn‚Äôt match row.user_id, Postgres won‚Äôt show you the row, even if your query is wrong.‚Äù

Given your ‚Äúone user = one business‚Äù rule, you do not need separate tenant IDs or business pickers to enforce isolation.

Soft delete

For most configuration tables (services, staff, categories, gift cards, notification templates):

Add deleted_at timestamptz.

Treat deleted_at IS NOT NULL as hidden from normal queries.

Only allow ‚Äúhard delete‚Äù for truly destructive actions (like business offboarding).

For bookings, I‚Äôd avoid soft delete entirely except for GDPR/account deletion; usually you never delete bookings, you just mark statuses.

Index strategy summary

Always index user_id on every multi-row table (fast RLS scans).

Time-series tables:

bookings(user_id, start_at DESC)

booking_payments(user_id, created_at DESC)

notification_events(user_id, created_at DESC)

Lookups:

customers(user_id, email), (user_id, phone)

gift_cards(user_id, code)

Availability:

availability_rules(user_id, service_id, staff_id, weekday)

Policies:

policies(user_id, business_id, is_active, version DESC)

This gives you fast queries that match your actual UI:

Past bookings paginated by date.

Search bookings by status & date.

Look up customers by email/phone.

Apply gift cards in checkout.

Generate slots by service/staff/day.

What you should actually do next

Lock in this simplified tenant model

Add user_id + RLS to all tables.

Enforce UNIQUE (user_id) on businesses.

Create the core tables in Supabase in roughly this order:

businesses, service_categories, services

staff, staff_services, availability_rules

customers, bookings, booking_payments

policies, gift_cards, gift_card_ledger

notification_templates, notification_events

Wire onboarding ‚Üí these tables exactly in the order of your 8 steps.

Wire booking flow:

Use services + availability_rules to build slots.

On checkout: create customer, booking, booking_payments (card saved), embed policy_snapshot.

Wire the Past Bookings page:

List from bookings ordered by start_at DESC, joined to customers, services, staff, booking_payments.

Buttons call endpoints that create new booking_payments rows and update bookings.status + payment_status.

-------------
Stripe & billing specifics
Yes ‚Äî Stripe Connect absolutely can power the payments in your booking flow, and the way we‚Äôve set things up is specifically to make that work.

Let me spell out how it fits together in Tithi with your current design.

1. What ‚ÄúStripe Connect powers their booking payments‚Äù actually means

For each business on Tithi, you will:

Create a Stripe Connect account for them during onboarding.

Store that as businesses.stripe_connect_account_id.

Then, in the public booking flow when a client books:

Tithi (your platform Stripe account) creates a SetupIntent or PaymentMethod for that client‚Äôs card.

When the owner later clicks Completed / No-show / Cancel (fee) on the money board, you create a PaymentIntent that:

Runs under your platform Stripe account,

But uses the connected account as the destination for funds.

So the business isn‚Äôt managing Stripe manually ‚Äî Tithi is the app, Stripe is the rail.

Yes, that is exactly how Stripe Connect is meant to be used for multi-tenant SaaS platforms.

2. How this works step-by-step in your booking flow

Using the schema we designed:

During onboarding

You send them through Stripe‚Äôs Connect onboarding (hosted flow).

When Stripe finishes, you save:

businesses.stripe_connect_account_id = 'acct_...'

Now Tithi knows:

‚ÄúFor this business, all payments should route through this connected Stripe account.‚Äù

During client booking (no money yet)

On your public booking page:

Customer picks service, time, etc.

You:

Create/find a customers row in your DB.

Create a bookings row with:

price_cents = base service price

final_price_cents = base minus any gift card/discount

Create a Stripe SetupIntent to save the card:

You can attach it to a Stripe Customer that represents this client for that business.

Store in booking_payments:

stripe_setup_intent_id

payment_status = 'card_saved'

amount_cents = final_price_cents (reference)

At this point:

Payment is not charged.

Card is ready to be charged later when the owner decides what to do.

This matches your requirement: ‚Äúmoney moves only when the owner clicks a button on the Past Bookings / money board.‚Äù

When the owner clicks a button in the admin money board

Say the owner hits Completed on a booking.

Backend:

Looks up:

the booking,

its final_price_cents,

the associated stripe_setup_intent_id / PaymentMethod.

Creates a PaymentIntent using:

amount = final_price_cents

currency = 'usd'

customer = the Stripe customer for that client

payment_method = saved card

Connect-specific fields:

on_behalf_of = business.stripe_connect_account_id

transfer_data[destination] = business.stripe_connect_account_id

application_fee_amount = platform_fee_cents (your 1%)

Confirms the PaymentIntent.

Writes a new booking_payments row:

booking_id = ...

stripe_payment_intent_id = 'pi_...'

amount_cents = final_price_cents

money_action = 'completed_charge'

status = 'charged'

application_fee_cents, stripe_fee_cents, net_amount_cents

Updates bookings:

status = 'completed'

payment_status = 'charged'

last_money_action = 'completed_charge'

Result:

Client‚Äôs card is charged via Stripe.

Business gets paid into their connected Stripe account.

You collect your platform fee automatically.

All of this is triggered from your booking flow + money board, no separate Stripe UI needed.

The exact same pattern works for:

No-show fee ‚Üí PaymentIntent with amount_cents = calculated no-show fee from policy_snapshot.

Cancel fee ‚Üí same idea.

Refund ‚Üí create a Stripe refund for the original PaymentIntent and log it in booking_payments as money_action = 'refund'.

3. Does this truly ‚Äúlet them use Stripe to power their payments page‚Äù?

Yes, in practice that means:

The public booking flow on Tithi:

Collects card details securely using Stripe elements or similar.

Saves the card and then charges it later.

The business owner:

Never has to configure Stripe manually outside onboarding.

Has all payments tied to their account so money goes to them, not you.

You:

Are compliant with Stripe‚Äôs Connect platform model.

Take a clean per-transaction fee without manually moving money.

As long as:

Each business has a valid stripe_connect_account_id, and

Your payment code always uses that when creating PaymentIntents,

‚Ä¶then Stripe Connect is powering their booking payments exactly the way you want.

If you want, I can next sketch the exact fields you should store for Stripe per business and per booking (including where to put stripe_customer_id, default payment method, etc.) so you have a concrete implementation checklist.
Alright, here‚Äôs the ‚ÄúStripe wiring spec‚Äù so you can literally see what to store where and how it all ties into your booking flow + Connect.

I‚Äôll break it into:

Fields to store per business

Fields to store per customer

Fields to store per booking

Fields to store per booking_payment

Optional but nice-to-have fields

Implementation checklist by flow

1. Stripe fields on businesses (owner-level)

These are about the owner‚Äôs Stripe Connect account + subscription.

Add to businesses:

stripe_connect_account_id text

The ID from Connect onboarding, e.g. acct_123.

Used in every PaymentIntent: on_behalf_of + transfer_data[destination].

stripe_customer_id text (optional but useful)

A Stripe Customer representing the business owner themselves, if you bill them (e.g., subscriptions directly).

Not required if you only use Stripe Billing with your own customer records, but nice if you charge them ‚Äúoff-session‚Äù.

stripe_subscription_id text

The subscription for Tithi‚Äôs $11.99/mo plan.

Created during onboarding when they enter their own card for Tithi.

stripe_price_id text

The price ID for your plan (e.g., price_abc123).

Not strictly required per business if it‚Äôs constant in code, but helpful if you ever support multiple plans.

stripe_default_payment_method_id text (optional)

The payment method you use to bill them for your SaaS fee.

Can also be fetched from the subscription in Stripe instead of storing here, but caching it is convenient.

These fields let you:

Know which Connect account to send booking revenue to.

Know how you bill the business owner for your platform fee (subscription).

2. Stripe fields on customers (client-level)

These are about clients who book appointments, not the owner.

Add to customers:

stripe_customer_id text

One Stripe Customer per (Tithi-)customer per business.

Lets you save multiple PaymentMethods (cards) for that client.

Used when creating SetupIntents and PaymentIntents.

You don‚Äôt need to store payment methods per customer in your DB; you can fetch them from Stripe when needed. But if you want to pin a default:

stripe_default_payment_method_id text (optional)

If you want ‚Äúpreferred card‚Äù behavior.

3. Stripe fields on bookings (appointment-level)

Keep bookings Stripe-related fields minimal. The heavy Stripe detail lives in booking_payments.

You already have:

price_cents int ‚Äî base price

final_price_cents int ‚Äî after gift card/discount

gift_card_id uuid

gift_card_amount_applied_cents int

payment_status payment_status

last_money_action money_action

You don‚Äôt need SetupIntent/PaymentIntent directly on bookings, because those belong in booking_payments. That keeps the booking ‚Äúclean‚Äù: it knows what should be charged, not all the Stripe plumbing.

So for bookings, you‚Äôre good with:

Amounts: price_cents, final_price_cents

Discount source: gift_card_*

Summary state: payment_status, last_money_action

4. Stripe fields on booking_payments (money-level)

This is where we store every Stripe object tied to a booking + why it exists.

On booking_payments:

stripe_setup_intent_id text

The SetupIntent used to save the card at checkout.

Usually created at booking time (public flow).

Only one is typically needed, but you might recreate in some edge cases.

stripe_payment_intent_id text

The PaymentIntent for this specific money event:

Completed charge

No-show fee

Cancellation fee

Refund

stripe_refund_id text (optional but nice)

If this row corresponds to a refund, store the Stripe Refund ID.

amount_cents int not null

The amount of this transaction (positive int).

For refunds, still store as positive int and use money_action = 'refund' to indicate direction.

money_action money_action not null

'completed_charge' | 'no_show_fee' | 'cancel_fee' | 'refund' | ...

status payment_status not null

'card_saved' | 'charge_pending' | 'charged' | 'refunded' | 'failed' etc.

application_fee_cents int

The fee you took as platform (e.g., 1% of amount_cents).

stripe_fee_cents int

The fee Stripe took (you can fetch from Stripe‚Äôs balance transaction, or leave null if you don‚Äôt care initially).

net_amount_cents int

Money that actually went to the business (amount - fees).

currency text default 'usd'

These fields make it trivial to:

Reconcile with Stripe‚Äôs dashboard.

Show ‚ÄúMoney timeline‚Äù per booking.

Know exactly what was charged/refunded and why.

5. Optional extra fields (only if you want them)

On booking_payments:

stripe_payment_method_id text

If you need to know exactly which card was used for a given charge.

Not strictly needed if you just look it up in Stripe using the PaymentIntent.

On gift_cards:

stripe_payment_intent_id text

If you sell gift cards via Stripe (clients pay to buy a card).

Lets you tie gift card purchase revenue to the right Stripe charge.

These are nice for deeper analytics / support, but not mandatory for a solid v1.

6. Implementation checklist by flow

Here‚Äôs the concrete ‚Äúdo this in code‚Äù flow, now that fields are settled.

A. Business onboarding (owner signup ‚Üí live account)

Owner signs up ‚Üí only auth.users exists.

Onboarding steps gather:

Business info

Branding

Categories + services

Staff

Availability

Policies

Stripe Connect onboarding:

Create / connect Stripe account ‚Üí get connect_account_id.

Save to draft or hold in memory until final commit.

Stripe subscription for Tithi:

Create Stripe Customer for business owner (if needed).

Create Subscription using stripe_price_id.

Save:

stripe_customer_id

stripe_subscription_id

stripe_default_payment_method_id (optional)

Final onboarding step:

In a transaction:

Create businesses row with:

user_id

stripe_connect_account_id

stripe_customer_id / stripe_subscription_id

all business details

Insert:

service_categories

services

staff + staff_services

availability_rules

policies

notification_templates

Show confetti screen:

‚ÄúBusiness is live‚Äù

Booking URL (from subdomain)

Button ‚Üí Admin view.

B. Client booking flow (public page, card saved only)

Client picks service, date/time, staff (or ‚Äúany‚Äù).

Backend:

Create/find customers row for this business:

If no stripe_customer_id yet:

Create Stripe Customer under your platform.

Save customers.stripe_customer_id.

Create a SetupIntent:

customer = customers.stripe_customer_id

payment_method_types = ['card']

usage = 'off_session' (since you‚Äôre going to charge later).

Frontend:

Use Stripe Elements to collect card.

Confirm SetupIntent, get success.

Backend:

Create bookings row:

price_cents from services.price_cents

final_price_cents after gift card

gift_card_* fields if used

policy_snapshot from current policies

status = 'pending'

payment_status = 'card_saved'

Create booking_payments row:

stripe_setup_intent_id

amount_cents = final_price_cents

money_action = 'none'

status = 'card_saved'

Now you‚Äôre in your comfortable state: booking exists, card saved, no money moved.

C. Admin money board actions (charge/refund)
1. Completed

When owner clicks Completed on a booking card:

Backend fetches:

booking (to get final_price_cents, customer_id, business_id)

business.stripe_connect_account_id

customers.stripe_customer_id

Payment method from Stripe (using SetupIntent or saved default).

Create a PaymentIntent on your platform account:

amount = booking.final_price_cents

currency = 'usd'

customer = customers.stripe_customer_id

payment_method = <from SetupIntent>

confirm = true

on_behalf_of = business.stripe_connect_account_id

transfer_data[destination] = business.stripe_connect_account_id

application_fee_amount = platform_fee_cents

On success:

Create booking_payments row:

stripe_payment_intent_id

amount_cents = final_price_cents

money_action = 'completed_charge'

status = 'charged'

Update bookings:

status = 'completed'

payment_status = 'charged'

last_money_action = 'completed_charge'

Same exact pattern, different money_action and amount for:

No-show fee:

Amount comes from policy_snapshot.no_show_fee_*.

money_action = 'no_show_fee'.

Cancellation fee:

Amount comes from policy_snapshot.cancel_fee_*.

money_action = 'cancel_fee'.

2. Refund

When owner hits Refund:

Look up the original booking_payments row (with status = 'charged').

Call Stripe refunds.create({ payment_intent: 'pi_...' }).

Insert a new booking_payments row:

stripe_refund_id

amount_cents = refunded amount

money_action = 'refund'

status = 'refunded'

Update bookings:

status = 'refunded' (or keep completed but with payment_status = 'refunded', depending on your UX).

payment_status = 'refunded'

last_money_action = 'refund'

That‚Äôs the full Stripe wiring:

Where each ID lives.

Which tables care about Stripe.

How Connect powers payments in your booking flow.

How that meshes with your onboarding + money board design.

If you want, next I can write the actual Supabase table definitions (SQL) for customers and booking_payments with these Stripe fields baked in, plus a sample query the admin view would run to render the money board cards.


---------------

API Contracts




---------
Notifications and Availability Engine



---------
Gift Cards and Policies and Compliance


------------

Operations and Tooling and Environment and Deployment and Testing and Seeding
